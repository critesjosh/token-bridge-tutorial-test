{"transpiled":true,"noir_version":"0.30.0+c363d6fb324a83b35cf5aa1bfd39f62b9198f0b6","name":"TokenBridge","functions":[{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":39,"start":0}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"},"return_witnesses":[472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928]},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":5,"start":4}],"caller_on_l1":[{"end":6,"start":5}],"inputs":[{"end":3,"start":0}],"nonce":[{"end":7,"start":6}],"recipient":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":41,"start":40}],"inputs":[{"end":39,"start":0}],"secret_for_L1_to_L2_message_consumption":[{"end":42,"start":41}],"secret_hash_for_redeeming_minted_notes":[{"end":40,"start":39}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"},"return_witnesses":[929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385]},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":3,"start":0}],"portal_address":[{"end":5,"start":4}],"token":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":42,"start":41}],"caller_on_l1":[{"end":43,"start":42}],"inputs":[{"end":39,"start":0}],"nonce":[{"end":44,"start":43}],"recipient":[{"end":41,"start":40}],"token":[{"end":40,"start":39}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"},"return_witnesses":[1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578]},"bytecode":"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","debug_symbols":"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Vam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRjZob1ai5UY2aG9WouVFtYz5rGzU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqU3OjOjU3qlNzozo1N6pvzGdtp+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kaFjRocdQuf+bS9hc983N7CZz5vb+EzH7i38JlP3Fv4zEfuLXzmM/cWPvOhewuf+9SlRkjdwuc+dakhUrfwuU9daozULXzuU5caJHULn/vUpUZJ3cLnPnWpYVK34LhPXWqc1C047lOXGih1C4771KVGSt2C4z51qaFSt+C4T11qrNQtfO5TlxosdQuf+9SlRkvdwuc+danhUrfwuU9darzULXzuU5caMHULn/vUpUZM3cLnPnWpIVO38LlPXWrM1C187lOXGjR1C5/71KVGTd3C5z51qWFTt/C5T11q3NQtfO5Tlxo4dQuf+9SlRk7dwuc+damhU7fwuU9dauzULXzuU5caPHULn/vUpUZP3cLnPnWp4VO38LlPXWr81C187lOXGkB1C5/71KVGUN3C5z51qSFUt/C5T11qDNUtfO5TlxpEdQuf+9SlRlHdwuc+dalhVLfwuU9dahzVLXzuU5caSHULn/vUpUZS3cLnPnWpoVS38LlPXWos1S187lOXGkx1C5/71KVGU93Cpz51AzebKnCzqQI3mypws6nCRn3qBm42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV5GZTRW42VeRmU0VuNlXcqE/dyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaZK3GyqxM2mStxsqsTNpkob9ambuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VTCzaYSbjaVcLOphJtNJRv1qSvcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqTI3mypzs6kyN5sqc7Op8kZ96mZuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeFmUxVuNlXhZlMVbjZV2ahP3cLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mqtxsqsrNpqrcbKrKzaaqG/WpW7nZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUjZtN1bjZVI2bTdW42VRtoz51GzebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqc7OpOjebqnOzqTo3m6pv1Kdu52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42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j0jYmNNKmzGnlTZjTittYi1hY04rYfPFRyRszGklbMb4iIStOS1szviIhK05LWzW+IiErTktbN74iIStOS1s5viIhK05LWye+YiErTktbKb5iIStOS1srvmIhK05LWy2+YiErTktbL75iIStOS1sxvmIhK05LWzO+YiErTktbNb5iIStOS1s3vmIhK05LWw++oiErTktcPb6gIStOS1w/vqAhK05LXAG+4CErTktcA77gIStOS1wFvuAhK05LXAe+4CErTktcCb7gIStOS1wLvuAhK05LXCO+4CErTkta4z4ZI0Rn6wx4pM1RnyyxohP1hjxyRojPlljxCdrjPhkjRGfrDHikzVGfLLGiE/WGPHJGiM+WWPEJ2uM+GSNEZ+sMeKTNUZ8ssaIT9YY8ckaIz5ZY8Qna4z4ZI0Rn6wx4pM1RnyyxohP1hjxyRojPlljxCdrjPhkjRGfrDHikzVGfLLGiE/WGPHJGiM+WWPEJ2uM+GSNEZ+sMeKTNUa8WGPEizVGvFhjxIs1RrxsYi1hY05LrDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaIz5bY8Rna4z4bI0Rn60x4vMm1hI25rSyNUZ8tsaIz9YY8dkaIz5bY8Rna4z4bI0Rn60x4rM1Rny2xojP1hjx2RojPltjxGdrjPhsjRGfrTHiszVGfLbGiM/WGPHZGiM+W2PEZ2uM+GyNEZ+tMeKzNUZ8tsaIz9YY8dkaIz6vBNTuNf79073+899+pbvQoXQi3ZVQy721R7q9HqS70HZ1Jt2FNqsz6YqtdBdq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NSm921GT0rsdLSmbdztqUnq3oyaldztqUnq3oyaluJRaUnq3oyaldztqUnq3oyaldztqUnq3oyVl925HTUrvdtSk9G5HTUrvdtSkFJdSS0rvdtSk9G5HTUrvdtSk9G5HTUrvdpSkDJt3O2pSerejJqV3O2pSerejJqW4lFpSerejJqV3O2pSerejJqV3O2pSerejJWXwbkdNSu921KT0bkdNSu921KQUl1JLSu921KT0bkdNSu921KT0bkdNSu92tKSM3u2oSendjpqU3u2oSendjpqU4lJqSendjpqU3u2oSendjpqU3u2oSendjpaUybsdNSm921GT0rsdNSm921GTUlxKLSm921GT0rsdNSm921GT0rsdNSm929GSUrzbUZPSux01Kb3bUZPSux01KcWl1JLSux01Kb3bUZPSux01Kb3bUZPSux0tKbN3O2pSmuh2Xuma6Ehe6ZroGl7piq10TbjvV7omHPIrXRMu9pWuCaf5SteEG3yma2Me/CtdW67Kxlz1V7q0ruqVgvCnQOt+XinQOppXCrQu5ZUCrfN4pUDrJp4p8M5QfqVAe+q/UqA9yV8p8J/OvDNyXynwn868M2FfKfCfzrwzUF8p8J/OvDM/Xynwn868My5fKfCfzrwzHV8p8J/O2DMMg4RXCrn8I4U//Est9qTBEQlDn/wjEob2CQMSxp6tNyJhaA8yImFoxzIiYWh/MyJhsZYwtHcakbA1p4U95WxEwtacFvbEMP2EI/ZcrxEJG3NaEXtG1oiEjTmtuIm1hI05rYg9u2lEwsacVsSegzQiYWtOC3um0IiErTkt7Pk8IxK25rSwZ92MSNia08KeGzMiYWtOC3sGy4iErTkt7HkmIxK25rSwZ4OMSNia08KeszEiYWtOC3tmxYiErTkt7PkPIxK25rSwZymMSNia08KeSzAiYWtOC5vxPyJha04Lm5c/ImFrTgubPT8iYWtOC5vjPiJha04Lm4k+ImFrTgubLz4iYWtOC5vVPSJha04Lm3s9ImFrTgubIT0iYWtOC5v1PCJha04Lm/c8ImFrTgub+TwiYWtOC5v7PCJha04Lm/08ImFrTgub/zwiYWtOC5sXPSJha04Lm0U9ImFrTgubcz0iYWtOC5uhPSJha04Lm889ImFrTgub/T0iYWtOC5srPiJha04Lm1k+ImFrTgubhz4iYWtOC5u1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8+Hkpc4+2+4j0/bZMR+a1spL9dmnHprWykv12R0emtbKS/XZkx2a1spL9dkJHZrWykv12X8cmtbKS/XZ9Rua1spL9dlrG5rWykv12eEamtbKS/XZVxqa1spL9dnNGZrWykv12UMZmtbKS/XZuRia1spL9dkvGJrWykv12aUXmtbKS/XZGxea1spL9dmRFprWykv12QcWmtbKS/XZfRWa1spL9dnzFJrWykv12WkUmtbKS/XZ3xOa1spL9dlVE5rWykv12csSmtbKS/XZQRKa1spL9dm3EZrWykv12S0RmtbKS/XZoxCa1spL9dkZEJrWykv1eR8/NK2Vl+rzhn1oWisv1eed+dC0Vl6qz1vwoWmtvFSf99pD01p5qT5vqoemtfJSVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnl9W755fVu+eX1bvnl9W755fj2E1rZOXuqzePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb/6vI29PB6Pr0Nfbz77J+dYxvmacNm349s5/nLC8/r85PXNJ+9j/fWz+9hmCrXxCG0VauNruirU5930tgq18Y9tFWrjedsq1Mant1VooFBxhdp0y20VatOHt1WITqG6QnQKmQqdryPv1z5TiE6huEJ99oe0VYhOobpCdAqZCj2/FDpmCtEpVFdooFBxhegUqitEp1BdITqF6grRKWQqtL9+12c/Zr/r02cnVVeF+uzRaqsQnUJ1hegUqitEp1BdoYFCxRWiU6iuEJ1CdYXoFKorRKdQXSE6heIK9dkn2VYhOoXqCtEpVFeITqG6QgOFiitEp1BdITqF6grRKVRXiE6hukJ0CsUV6rNXua1CdArVFaJTqK4QnUJ1hQYKFVeITqG6QnQK1RWiU6iuEJ1CdYXoFIordNIpVFeITqG6QnQK1RWiU6iu0ECh4grRKVRXiE6hukKueUj8kuLlmlrUHF2zhZqjawJQc3T16WqOA44Sjq6eV83R1ZmqObp+J6Xm6PrNkZojeUbA8Y//Nhzfcnz7svHHf5s8o+FIntFwJM9oOA44vuX49rXQj/82eUbD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vzs4Ku8QSyYzIDMh4+mBI2Q8PXCEjKcHjpDx9MARMp4eOECm8gasZDKeHjhCBg88I4MHnpEZkJmQwQPPyOCBZ2TwwDMyeOAZGTzwhEzlnV/JZPDAMzJ44BkZPPCMzIDMhAweeEYGDzwjgweekcEDz8jggSdkKu/8SiaDB56RwQPPyOCBZ2QGZCZk8MAzMnjgGRk88IwMHnhGBg88IVN551cymb/bz2j/cu3427csqc+/3/z8x83P/7z5+c+bn/+69/n/9k066vMvNz//evPz3/z+/ds3vGj/IvXYK9+/kfNXvn8j5698/0bOX/n+DfzV2175/g2c/6h8/0bOX/n+jZy/8v0bOX/l+zdy/sr3b6B/OCrfv5HzV75/I+evfP9Gzl/5/o2cv/L9Gzj/s/L9Gzl/5fs3cv7K92/k/JXv38j5b37/Pm9+/z5vfv8+b37/Pm9+/z5vfv+eN79/z5vfv+fN79/z5vfv3/4Su/r8N79/z5vfv+fN79/z5vfvefP797r5/Xvd/P69bn7/Xje/f//2V6DV57/5/Xvd/P69bn7/Xje/f69737/Px73v3+fj3vfv83Hv+/epeKd0eR1pXY6hPP/73796Kl4TTT3/8+bnP29+/uve51e8cpl6/uXm519vfv7t5ucfNz//ze/fpfL9+/73V59L5fs3cv7K92/k/JXv38D518r37/vfn3yule/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/RvoH9bK92/k/JXv38j5K9+/gfNvle/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/Rs5/83v3+3m9+928/t3u/n9O25+/46b37/j5vfvuPn9q3h/KfX8N79/x83v33Hz+3fc/P4dN79/95vfv/vN79/95vfvfvP7V/H+Uur5b37/7je/f/eb37/7ze/f/eb373Hz+/e4+f173Pz+PW5+/yreX0o9/3/83//H2F/nf1wP5fkDv38leP8n9/zXvc8veP8n9/zLzc+/3vz8283PP25+/v3m5z9ufv6b37/Pyvdv4PdXn5Xv38D5z8r3b+T8le/fyPkr37+B3588K9+/kfNXvn8j5698/0bOX/n+jZy/8v0bOX/l+zfQP5yV79/A+a/K92/k/JXv38j5K9+/kfNXvn8j5698/0bOX/n+jZy/8v0bOX/l+zdy/pvfv9e979/zce/793zc+/49H/e+f8/Hve/f83Hv+/d83Pv+PR/3vn/Px73v3/Nx7/v3fNz8/l1ufv8uN79/l5vfv8vN71/B+0u557/5/bvc/P5dbn7/Lje/f5eb37/rze/f9eb373rz+3e9+f0reH8p9/w3v3/Xe96/H//X//6n//HP//Sf/ut/+Z8f/x9//I//61/+87/+83/7l1//57/+n//+//6Xj5/9vw=="},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":3,"start":0}],"token":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"zZ3tipXZEYXvpX9LeHd97KrtrYQQnBknCKLD6ASCeO9pk9OaYCfNWp2VqV/S9lt1CtcH8niO/enup9c//PaXP7959/P7D3cv//jp7u37H199fPP+3f1Xn+6uP6z1j9/98Murd19+48PHV79+vHt5vbh7/e6n+18/v7j7+c3b13cvoz6/+O6xk3578FR+ffT0I4+m5bo9m7a/7d3++U8vvtxhQ+7wIXfEkDtyyB17yB015I4ecseZcYddQ+4Y0qc2pE9tSJ/akD61IX1qQ/rUhvSpDelTG9KnPqRPfUif+pA+9SF96kP61If0qQ/pUx/Spz6kT31In8aQPo0hfRpD+jSG9GkM6dMY0qfxnD5dlz88ua60Z15SYy7pMZecKZfkNeaSNeYSG3OJj7kkxlySYy4Z07E5pmNzTMfmmI7dYzp2j+nYPaZj95iO3WM6do/p2D2mY/eYjt1jOnaP6dga07E1pmNrTMfWmI6tMR1bYzq2xnRsjenYGtOxNaZje0zH9piO7TEd22M6tsd0bI/p2B7Tsf2sf+Hq8+0Q/++HrK4HnL2One8P6SmHnCGHnGvKIWvKITblEJ9ySEw5JKccsqccMqVZz5RmPVOadV1TqnVdU7p1XVPK9f7vN2MumVKv9xvGXDKlYNc1pWHXNaVi1zWmY9eYjl1jOnaN6dg1pmPXmI5dYzp2jenYNaZj15iOXWM61sZ0rI3pWBvTsTamY21Mx9qYjrUxHWtjOtbGdKyN6Vgf07E+pmN9TMf6mI71MR3rYzrWx3Ssj+lY13TsbfkRLo9LuXwpl5tyuSuXh3J5Kpdv5fJSLlcmNJQJTWVCU5nQVCY0lQlNZUJTmdBUJjSVCU1lQlOZ0K1M6FYmdCsTupUJ3cqEbmVCtzKhW5nQrUzoVia0lAktZUJLmdBSJrSUCS1lQkuZ0FImtJQJLWVCW5nQVia0lQltZUJbmdBWJrSVCW1lQluZ0FYm9CgTepQJPcqEHmVCjzKhR5nQo0zoUSb0KBN6hAm161IuX8rlplzuyuWhXJ7K5Vu5vJTLW7lcmdClTOhSJnQpE7qUCV3KhC5lQpcyoUuZ0KVM6FIm1JQJNWVCTZlQUybUlAk1ZUJNmVBTJtSUCTVlQl2ZUFcm1JUJdWVCXZlQVybUlQl1ZUKV7yky5XuKTPmeInvWe4rynnnensx7LPT14W8/A8Ok2126PaTbU7p9S7eXdHtLtx/l9me9uejp7dKspjSrKc1qSrOa0qymNKspzWpKs5rSrG5pVrc0q1ua1S3N6pZmdUuzuqVZ3dKsbmlWtzSrJc1qSbNa0qyWNKslzWpJs/qstx09/VPkSrq9pduPcvuz3nr09PYl3W7S7S7dHtLtKd0uzWpLs9rSrLY0q0ea1SPN6pFm9UizeqRZPdKsHmlWjzSrR5rVo8yqX5d0+5JuN+l2l24P6faUbt/S7SXd3tLt0qwuaVaXNKtLmtUlzeqSZnVJs7qkWQXen3QbaHTggAPAe4NuAwsdMHTA0YFABxId2OgAqrShShuqtKNKO6q0o0o7qrSjSjuqtKNKO6q0o0o7qnSgSgeqdKBKB6p0oEoHqnSgSgeqdKBKB6p0okonqnSiSieqdKJKJ6p0okonqnSiSieq9EaV3qjSG1V6o0pvVOmNKr1RpTeq9EaV3qjShSpdqNKFKl2o0oUqXajShSpdqNKFKl2o0o0q3ajSjSrdqNKNKt2o0o0q3ajSjSrdqNIHVfqgSh9U6YMqfVClD6r0QZU+qNIHVfqASsd1oQMLHTB0wNGBQAcSHdjoQKEDjQ6gSi9U6YUqvVClF6r0QpVeqNILVRplZIEyskAZWaCMLFBGFigjC5SRBcrIAmVkgTKyQBlZoIwsUEYWKCMLlJEFysgCZWSBMrJAGVmgjCxQRhYoIwuUkQXKyAJlZIEyskAZWaCMLFBGFigjC5SRBcrIAmVkgTKyQBlZoIwsUEYWKCMLlJEFysgCZWSBMrJAGVmgjCxQRhYoIwuUkQXKyAJlZIEyskAZWaCMLFBGFigjC5SRBcrIAmVkgTKyQBlZoIwsUEYWKCMLlJEFysgCZWSBMrJAGVmgjCxQRhYoIwuUkQXKyAJlZIEyskAZWaCMLFBGFigjC5SRBcrIAmVkgTKyQBlZoowsUUaWKCNLlJElysgSZWSJMrJEGVmijCxRRpYoI0uUkSXKyBJlZIkyskQZWaKMLFFGligjS5SRJcrIEmVkiTKyRBlZoowsUUaWKCNLlJElysgSZWSJMrJEGVmijCxRRpYoI0uUkSXKyBJlZIkyskQZWaKMLFFGligjS5SRJcrIEmVkiTKyRBlZoowsUUaWKCNLlJElysgSZWSJMrJEGVmijCxRRpYoI0uUkSXKyBJlZIkyskQZWaKMLFFGligjS5SRJcrIEmVkiTKyRBlZoowsUUaWKCNLlJElysgSZWSJMrJEGVmijCxRRpYoI0uUkSXKyBJlZIkyskQZWaKMLFFGligjS5SRJcrIEmVkiTKyRBlZoowsUUaWKCNLlJFtlJFtlJFtlJFtlJFtlJFtlJFtlJHtxxnZrpW3mV2e/zr2/af81vKvPzh57fj68P0XjzztZbeHY337nz/bH+45s+55HNj9jvesYffYsHt82D0x7J4cds8eds+wPnwcVP+O9wzrZxvWzzasn21YP9uwfrZh/WzD+tmG9bMN62cb1s82rJ99WD/7sH72Yf3sw/rZh/WzD+tnH9bPPqyffVg/+7B+jmH9HMP6OYb1cwzr5xjWzzGsn2NYP8ewfg5tP99e5PwfXiT/F01a8fVFzn7iT/b+kX542q76+rSZPZy05p1k807yeSfFvJNy3kl73klP12v820m3sebGDjW2L25scWPGjTk3FtxYcmObG+NcsjmXbM4lxbmkOJcU55LiXFKcS4pzSXEuKc4lxbmkOJc055LmXNKcS5pzSXMuac4lzbmkOZc055LmXHI4lxzOJYdzyeFccjiXHM4lh3PJ4VxyOJccyiV1XdzY4saMG3NuLLix5MY2N1bcWHNjnEsW55LFuWRxLlmcSxbnksW5ZHEuWZxLFueSxbnEOJcY5xLjXGKcS4xziXEuMc4lxrnEOJcY5xLnXOKcS5xziXMucc4lzrnEOZc45xLnXOKcS4JzSXAuCc4lwbkkOJcE55LgXBKcS4JzSXAuSc4lybkkOZck55LkXJKcS5JzCcdei2OvxbHX4thrcey1OPZaHHstjr0Wx16LY6/Fsdfi2Gtx7LU49locey2OvRbHXotjr8Wx1+LYa3HstTj2Whx7LY69Fsdei2OvxbHX4thrcey1OPZaHHstjr0Wx16LY6/Fsdfi2Gtx7LU49locey2OvRbHXotjr8Wx1+bYa3PstTn22hx7bY69Nsdem2OvzbHX5thrc+y1OfbaHHttjr02x16bY6/Nsdfm2Gtz7LU59toce22OvTbHXptjr82x1+bYa3PstTn22hx7bY69Nsdem2OvzbHX5thrc+y1OfbaHHttjr02x16bY6/Nsdfm2Gtz7LU59toce22OvTbHXptjr82x1+bYa3PstTn22hx7bY69Nsdem2OvzbHX5thrc+y1OfbaHHttjr02x16bY6/Nsdfm2Gtz7LU59toce22OvTbHXptjr82x1+bYa3PstTn22hx7bY69Nsdem2OvzbHX5thrc+y1OfbaHHttjr02x16bY6/Nsdfm2Gtz7LU59toce22OvTbHXptjr/0fIOqyh0/W7BXfPl63b58TPI/zybKu21i5X4+MPX6k1Xl4NTuPvdqjLrH98GJ+fRt6+CjjeRyOPTW0mCFjhpwZCmzo/ou/vvr1zasf3r7+cD/w5Xu/vfvx45v3725ffvzbL//8zv2zfwc="},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":4,"start":3}],"inputs":[{"end":3,"start":0}],"secret_hash":[{"end":5,"start":4}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"param_witnesses":{"contract_address":[{"end":1,"start":0}],"nonce":[{"end":2,"start":1}],"note_type_id":[{"end":4,"start":3}],"serialized_note":[],"storage_slot":[{"end":3,"start":2}]},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[4,5,6,7]},"bytecode":"H4sIAAAAAAAA/+2b227iMBCGE8ohNMshIYTzobQ3exdYCvSOl9l9671fad9htZ3UUwZrWjnqxIolLKFMjOP/m9+HppXre2+l9frxVdzQrrRgm7O6Zl8rW8G+sjI5fUc4a45w3gly+gwnXOsqhivM5aZ3Pc/fy1lwklBRCgUDc0fqPoK7eghKUwWBBnyWgD5lpybpnEJDCRU4BQhJIj6pw2drpA53kLvg0kVTPod9QMwT6/d1QMNL2u/cIYnxO9Cekrp6STk25HMsy7t8VaI/DdVvi9yjV20VC+6wW6rtq0+baHpqjDCekLbYDv2okTGG0vEu49/+5Lm69lyXtGky+Z892fxbGk9LY24oJigR8Gp7QEljk0G/9/L9Xo15XRuTe5JTR9zv3Qn2hNC7LvpPmTOJO4TnmzhPti0nz7ex6xJ2mX6f9+BVT/Mq1LzqkjaUoVeCfz7Rxb7xvsdoy3lxOIF238CLPsPTt+xFn9EW9OIFtCMDLyKGJ7LsRcRoy3lx/AHasYEXMcMTW/YiZrTlvNjl7xYDAy8GDM/AshcDRltwjeTzIjHwImF4EsteJIy2oBe/QHto4MWQ4Rla9mLIaAt68RO0UwMvUoYntexFymgL7p35+8XIwIsRwzOy7MWI0Rb0YgfaYwMvxgzP2LIXY0ZbcI3k2hMDLyYMz8SyF/R31CLMAweZUweZ4wowB1oso33I98+pgRdThmdq2QvUK8qcVIA50GIZ7cMzaM8MvJgxPDPLXqBeUebIQebYQeahg8yJg8ypg8xVmM+BFstoH/M9dG7gxZzhmVv2AvWKMkcOMk8dZI4rwBxosYz2Mf/b3MLAiwXDs7DsBeoVZR45yNyvAHOgxTLaxwNoLw28WDI8S8teoF5R5rGDzKmDzFMHmWMHmYcOMicOMt/WoB3mqALM9EzT31J5di+hxoOeeRqjpzGGJKbnYFbijFlGx2dFtNbyWltuvuD9ulTt3Qn63cjnlL/LP6q+8AzfhsnpScXS57keSb8+0cH6Oon/kLbYDv3AdYvsMO8eVPz0yXNL7bkuafPA5H/2ZPPfaDwbjRnG5DfhWItz7E4m87rvXdbyd8JTwj64p2dysZjsOyXtMduS8szoGb5/nuyaXmteBZpXXdKG7tHrEvwzmV835hvzR8z0fSIgdfj9itTVtFzo/zJgezgz/B/4fzqFFjUAAA==","debug_symbols":"ndpRattAGIXRveg5FN9foxkpWymluIlTDMEJiVMoIXuv3dIF5LxpJN237+kw79P94cfbz+/H08PT63T79X16fLrbn49Pp8vpfdp9qf737evz/nR98Xrev5yn27lyMx1O99en/nEzPRwfD9NtGx/fbq6bAZsVNtvnN/MONoFNwWaGTYPNAhvoYIYOZuhghg4adNCggwYdNOigQQcNOmjQQYMOGnTQoIMFOliggwU6WKCDBTpYoIMFOliggwU6WKCDDh106KBDBx066NBBhw46dNChgw4ddOhgQAcDOhjQwYAOBnQwoIMBHQzoYEAHAzpYoYMVOlihgxU6WKGDFTpYoYMVOlihgxU62KCDDTrYoIMNOtiggw062KCDDTrYoIMNOshuJ6PIqGQ0y6jJaJFRl9GQ0SojKSJSRKSISBGRIiJFRIqIFBEpIlJEpIiSIkqKKCmipIiSIkqKEGqMWGMEGyPaGOHGiDdGwDEijhFyjJhjBB0j6hhhx4g7RuAxIo8ReozYYwQfI/oY4ceIP0YAMiKQEYKMGGQEISMKGWHIiENGIDIikRGKjFhkBCMjGhnhyIhHRkAyIpIRkoyYZAQlIyoZYcmIS0ZgMiKTEZqM2GQEJyM6GeHJiE9GgDIilBGijBhlBCkjShlhyohTRqAyIpURqoxYZQQrI1oZ4cqIV0bAMiKWEbKMmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZdH1SLofSRckxSxLzLLELEvMssQs67NmeTn82r8c9z8eD9eLsNdvb6e7//diL8fz7+d/Xy7//gE="},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":3,"start":0}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"},"return_witnesses":[3]},"bytecode":"H4sIAAAAAAAC/7WXy67TMBBA7TiPpqXvZ9rmttBGLFjDim/gH5BggYRgw4pPZMceiU+5eMYeT5zcwgipkdLYzjke25k8elWpwm2Ax1r5zdgWNVG5PSSwv1VUsgXY9URpamrgJFiupMFvvKDSF/Zn1CjnDcxrOGGgh4b6UlcaBfSpMhWqGfwgZ4RcKuS0gKPF0HYK+khTUDmWcsAacvO4q0JjFZgCDe1rWsilQs4IueTWYhc86eJvi/gklwk5I+S0gLtxUQZYgiwswkUZxF2VbnGAKdHQvqaFnBFymZBLhdzNi1fy4pRhEQshlwq5TMgZIacFXLjIDd2NZUMpMGyIw8eNGkJsSIZzSIYyIMOQDGUccuQWG5gRGn4c3WS4yRkhlwm5VMgVQi65Ko1PtQy5oV/Hlj61+zgs9Yivwbh/hZ5xFQnb+Tt7nDhp5KUpXuAJlGJ96rgxRbX6V24mfYY6ALNYn7E+8/o3biZ9jjoA81ifsz73+pmbSV+gDsAi1hesL7z+iZtJX6IOwDLWl6wvvf6Fm0lfoQ7AKtZXrK/csa8t/k+b3S2aneN7biZ9jToA61hfs772+mduJn2DOgCbWN+wvukPehMG/Q/NRv3OzaRvUQdgG+tb1rde/8jNpO9QB2AX6zvWd17/wM2kV6gDUMV6xXoFx+dw4nd8g8+wA8V3NZ2owkN2HPcM2x5D7vshD66DyhXbZ+GWPcS91DlWaw8/+KfRSWNXJ2iCHYf9y9Vo3uCcGsKOHNWdSFyjOsWjO6kQELT6bH9+dobYmcAbTQ+Vq3vLtTaIMsQPYHx0Du/y/XSX76LwUizCKzOB1+M1vB5dTpjw+K8CPMbrTzHGnZTTcco1tHxayBkhlwq55MlbYu+5fZyQhxg+uvw8+GSqIRE1vDdrzAq/pX4BAasxLuRX5fLCB4ky59FuQDkC4NoSj50NgjoCYh+5j1Zo9eAIvE2S0B1U605Vheox9ooCi3s/C7zbNAz7gSfZyQBMl8tUhc8rzNOQMMnlVWiE9WloldpI/27Cv4RuXKafCHnTWm86kfdzPnuZ+tg6ip2Hr8Qi/DVLwmzMBYq7H7D/AbZaOCrvDgAA","debug_symbols":"5Z3tahtHFIbvRb9N2TNnzpkZ30opRUmcIjByiJVCMb73rlt9tHiJiZ03eWB/mZXOnH1H+HkG7Y6kh82Hm3df/vh9t/94d7+5/vVhc3v3fnvY3e3no4fN9IvZP4/ef9runx64P2w/HzbX09XmZv9h/vt4tfm4u73ZXNf2ePWsbIQfC0eLc+noC6VRwo61UfLSN/3xt6unHAWSwyE5KiRHQHIkJEeD5OiQHIORo0yQHBCfFohPC8SnBeLTAvFpgfi0QHxaID4tEJ86xKcO8alDfOoQnzrEpw7xqUN86hCfOsSnDvFpfYtPbfJTpU1R3pjEMEkKJoljklRMksAkSUyShknSMUkGJUlgHBsYxwbGsYFxbGAcGxjHBsaxgXFsYBwbGMcmxrGJcWxiHJsYxybGsYlxbGIcmxjHJsaxiXFswzi2YRzbMI5tGMc2jGPbm67C9nEJ4l8PYr2dLsnZKON5kKQEaZQgnRJkQIL0iRLEKEEKJYhTglRKEIpZO8WsnWLWTjFrp5h1UMw6KGYdFLMOilkHxayDYtZBMeugmHVQzDooZrWJolabKG61iSLX+b00JglFr3MHTBKKYG2iGNYmimJtwjjWMI41jGMN41jDONYwjjWMYw3jWMM41jCONYxji8axx+ambF6UzV3ZvCqbh7J5Kps3ZfOubD6EzV1JqCsJdSWhriTUlYS6klBXEupKQl1JqCsJrUpCq5LQqiS0KgmtSkKrktCqJLQqCa1KQquS0FASGkpCQ0loKAkNJaGhJDSUhIaS0FASGkpCU0loKglNJaGpJDSVhKaS0FQSmkpCU0loKgltSkKbktCmJLQpCW1KQpuS0KYktCkJbUpCm5LQriS0KwntSkK7ktCuJLQrCe1KQruS0K4ktCsJHUpCh5LQoSR0KAkdSkKHktChJHQoCR1KQoeQ0DJNyuambF6UzV3ZvCqbh7J5Kps3ZfOubK4k1JSEmpJQUxJqSkJNSagpCTUloaYk1JSEmpJQ5Z6iotxTVJR7isrynqL5lt3po9zzbar29VPMi3wei+eF7VJsxRaqvZVjcbVLnn7+RuqA5UlYngbL02F5BivP8kapn5jHYHkKLA/Mh8ubvn5iHpifHeZnh/nZYX52mJ8rzM8V5ucK83OF+bnC/Fxhfq4wP1eYnyvMzxXm54D5OWB+DpifA+bngPk5YH4OmJ8D5ufQ+vl4kvEDTpLfw6TZzifp44VXtvVTojYuP4wyX3E8BTJaoEIL5LRAlRYoaIGSFqj96EDp50D5v0ALdyf8dHdi5HihtkU/963/qT3Ns69jnm1ayTzLSuZZVzLPWMk8cyXzXMm60tayrox1zLOvZP1c/gxAWjmNSquXYZdfOF78d2+ln2bc3Kfnw5Z3Ypfz6+RTff7eenkT9EuD4jWD8jWD2msG9W8bNB/8uf282767vbmfBzw992X//rC72x8PD399+veZufZv"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"param_witnesses":{"amount":[{"end":5,"start":4}],"inputs":[{"end":3,"start":0}],"message_leaf_index":[{"end":7,"start":6}],"secret":[{"end":6,"start":5}],"to":[{"end":4,"start":3}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAC/+1daWxky1Wu2+12t7de3G677RnPeLvj8T7e7fbWz+N5817yCAixBCEkdoTYQggSi0BEYosQiE2QHywBgRC7xA/2JQiEEAogITYBEYQfCCUEgiJACoHQZ6lzuupWu+s5JFGkttQzdet+X9WpU+fWrfXcFTNk8K9UhH/nDf91rkqmbIY7/+Xgd25sqBOAX1I2iY1K4SawKNSJN/mUCWYIQ/nOPwUMQX7DGCpAPhgahn+WOv+UD0WUFSsZ5GPGUivZqJEbY/BPaiUadRm5ECMnjHyWMSqMvDJGhTGExYLQcFa+IWUMCaMYiRuJxJUicYVIXBKBsypJOtVTPUqtErF+UYlYv8jNe+pMSGWsxHya8FUSiStE4kqRuJFIXDESN9zLGEZ7mU8MrhiJG4nElSJxhUhcEoHrYTT0EI/Jo4YPtpvUOCkbMOPISPgqicQVInGlSNxIJK4YiRuKxPU0rnFV9vhtxhXEFSNxo5G4kUhcKRJXiMQlETgxwtS2ZuOpNdGJ1OLoNTEBjzQYa0uMdVwgE2Ks426WZao8wJSRwXL4xtoTV4jElSJxI5G40UhcMRI3FIkbXjEJvmUKiJvgeukSp9L5VaXqylqn1WyNV/QSEZ3EX9f5v0akMpMm0WBqEHLpk4SrUhDpX6HRll5HOgDqLr2u9DrT36TRlj6FdABMufQppU8xfUGjLb2BdAA0XHpD6Q2mf7FGW/o00gEw7dKnlT7N9C/XaEufQToAZlz6jNJn6P8srXE3Wv0jllunjJ+j0ZbeRDoAmi69qfQm079Uoy19FukAmHXps0qfzQo9K0L3oXVy/TqNtvQ5pANgzqXPKX2O6V+g0ZZ+D+kAuOfS7yn9HtM/X6Mt/T7SAXDfpd9X+n34fxHiJ90HnBIwemVv3JdGu+qmDH/zmOV8NssHlMB9CnbfhZbkgZvKwjBeLjB4kVujpQSTgvEHSLyIYlfoypYbOEuphT3UXOlGjiLNkivdkpEMgbbQCSRDnoheAY4S1kB1xRm16OBkwuttKe7G0e2op1tXtHlXNR3FJV0VMmpFwpJVXVWG9D6gDWgD2oA2oA1oA9qANqANaAPagDagDWj/bzSZmp6QSdv7EQxv2mAhe/nQTWVBxtAPdAwNw3tzbiepH/Ac9II7jF6mGYZlxq/wDENKMwyQ7Ar8YIYh95SuhlhW4KSphS3i8irORyz5mBxFmtSVOjWSN6Sw3ClY7tidRFjM4+VDm7IrfErCp5z8IxZ+lYRfhSj4ofCfQVdWMOCspha2mFqFLbsiriYiIuCWE1dit6Ca3oqfUY4VueozclyyVS9fIyWD9FJQzYsuZFmnapbdel1wywGXi940j9jLitrLotjLMN0I2csqqXyV8Y9Z5Wuk8jWIgh+q/MvpakjLbtZSC0vLYmGPfEyOa27NlXrNSN6Qwioo5XNde0nJXhZtyq7wayT8Gie/zsJvkPAbEAU/FP6b6coKBpyN1MLS1ITrbSMRETfUfERit6Ca3mM/oxwrcsNn5LhkG16+RkoG6a2Bar4yaFJLnJT3KK1iieDGCHDf4prPPVIcLJ7BLOo8lLzyJxAC8Hemdm1kTJq5keAq/Yjh/5EBV6OuGB1acmmc9Zmbzq+s+cPcZgVr6K0QwtlHtuRuRsVb4ClIA46TwpjAD0MICvCjssybh8tfCG2rqLh5wN8kSTXJd+tsTlOJXS/BtYE65vXzRlZaxpgzlVoYLwDl5YZdAAovwUwybRKE/XGU2NtJoumBymqy4lrzlsE7En+bcZa0QXe1YVEWrkJhAX4FQr207S1U1UjbthSkgd+EEAj727ITowKXfyzarqi2J7PabpBUDb47zdqeSezaCa77TGNe7zCyNJRnzkxqYazFitywK1bh5ZgG0xog7O+ixC6uqumNSu2NubWHW346Ev+acXadgO6mhkVZuGyGBfhLCPXStreyNlVwFuZIA38LIRD2nam1XjSXfxFtT6q2G1ltN0mqppFFH9T2XGJXbXAxZxbzeo+R9Z4Kc+ZSC5tRm6UbdvUqvBDUZFoThP0HlDi4ijnJKpuRvVFdtQeXsBT0225DALqbGXbW2JpYgP+AUC9te6tsM6TtOidAGvgAhEDYD6bWesFc8roJrKHabma1ze3rPb57n7U9T9rG7iD8IK88d0KtErA9Ti1sTm2Wbth1s3lvMcVIhkC7B7J/CCUOLrs2TPcyXkVCEK9d23pwubrOgtZlbbbuvlwmQwtFXgOQuDRsc1p5zreRbYGmNe/prGQNyXE68xAUjPuHeNxXiIhGrwXqWUmzqWnOhtPEW5QmPkWyOOrZ2j1Jc07ThDozupyKEGjlx6H6tty1Orb28W5jrfwYG2t+Vx9SlzblVRClMsXVUkMzPIaQPjMk34R9oWHKNVd19ZRrxjRyGFm3FkQ9zhlbnaJiakW0PQFuk7hzfGPaSPrTpEBf2blQBc5mzavLFKZFxcORuGYkrhiJK0XiCpG4JAInFp/ax2E6tXdzsNXoUrYaTcgrfEaefgLPiE0m2TfqBHWHbUXrKzmJxBUicaVIXDES14zEDUfivD0U3O7NMW7OfTl4jRf3zuqmq3eW/0bj9M4ovWnb+qbcHJsJeg44E+dJ+VDnD1CEmKQmtfAh7w8yJQTkXdM0urI2VULgnoCcJIfblrxLI5c1lzddlKcct/tgIb8LQqHXNPbCQm16YA+Wp9yqqqpqbFe5aDJd5ZruFKlR7yJvZCOU89Y768ZNG7ufayIrSsUbXfRqmYK44UhcLRLXjMQVI3GlSFwhEpdE4KQFg9bqNdJalTGEA0dpmcrBXa24+Q8ZCV8lkbhCJK4UiStG4pqRuFokbjgSNxuJm+hl/MFdsrORuNhdxrVIXDMSF7sbuRKJ+5juMu611X2811b3Ud36PWpu2ereE1eIxJUicZVIXDES14zE1SJxw5G42UgcPUzj2UoOnnuYiMTNRuJiz43UInHNSFzs+ZJKJO5jfr7kdfLQjcjoTc+X+DOnSY+Z0yQSV4jElSJxlUhcMRLXjMTVInHDkbjZSNxEJG7cne3TsfuQN3ZX3NsNTNEYvWlvzGdNyt9fzNtfH7gTOQ/RImF5yVsh5A3A8xT0538GtAFtQBvQBrQBbUAb0Aa0AW1AG9AGtAFtQBvQBrQBbUAb0Aa0AW1AG9AGtAFtQBvQBrQBbUAb0Aa0AW1AG9AGtAFtQBvQPo5o4hp2SLxuz0cw7ru4hezlgpvKouzzfGgcHLncmKAbIZcbK3Tga4XxKR8OfkSHg8GRBSSdLnb+KX6jEbcqD5nzKLWwpbK4jV32MTmK7PaYwTSbN6Sw0hGg+EZ3o+sSudxYsCm7wj8i4R9x8qss/GMSHlxcgM+JVRT++414qXjInMephZHLEshlxRXxcSIiAm4lcSV2C6rppX5G1rPGY59hvdc89vI1UjJI7xGo5s3Bc32LXL+LroFMuJdphIuWVOylYmJctKTmdhctxZ82t7hoWS5bRzMfjouW4g+79rJM9pJmDQ7+XoWLluLvmFtctCynVmEfCxctULL+LlqKPxc80LbE9bvkGkjFvfTMcVnsZVXt5bHYyzjdCNnLOql83ZaHVb5JKt9keTdQ5X+uBVllzmZqYY/K0iKt+ZgcF33TlXrTSN6Qwjoo5Q9de3lE9vI4a3Dwt0nCb3LyWyz8Ngm/DVHwQ+HfTVdWMOBspxb2KLUKW3dF3E5ERMCtJ67EbkE1vQ0/oxwrcttn2Edp28vXSMkgvU1QzV8Fz3Ytc/16Pp/G3UvPHB+JvayrvWyIvYzSjZC9bJHKt2x5WOU7pPIdlncbVf4hLcg6c3ZSC1srS4u06WNyXPQdV+odI3lDCluglPe79rJG9rKRNTj42yHhdzj5Jyz8Lgm/C1HwA+FLDbqyggGHXCbsYhNoFbbliribiIiA20pcid2CanrbfkY5VuSuz7CP0q6Xr5GSQXo7C/A5q+CxpEdcv49cAxl1Lz1zXBN72VJ72RZ7adKNkL08IZU/seVhle+RyvdY3l1U+boWZIs5e6mFbZalRdrxMTku+p4r9Z6RvCGFJ6CUB669bJK9bGcNDv72SPg9Tn6fhT8g4Q8gCn4ofJuurGDAOUgtbDO1CnviiniQiIiAe5K4ErsF1fR2/YxyrMgDn2EfpQMvXyMlg/T2QDVbwS9KrHH9rrkG0nQvPXPcFHt5ovayK/ZSoxshe9knle/b8rDKD0nlhyzvAar8U7UgT5hzmFrYTllapD0fk+OiH7pSHxrJG1LYB6W87NrLDtnLbtbg4O+QhD/k5I9Y+GMSHpymHMEPhf8SurKCAec4tbCd1Cps3xXxOBERAbefuBK7BdX0DvyMcqzIY59hH6VjL18jJYP0DkE1rw86Sdjk+vWa3hqWCG6A95nSG1zzeUCKg8OoMGrbAQ2Vv9c2ZG9K2Yscf/5oyGS+CTSmPjrpg13c4nUfqISMxkIH8/DDfBnnaN3n9MbQ3dAQG4F3MnpE8x4xt3zYb8Q4ptTD3VCO/GCgzzD5WKB3LHRC0uw64D0RThNvqecPPZLvfR2qEvqMkXpgAEbZrdKKOBcDx3ml73fdCI1RleZZvxNYpfB1lwkAv1V8BIy5tJzX7VX/aPitJXx0fsQ4rkBIXAurpvaTJHkqdV7sAWonT05IRvnGEJ1sHuME8uJQrCxfgSrrIU/iWj8HI0bS946AUgKBei9nLS3vKrWsvhJRO3Loeyxo8GUWPkgr3o1W6k8jBygF1yZQn2fdODwn2+v4eFHVUnTMLAY3Hokbi8SVInGFSFwSgZOn3vXFMCqffSumgeYIrTuRFqfqtHZJJK4QiStF4sYiceORuIlI3HAvHwFVzw1QLyMM4iYiceORuLFIXCkSV4jEJRE4MULxAEK+lIrSwFflJYZNvfvZwapA1LuO5xOpRpUnzpOkfU4icYVIXCkSNxaJG4/ETUTihiNxRe421gp2XggBRT70P1mwzQk5n11xJgjVu2G9p4tP9Bvq+VftJP6KcVwnqnvU3p/UE/eoHfquRlt6v6/VNQw7Ge3QtzTa0vt9ra5BQaS/SaMtvd9n5xoURPpXaLSl9/vsnHWz2QjRmnejTfendYTd02hL7/eRuwYFkb6g0ZYeXNbochXaoCDSv0yjLf2BOK4Pu8RvUBDpX6DRlt5vuaZBQaR/lUZb+oJ8z85bdVlQ+kJW49E0/hLjgktfRDoAFr21HqUvMv2LNNrSl8T5e/gjfA0K+kIviaruQLvfn8Yf5lxy6cuyDLIcdEPfoKCf67Jo+A60+3ejLfSn8acxl136ikzde0tMK0pfYfobNdrSU/HyH/7OQcO2zyHag7vRFvrT+JOYqUt/JOtd4RW/BgWR/rUabemrMmsd/nBBg4K+0KtSr31o/HnXVZdOa3EACK/FNSiI9K/WaEtfkzWb8KpVg4K+0GtiFh892lJ/WqeMX6jRlr4u08PeMsa60tezua5LrnegPbgbLe1Pg8Zx5N/cLg4uC4b8aq/bDhDx3d7Nhqy/rN++AuX2pbwprO1hf64Yu2lPaHYPptBg4gznrkb+xcg0dZ05T1IL61oGoBs5w1O2rnQ8d7rNtO2FTsLv8kT0CoCzIvqID4bdtwy75YvpNM4GWSoy9vFGPJ8sI56iNzzCPIKLzEW2uWJq++tJJK4QiStF4sYiceORuIlInP2A+riOZLzvw4PV65Bl49Yhy3p2yPIp+ghsMGlLljy89YwtbV62ut7jWy59Wx7G8Ipsgx9I21Paduk7snIXXrtscCthe8I7Lv2JzL+HmwJelJT3+hOXTsuDAAgvDzYoKKOAXZe+J8tI4YW0BgVlvLXn0vdlXcVbtNhX+r7R8da+S6e1KgCE16oaFLSNvkvb7U/r5Pp5Gm3ph7IUEl4MalDQz/VQhO1D477MoUs/QjoAjlz6kdKPjI54jlw6LdMAILxM06CgdIWOXfoJ0gFw4tJPlH5idLR34tJPkQ6AU5d+qvTTrMpOxbbvQNu9G+3wbrT9j2puESrpVMTXaLSlt5AOgJZLbym9lc21JW3UHWhHd6Pt3Y22czfa4UdVyN3+NJ5da7n0M6QD4Mylnyn9zOjs2plLP0c6AM5d+rnSz43Orp279AukA+DCpV8o/SJb5gtR1R1o+3ej3VHIVn8az6ZduPRLpAPg0qVfKv0ym+ulmMMdaCd3o+3cjXb0EaPxbNmlS79COgCuXPqV0q+MzpZdufQ20gHQdultpbezQrdFRX1oMGYb8xa8tjEBo/1RewMYOtRsu73SFzDLF7JZXlMCbQp234Vn89pN5YaGmjcMfsb96BdpqPkiRMEPxS7SlS03cF5MLeyp5ko3chRpvO9JvmgkQ6DdLHTW1z7oiegVQIaa26/qkxSxn8IYi8R9RD4hIYthuscBP4LzaTLk8xxhl2gIBEAaR9rxThKJK0TixiJxE5G44fAulLGy7IsY61W9JVVf6bbqDeIKkbgkApettpKM6L1vF7Xl20U06mwLuIEPr83D+8peO3Hbi9TafhKJK0TiJiJxw8H27AXGveC2Jtcu+Ck1LtfcEtxgK/LpEPL31JQYdoP53mQbtZLo/oVQ5V27suQxKaMwe+PGrWT4eyq4G8U9zRrDM5dGDdyNYwJeU/ec0nuRgt1NojCeu5v+XiLGcwqa58h45uISScBoHobzUW08d7XxkjBeVMZLWW28LLiXFPdyVhuvcWmvTVl8Fg1kea3LeIXSey0FmfEyhizjFVcbn0CMVyhoXkHGazBkuJSwxWvsW7xXGn06cYKrB99dZegrPQPwW1KuGrY1rB2R4CrY5bgy3KNIuSPBRuMxcrcxroOvwWtO5VqsiV7rz2+zqyu1q6sedtVPKmslV73s6ipkVzcuI+8wbkKM5/Ig3mTLcanluAyUAxiXbjm493xpuM8s5bj02iExEKzzX/LukoE8s00THpz6HwgB+Je1yqQxuhKBzoPjp3PDw6OUR0XmMsTI3cbwxg+szgtO5UKbOemhqoFcB7nXzL2WLvG1MG5cqc61V3aOVWaHJR7uUqr7Qqv70m0ehpzG97Jn45u41mQot4RrztYziiSFD48/ReyPC5rUxkVqslruybhyccZ5stBy3+vWwRW9fZ9aa16kt34nBOB/TxN5iqwYZ8G5hTPDUwdpYoKzAGchozijyg5tEj6jLt+ZsRMTZ1nzP5U0W5rmaThNxFOap8bOdXmTVfB3gmnC8PdqAZYKXHWdDksbCdwzUNc4HCw6A/CIqOuqjA0ftqWUKdVlQn0TbvJLxnbySq9CsZchRu7VVEWodSlJHUHoJDiRe2J4njbl6VnTCjFytzFOg3O8p/auVHUpWhY7t3IijGNXFp6utgcejqXqPZya6GnGRJ2acS2mUwuFJ5//uje+a/dta7/6Sc9++c1vfv1nQeJU78eUT+Hx/j+/9LW/9obvefqu//i+97GpEeKEyhj6euURIfCYRk6Sw0J4l0YuT1xeSRUMRTmShc7wVP8Z087uSJNWyARtTjSKuHYk7oVI3GUk7jwSdxGJSyJw0g6ltpEic2uhdg1rg2z4Cq3UcMkPU/v+PKAz1wYWt2xzvJfaPGiNGGohL20YORIAsyhgCKaihzEEa0y0eLwvTxvMPY7ACPX1MkI9lBHqsRx2OZGk9iT5fcnyQEatJ8HDQtkmIYnEXUTiziNxl5G4FyJx7UjcFc+fnRfk4J7Xt4NNGu1Q7yjwxHij644QyeuM9M0vmXQsD2Z4ja7NUrZ5JfjYpR/KGl14gbHNBtHmFcJDl95vgbHNhtvmpdwjl34ms73hlYk2PwHtEO24P42Xr89c+q68i8LL120KIn1Boy39iUy/hxfP2xRE+udptKXvyOJ5eOm+bWQqGWe4d1z6tsw1hzcOtA1PKfP2w22XviWLcuFtC20K+hr/sGi7/Wm8z2zLpW/KJonwif42Bf1cN0VFfWi8t2LTpW/Izo6wc4U2Bf1cN0RFd6Ad34121p/WKeOiRlv6eq+dautKh81ebewH/6/biE2Z7s1x7dDmuLbJ7KNZ67Vp8LHuLfM8I0Br+binqxd0sMIt7kpi99Cqn5rx/zayI/WSOSupha1qrnTD7voMb8tlNy/ogWX8fZ6IXgGOeKrUTC33GtacZYY13YORE33B4ICkKGMTfOfgUA6WY457faf8KJFOHnYiKYEjjjrEBGCH1KEmoE2qjHXOXKn41DG+KwyfjZ6AoyEH/nzuJcP0IHnXAI1OC0Pv6FS7uqeEswPDA3mxwc0LYRxnhn+Yc/eQUtPEhGTbTUsnwUAPB6rTA9HpkqtT6U7RgFH0ci19tMvgyP3S2FkgnufqnuhYMHZwZZRhuHx+X9O1/c7wJPkSI4OYc2OHR3bYE95m02K7Afr/aLSlH8uycLgD0WJ1An1eoy39SKop3ANoGdnMkXymRlv6ofQAwv2PlpFtFsl/arSlH0j/I7wrq2Vrv0P/CY229H0xj/BWshYFkf5ujbb0PdlsEN7I1jKy2SP5WY229F3Z4hDuh7SMbPpIPqDRlt6vH9KiINK/QaMtvV8/pGVkX0zyBo229H79kJaRvT/J2zTa0vt1KFoURPr3arSl9+sZtCiI9F/QaEvv94pvURDpNxpt6f3eni1+G7S4/7nu0ulNCIDw7vsWBZH+iRpt6Y/lRRo+oNDi9xDQ/1ijLX1VDiiEj0e0KIj0P9JoS38kL8rwmY4WBZH+dxpt6amc6QifKGlxuwv0v9BoS1+RTf3h13SLgkh/qNGWviynZ8Jnd1oURPofaLSlL8lpi/DxphYFkW402tIX5fxD+ChXi4JIf1mjLX1BjnKFD5K17NulQ5/RaEt/KGd5wqffWhRE+j2NtvQHcsgqfPauRUGk/7lGW/q8HOIIn/xrURDpWxpt6ffl5F/43GGLgkj/fY229HtyJCh86rFFQaS/VaMtfU5OPYZPeLYoiPT3a7Slz8oJz/D50hYFu6cfsR51Bh8R2EX5Mwj5/a1zhs2mnGp3xwT+b2pScGJ0BpP6awiFepDwv3cOt1mQ7hIkMI0JvBNCHUkn/l4W3MDpysS/SvdmVrs3M24e8DdFUk3x3Tr35SepLw89S+hd1zGv9xo5aXzNnMnUwnjT1KzcyFGkmXRLMWkkQ6BNgbD/iBIHZ+hnWWUNmYNsBJdi7RrLZVEucbkNBYdOy7XXzZ413cs/18Ejz9eslWuZBr+W6UJ/vQe1H1jWLOM2jK7MdQHbrm3qSmXsKsVFiPFqVimOVWuBKZxjXfnEgcEtK0FOX9fVxtGwjHguqG/pe9SCPiMOhMoPjDOthaMDGbgcu73YA+nthvubR0w76tRQue7KdKyrFRfZ7vWRbH/y+tFPdVkEVHYiA/8rsYybXpX4VKvkqbHzZjpFjWuHwaXgp7ZVkcHBU0/fMi0cWmMPbsIAjT/zjBF2CDzTXYSyr+IyuJ1WV/7twOo6xMjdxrgKmvkz1uRl8O413z0PLXWG1hxcbfDa4imndJJ114UrRaikTzYyQHtqugfMxyrOhdywBhAeuZ3aZwiM8bk3llTru3ZTxpG57J07DbZ4Z9yOnEnL+FzWVV7sVYldE9fYWsqKzWWv7TTXOma/FoM/y1bimSyV0I4gcfrUtc0NnvIcTYtY30tj1F7nOaqCFQAD7ErordhJ2VSpJtF9SedXQwacMaqF3EQBrJayzzJToUkK3Fwprp4qOdn/yP43rAOtmrFbItETkjDGwlMg3a63NE1MKLWu8EbE11TX7k5QU1VdhIAyKqoXiJrEUr4ZQr30Uh+WbZ/wyp5CxrdAKKQXgE2hLPgmJsknVRvWE8mkOs2adAoyHnyt5y1OxUclojDfDSFvagfukksxcfy2I2th94MdxfuGvV+k3PnsdinH3VN8uOcKtntKrj1QiB+CkAqhzAWB/KgLUTfRALuXJibjfePt0AvTpMC1B+4zL/8khEI19vZsT2aaGuwHnABV4M9wH6n8c6gVGOvfg8vfkGbwXs+DlPA3SVJxD83UWDXVxLoIwhqgh+jXjXj222GOeqqpq9t1upFjQ6sGvQ5NWsMFYX8RJQ52se6xyuoyOqgHhzbWXeD9olwCmLwH/h6Eej0XXR1TPJGpCeyIlv/QfUy0JuHhnSIzmmIzwr5w+R0QCjFSgfypC1Hv0VTexD6orlHU1G8tugrCpGAUXu1lRr4PJjKjGU6gjAn8DfwDtfB3KduMqcPle0IuhKpZMxohqUZsC8VmlCMzso15HvN6N13Z2gVOLrWwMT0oTzds6+p5sM2ptzp0igjC/j1KHGx36qwyaq2n3Oa1rU/JLAs1o1YwI2b0fteMtE6hMdwpiI/RObGb/+plN48F8oFQC7zKMG2Bd9w6LQ9LJZZt+4nnFsZ6WYF3WKBckMcQEhjBBAqsyQrtTahz21KZFiuY6ukpE/sD6qER7u6xFewndr4WJ1L3MC8+QGwrBydpUwvL6yCQblgLCk8B2xneHAg7ihIHGx07is3LvGiXx8XPNjJ/ah9+zwrwJVt54L5ktU7hpc0OuSa724LKUq+2YEMgaagtWM+0BZNunY6oFYzYx6sCieZ7WUHec1dakE4FPkmYwBOrSdpgMsVtQeWFUFuQz1pBl9teuHub295K28iwbMr4bnu7zOPV+uqtHKLEQc+VdVYZrQxMGmdl4Ju0zZjlu54VYItbedltcbVO0TFhQd6e0hZUPqFXW7AtkE8KtQVbmbag6tZpTq0gJ4/Xp0GolxV4KyG5gnSF8UnCBD7TavKz3LbgS0NtwV7WCl6F/+NKl//juvH9H3eZh+evuK9b4spno8Sek1W3LaDZgqpxZgveptYyy5qpqhVU5bF9U68nGybg6mQFdbYCnNCrwNHtmRBjVyBf70LUKzNaYMqdo+5+0Nv1qavyg0CPFwwIDnpZgTc7sl+QLjk+SZjAt1pNfru0BTNw+YNiBTNqBQdZKzjW9Wi4a4fVp4k92q7D6soPGBlWTxk7s2RhbB4zcsMuSYZPy9v16mMQ9jtQ4uDq3wyr7Ei6q0fip1C/A+S1mlM6lpmSt8mesVv/oN9Jjq1Tnn/unlNG33d6lGtcG5hxjqK24KfctsDts07qI4+jKWTA6mVmjDthu3oyxp2isdyUGBMOJmhUN8M3eIw7aynSa5pTRniMO1sW5mxOMsKEZGg4nbLfx+6+LfRCJhPplHh6mZSG97dMj64u6KWieoHeEPZtK78LoV56Kcs8RJUkB2uYUW3UKMoWpOoUpBm0i3GrRBVfeuqVd7jiyxh3vCN+fivljwV1lmIMh+aCyxFzrNQ5MbF77trArPaPEVeUSwA3URZYXGj6bdEIW3CTH9XpgvXSSb4/kfnOUCsGzIcC+YdQK/aAYdqKdakQZiF5uWHO9jswqX9yW1mX4Q0HpwoysJiSLtt7DA00K+9Ftc7bVuyDoVasnm3Fqtq2wt0Kq6ZMrViZrQ3npir/beQw8Txz1MZqbqtTFksqe71zIxmiaYKw70OJXVxD05sTy4SqqiluxcjoZoQ141nDPAheRYlDdQprqfMFuxCIVoD2Uy31sp9FgYy5EB3jAqwp7cC8W6eTagXSvFVrbvPmMmreqK8gDay0HNVp1mS1mRprfXC5KlbQVCuoZa2Ax1xlIxNcaAVjie1c4qM+jnk9MuKPX8ZoqYWxeTRNt6f1wIFu39M6CHsPJXZxdU0PVFaRddiK2MOEtCfzQQuaN93OX+tZXFMtCPs2akF1saAD14Kk3whDytxbcHiak73tednbnlvekEj3tdsFCZ8p6nLr772jh0MfdwgcXC+s2gFk4uRNfMiTxsLDIjxs6ssvT/cuzUzvW1v9C7ppuLzdpjcupRnV0gQc8I3tNTiDIZa5SBwhjIhH+ZKckC+K97thPSuvZZXyD+GnxZp/BL//AwnqFBd+0wAA","debug_symbols":"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0nA9SMP1IA3XgzRcD9JwPUjD9SAN14M0XA/ScD1Iw/UgDdeDNFwP0nA9SMP1IA3XgzRcD9JwPUjD9SAN14M0XA/ScD1Iw/UgDdeDNFwP0nA9SMP1IA3XgzRcD9JwPUjD9SAd14N0XA/ScT1Ix/Ug/aAx23E9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDdFwP0nE9SMf1IB3Xg3RcD9JxPUjH9SAd14N0XA/ScT1Ix/UgHdeDDFwPMnA9yMD1IAPXg4yDxuzA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJwPcjA9SAD14MMXA8ycD3IwPUgA9eDDFwPMnA9yMD1IAPXgwxcDzJxPcjE9SAT14NMXA8yDxqzE9eDTFwPMnE9yMT1IBPXg0xcDzJxPcjE9SAT14NMXA8ycT3IxPUgE9eDTFwPMnE9yMT1IBPXg0xcDzJxPcjE9SAT14NMXA8ycT3IxPUgE9eDTFwPMnE9yMT1IBPXg0xcDzJxPcjE9SAT14NMXA8ycT3IxPUgE9eDTFwPMnE9yMT1IBPXg0xc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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"param_witnesses":{"inputs":[{"end":3,"start":0}]},"parameters":[{"name":"inputs","type":{"fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"},"return_witnesses":[3]},"bytecode":"H4sIAAAAAAAC/9WZO4/jNhDHSUm21nb8fu9Zfkq7jtPkiqRKnTJfIcgLQZAgKZIUyUdLHyBIlz7AfYFrrrjiuuMMORyPZa8JAWfgBMiihv8fhxyOuBI3V4nC4w6vmXJHbCyqo+rmEsH5maKSKcCpO0qTqYBKoGxJA184QCVb89MqlOXu4k+gIoYWCmpL5dQLaFPVlL+twQ/q4kBdEqjTAToKhjZD0K9oCKqOpTrICmLrsqlU4y1oUiS0u9OBuiRQFwfqokvBTnnQ6VNBPKuLA3W1QJ0O0F2YlDssQRamflLuZFMNGxzQNJDQ7k4H6mqBujhQlwTqLk5eg4PTeGryzurSQF0cqKsF6nSAzk9yQU9jo6AUaBakw+VGNaGPkAyvfTI0vKTpk6EhXbZssEHTQsL14zQZLupqgbo4UJcG6pJAXZQrjataDXVNF8cjN11ztn2oWzwH7fIMfcC3qDCNf2GuHQu1HNTFCe5ASeJdq2uTV4P/wmbCe4iDoCfxHuM9h//GZsL7iIOgL/E+432Hr9lM+ABxEAwkPmB84PAf2Ez4EHEQDCU+ZHzo8J/ZTPgIcRCMJD5ifGSvZWxQDeu9M29mjF+xmfAx4iAYS3zM+NjhP7GZ8AniIJhIfML4pNzpie/0Fcx4/ZPNhE8RB8FU4lPGpw7/js2EzxAHwUziM8ZnDv+WzYTPEQfBXOJzxudw3UDFC/mA97ABxU81Vcz9ItuWLcNxjy7vyy6f2QbmtnhcC4/sM9lKVsfbzImXbjVaaWxqBSY4sdv/2zsaNzCrgmQL9morImtUK9m7lfIOAcvW5ue/ky6eDOBTTYuK611q18qE/tIw/rFYK++fXCvn5bXyc/Z+76AFDgT6sZD4gmd24fDf2Ux45uOQSTxjPONZl9jwOma8fsNmwpeIZ3ZCj/El48uy16Vfbipgg2pYtxo2rIb1r2Mmot+zmXCbz8uL+dx2+dw+h02rYb3rmOnsl2wmfI04CNYSXzO+Lntde68VsO51zHT2RzYTvkEcBBuJbxjflL1ufGQrYMNqWL8allXDRu/D2Lo37eT4OmaS7A82E75FHARbiW8Z35a9bn1ormDG69dsJnyHOAh2Et8xvit73fnUroD1q2FZNWxUDRvfFKsYydk7mwCTLb+ymfAccRDkEs8Zz8tec79qV8BGN/U2qIZlNx3b+KbY5joGEv2PfM99jg0ofrmlCiD4kyGXr7gFuizKLh9sA7ktHtfCC/WDbGVvPxn2Tvyheyk/2E+GA5jgxG7/be9o3MAcCpI9sldbEVmjOsjeHZR3CNh+bcx/nXTxZAD+k+F5bje8jg78dOjY7Vs4L+3aNTmqTYzehV22szodoPMdwhLUNf1OWQQ7ZW/8Tpmda3Buv25yL27jvJKP9kkqaZlKBYVFB+riQF10NoULpytkAj1I8aPNpwc3+XtMnJdQwll0R+ICA7I9+t37uOQ+BvAT7boYNh+82Acv2n3kjTj11PKx5HzGxDZj4nJQ6sVRH6miXp7/2mPifGvhu+43T1P/H4vIb6PGOyjO/oXzLbo307AGGgAA","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"1"}},{"name":"typ","value":{"kind":"string","value":"PublicMutable<AztecAddress, Context>"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"2"}},{"name":"typ","value":{"kind":"string","value":"SharedImmutable<EthAddress, Context>"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::get_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_public_parameters"}}],"kind":"struct","path":"TokenBridge::claim_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_private_parameters"}}],"kind":"struct","path":"TokenBridge::claim_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::constructor_parameters"}}],"kind":"struct","path":"TokenBridge::constructor_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_public_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi"}]}},"file_map":{"116":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // This looks the same as the &mut PublicContext impl, but is actually very different. In public execution the\n        // storage read oracle gets transpiled to SLOAD opcodes, whereas in unconstrained execution the PXE returns\n        // historical data.\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n"},"121":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"139":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"143":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::recursion::verification_key::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::log_hash::LogHash;\nuse crate::traits::is_empty;\nuse crate::utils::{uint256::U256, field::field_from_bytes_32_trunc};\nuse crate::constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n};\nuse crate::traits::Hash;\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(address: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_encrypted_log(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_unencrypted_log(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5, counter: 1234 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"144":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u64,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"146":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n"},"147":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"167":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"169":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"171":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n"},"172":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"176":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u64,\n    nullifier_read_requests: u64,\n    key_validation_requests_and_generators: u64,\n    new_note_hashes: u64,\n    new_nullifiers: u64,\n    new_l2_to_l1_msgs: u64,\n    private_call_requests: u64,\n    public_call_stack_hashes: u64,\n    note_encrypted_logs_hashes: u64,\n    encrypted_logs_hashes: u64,\n    unencrypted_logs_hashes: u64,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"177":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"179":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"180":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"184":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"187":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH}, hash::silo_nullifier,\n    traits::{Empty, Hash, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = silo_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"189":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"190":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x0933cf2bb384c9733d5a8311bfdc089489c2557df2265026579f9ac2b21d2ef9;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"191":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"192":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"197":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"198":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr","source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x1f0e71146c5d4a5bdcf517f0063cda7767e51fcb9cebc877feb348a77a7a6b4a;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x079a2b28b4853de9169d7dc40ac41c6d80b465d82c60195ede91504013f8b11b;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n"},"21":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"210":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::silo_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = silo_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"212":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"214":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"215":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"216":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"217":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"22":{"path":"std/field.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"222":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"223":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"233":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"234":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"235":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"249":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"250":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"252":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"253":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"255":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress}\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::{auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public}};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        storage.balances.add(\n            context.msg_sender(),\n            context.msg_sender(),\n            U128::from_integer(amount)\n        );\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes[0].unwrap_unchecked();\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        storage.balances.add(context.msg_sender(), to, U128::from_integer(amount));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount);\n        // docs:start:increase_private_balance\n        storage.balances.add(from, to, amount);\n        // docs:end:increase_private_balance\n    }\n    // docs:end:transfer\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all\n"},"270":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr","source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"},"29":{"path":"std/hash.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n"},"31":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"35":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"41":{"path":"std/slice.nr","source":"impl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u64, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u64) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<N>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n}\n"},"47":{"path":"/home/josh/Documents/test/aztec-token-bridge/packages/aztec-contracts/token_bridge/src/main.nr","source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n"},"55":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n"},"58":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"60":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, silo_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub fn compute_siloed_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    silo_nullifier(address, nullifier)\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n"},"63":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    * Should be automatically convertible to [Field; N]. For example str<N> works with\n    * one char per field. Otherwise you can use CompressedString.\n    */\n    pub fn emit_unencrypted_log_with_selector<T>(&mut self, event_selector: Field, log: T) {\n        emit_unencrypted_log(event_selector, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn emit_unencrypted_log<T, N, M>(&mut self, log: T) {\n        let event_selector = 5; // Matches current PublicContext.\n        self.emit_unencrypted_log_with_selector(event_selector, log);\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log<T>(event_selector: Field, message: T) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nfn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nfn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nfn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nfn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nfn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nfn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nfn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nfn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nfn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nfn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nfn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nfn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nfn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nfn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nfn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nfn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nfn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nfn emit_unencrypted_log_opcode<T>(event_selector: Field, message: T) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nfn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nfn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nfn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nfn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"65":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::{note_interface::NoteInterface, utils::compute_note_hash_for_insertion},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_log, emit_encrypted_note_log, compute_encrypted_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Ending setup at counter {0}\",\n            [self.side_effect_counter as Field]\n        );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(&mut self, log: T) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn encrypt_and_emit_log<N, M>(\n        &mut self,\n        contract_address: AztecAddress,\n        randomness: Field, // Secret random value used later for masked_contract_address\n        event_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        preimage: [Field; N]\n    ) where [Field; N]: LensForEncryptedLog<N, M> {\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        // We are currently just encrypting it EXACTLY the same way as if it was a note.\n        let counter = self.next_counter();\n        let encrypted_log: [u8; M] = compute_encrypted_log(\n            contract_address,\n            randomness,\n            event_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n        emit_encrypted_log(contract_address, randomness, encrypted_log, counter);\n        let len = 32 + 32 + 64 + 48 + 48 + 176 + 64 + (preimage.len() as Field * 32) + 16 + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n    }\n\n    pub fn encrypt_and_emit_note<Note, N, NB, M>(\n        &mut self,\n        contract_address: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        note: Note\n    ) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n        let note_hash_counter = note.get_header().note_hash_counter;\n        let note_exists_index = find_index(\n            self.new_note_hashes.storage,\n            |n: NoteHash| n.counter == note_hash_counter\n        );\n        assert(\n            note_exists_index != MAX_NEW_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n        );\n        let preimage = note.serialize_content();\n        let counter = self.next_counter();\n\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        // TODO(#1139 | #6408): perform encryption in the circuit\n        let encrypted_log: [u8; M] = compute_encrypted_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n\n        // Current unoptimized size of the encrypted log\n        // incoming_tag (32 bytes)\n        // outgoing_tag (32 bytes)\n        // eph_pk (64 bytes)\n        // incoming_header (48 bytes)\n        // outgoing_header (48 bytes)\n        // outgoing_body (176 bytes)\n        // incoming_body_fixed (64 bytes)\n        // incoming_body_variable (N * 32 bytes + 16 bytes padding) \n        // len of processed log (4 bytes)\n        let len = 32 + 32 + 64 + 48 + 48 + 176 + 64 + (preimage.len() as Field * 32) + 16 + 4;\n\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"69":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"71":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize};\n\nuse crate::context::private_context::PrivateContext;\nuse crate::context::public_context::PublicContext;\nuse crate::context::gas::GasOpts;\nuse crate::context::public_context::FunctionReturns;\n\nuse crate::oracle::arguments;\n\nstruct PrivateCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateCallInterface<T> {\n    pub fn call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateVoidCallInterface {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nstruct PrivateStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateStaticCallInterface<T> {\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateStaticVoidCallInterface {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nstruct PublicCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicStaticCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nstruct PublicStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicStaticVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"72":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"78":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nfn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"80":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"82":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nfn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nfn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"83":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n"},"88":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nfn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"92":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nfn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"93":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nfn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nfn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"94":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"95":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u64 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nfn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u64, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"98":{"path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"}}}