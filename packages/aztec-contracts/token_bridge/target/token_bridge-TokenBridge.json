{"noir_version":"0.30.0+68e1a0864791be84d2fe494e06af564e72582c86","name":"TokenBridge","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}],"portal_address":[{"start":4,"end":5}],"token":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":41,"end":42}],"caller_on_l1":[{"start":42,"end":43}],"inputs":[{"start":0,"end":39}],"nonce":[{"start":43,"end":44}],"recipient":[{"start":40,"end":41}],"token":[{"start":39,"end":40}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"return_witnesses":[1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578],"error_types":{}},"bytecode":"H4sIAAAAAAAA/+xdB5xdRdW/b7PZlM1uQu/kpffk3bclu6kvoffea7LZQOiGooAioKCCqICAUlTABvopooKgoqCCIqj0ImJBLNhFRPo3szsn+9+zc1+d83Ivd97vd3buzM6d+Z8zM2fO1JsJ+n+TRwbBG8P7nzOKhilqUJQF/zDzTP5G5h/O4o9g/hbmH8v8GzD/Rsy/maIC+Mez/2eZfwLzT2T+qcaPv4xxC8Zty3W2t/fOz/eGbeGKXL57ZVdHrr1jZWdX2BV2dHWsyne1tfV2tXfN717ZPT/XHba39YarO7rbVuf6f7MhrVyNP41tFKQ3TdGbiqYbd4ZxZxp3lnFne/dt684J+uss1os5Xi6pd+cGg38Nxi0YN1fbL5wauNOR8xziIt2u08wGA22D+M8YGZGr+6hc0N93YTz8ZRzLblN3aeUscGtNO6QHlEVo3DzIw1WG6zKmwtOZPRsMdNT5YGhHPUywUKqs0HlTocMwcNc48oFMZXGtEFzy3GZJa2WuZ1VHuLJz1fywd0VHV09Pd1sY5ld0ruhcme9a3buyI+zq6FJp9qzId6ns8it6wt7cis5e3bBHB5ZKG7hv2G2BW2OPfu2BYKOTEkS7QLodDiuZFN8d7svIitWFYtFYXSkCStdlGXUGbhuU7jR0mnpkaAa7denxpZS4a5w5hziHA875xu0ybrdxFxgeNjb+hYoWKVqsaImipQbPMkXLFW2naHtFOyjaUdFOinZWtIuiXRXtpmh3RXso2jOog6WyANKkH29QtTYCh4USdgVuC7hePavLiol49woS1rPmGGhX6e4dxLtn1Ynu7b6M6lqJuwOZSrxPkLBK3M1Au0p33yDelVjzva/7MqprJV4QyFTi/YKEVeIFDLSrdPcP4l2JNd/7uy8jEay6x9g3cD92OiBw2wj0zCNNaGlB6JnJbuMuMK7+HWhc1/zo8jxAIN2DHJYlH6e5rivz3aWVo/HMwYoOUXSoosMUHa7oCEVHKjpK0dGKVihaqahH0SpFvYpWKzpG0bGK1ig6TtHxQf/QgoYeBweDV18PYf5Dmf8w5j+c+Y9g/iOZ/yjmP5r5VzD/SubvYf5VzN/L/KuZ/xjmP5b51zD/ccx/fDC0g2k0bsG4udp+g+pQrW3nYAdp9a7u/x3iENesJpm5DF4WNfK86lB3aXUf5i6t8HCHZTE7EWXRGx7hLK2e8EhnaXWFRzksizmJKItceLSrtHpz4QpXafXkwpUOy2JuEsqiKxf2uEpL9T2rHKXVq9LqdVgW8xJQFj2K59WO0upSaR3jKC3Fcnisw7LIxb8sejXPa9yk1aPTOs5NWl06reMdlkVYp7LI1fYLHdp7oUN7JcT+tua10ISUhcN+LXSol8Ocw7JoEyoL1xuGHLbf0GH9C6Xk53pZ82CHaZ3gsFx1Gq7nlvS83UGB+/m1EwO3Ze2ab72ef7AA34ub4s23ro8nCvC9pE66sVacJzmUpcOyDpfEvN7o9nKCQL1ZFnO+DxZqL8sT0l5OdihLh2UdupQf34mvdYRe1zo5GFjfOsW4ruuX3lN2iED92kG4XdWK7xAjU9fp7piQ8dIpDnl+h0NcDutNmJSyWOSwLNYKteE4tQuuL3X903pybTCgL081rmt9qfffHhq41xu7xFxfHmpk6jrdXRPSRk91yPNpDnE5rDdhUspiscOyOF2oDcepXXB9qeuf1pOnBwP68gzjutaX+qzCYYF7vbFHzPXlYUamrtPdMyFt9AyHPL/TIS6H9SZMSlkscVgW7xJqw3FqF1xf6vqn9eS7ggF9eaZxXetLfa7r8MC93tgn5vrycCNT1+num5A2eqZDns9yiMthvQmTUhZLHZbF2UJtOE7tgutLXf+0njw7GNCX7zaua32p0zkiEDjHEHN9eYSRqet0D0xIG323Q57f4xCXw3oTJqUsCg7L4hyhNhyndsH1pa5/Wk+eEwzoy/ca17W+XBYMnF8JHMr6kJjryyONTJ3Piyakjb7XIc/nOsTlsN6ESSmLZQ7L4jyhNhyndsH15blBv548LxjQl+cb17W+XB4MnO8LHMr6iJjry6OMTJ3r4YS00fMd8vw+h7gc1pswKWWx3GFZvF+oDcepXXB9qeuf1pPvDwb05QXGda0v9T1URwfu9caKmOvLo41MXae7MiFt9AKHPF/oEJfDehMmpSy2c1gWHxBqw3FqF1xf6vqn9eQHggF9+UHjutaX+s6+FYF7vdEbc325wsjUdbqrE9JGP+iQ5w85xOWw3oRJKYvtHZbFRUJtOE7tgutLXf+0nrwoGNCXFxvXtb7U95uuDNzrjTUx15crjUxdp3tcQtroxQ55/rBDXA7rTZiUstjBYVlcItSG49QuuL7U9U/ryUuCAX35EeO61pc7BgP3iwUOZX1izPVlj5Gp63RPSkgb/YhDnj/qEJfDehMmpSx2dFgWHxNqw3FqF1xf6vqn9eTHggF9ealxXetLfW/+qsC93nhHzPXlKiNT1+muTUgbvdQhz5c5xOWw3oRJKYudHJbF5UJtOE7tgutLXf+0nrw8GNCXHzeua32pvzHSG7jXG6fHXF/2Gpm6TveMhLTRjzvk+QqHuBzWmzApZbGzw7K4UqgNx6ldcH2p65/Wk1cGA/ryKuO61pf6e0yrA/d648yY68vVRqau0z0rIW30Koc8f8IhLof1JkxKWezisCw+KdSG49QuuL7U9U/ryU8GA/ryauO61pf623XHBO71xntiri+PMTJ1ne45CWmjVzvk+RqHuBzWmzApZbGrw7K4VqgNx6ldcH2p65/Wk9cGA/ryOuO61pf6O5/HBu71xnkx15fHGpm6Tvf8hLTR6xzy/CmHuBzWmzApZbGbw7L4tFAbjlO74PpS1z+tJz8dDOjLzxjXtb7U30ReE7jXGxfEXF+uMTJ1ne6FCWmjn3HI8/UOcTmsN2FSymJ3h2Vxg1AbjlO74PpS1z+tJ28IBvTljcZ1rS/19+OPC9zrjQ/FXF8eZ2TqOt2LEtJGb3TI82cd4nJYb8KklMUeDsvic0JtOE7tgutLXf+0nvxcMKAvP29c1/pyz2Dw91VdyeeSmOvL441MXaf7kYS00c875PkLDnE5rDdhUspiT4dl8UWhNhyndsH1pa5/Wk9+MRjQlzcFg38NjstsnEM53+QOV66B8e26v5juEGvWpHOzoi8p+rKi/1P0FUVfVXSLoq8pulXR1xV9Q9E3Fd2m6HZF31J0h6I7FX1b0XcUfVfRXYq+p+j7iu5WdI+iHyj6oaIfKbpX0X2KfqzoJ0ZI9K1xjWVkMOD/EvN/mfn/j/m/wvxfZf5bmP9rzH8r83+d+b/B/N9k/tuY/3bm/xbz38H8dzL/t5n/O8z/Xea/i/m/x/zfZ/67mf8e5v8B8/+Q+X/E/Pcy/33M/2Pm/4nx48+1fsc2U6uuuNlBWvQ96S85xHVpnfraWnjWZfFlJ2n1l+v/1Z5W3sgv/IrDsrgszmXRvg5n+NXa0soBz+EttaSVHyS/8GsOy+LyeJZFjuEMb60yrc7VQ3gOv15dWl0W+YXfcFgWH49bWXRZcYbfrDyt+RE8h7dVmtb8SPmFtzssiyviUxb5IjjDb1WS1vyiPId3lJ9WTwn5hXc6LIsr41AW80viDL9dXlq5MngOv1NOWrmy5Bd+12FZXLV+y6KjTJzhXaXSai+b5/B7RdNqX12B/MLvOyyLT6yvsphfEc7w7ui0uirkObwnIq3u1RXLL/yBw7L4ZP3LIlcFzvCHtrRyVfEc/mhoWmGV8gvvdVgWV9ezLFZVjTO8b3BabTXwHP4Y0sqvrkl+4U8clsU1STm/7HBe3+H4Nrzc4Rz3tUk5G+lQfg7t+PBKh2VxXVLOXTmUn0N7Jfykw7L4VFLOdDiUn0O9HF7rsCw+LVQWwxyXhcP2Gzqsf6FL+Umv1c1wl9a6tbr7Ff1U0QOKHlT0M0U/V/QLRQ8peljRI4oeVfSYoscVPaHoSUVPKXpa0S8VPaPoV4qeVfRrRb9R9FtFv1P0nKLfK3pe0R8U/VHRnxT92QiJ1m40FlzL+SnzP8D8DzL/z5j/58z/C+Z/iPkfZv5HmP9R5n+M+R9n/ieY/0nmf4r5n2b+XzL/M8z/K+Z/lvl/zfy/Yf7fMv/vmP855v898z/P/H9g/j8y/5+Y/8+B/Fodtplade39DtKitbqfOsT11YSs1T3gJK3+cn2w9rTWrdX9zGFZ3JKQtbqf15bWoLW6X9SSFlure8hhWXwtIWt1D1eZlm2t7pHq0rKu1T3qsCxuTcha3WOVpxW5Vvd4pWkVWat7wmFZfD0ha3VPVpJWibW6p8pPq+Ra3dMOy+IbCVmr+2V5aZW1VvdMOWmVuVb3K4dl8c2ErNU9WyqtCtbqfh24W6v7jcOyuC0ha3W/Ddyt1f0ucLdW95zDsrg9IWt1vw/crdU9H7hbq/uDw7L4VkLW6v4YuFur+1Pgbq3uzw7L4o6EzIM7nB8IHY5vw685nAe/MyFl4XAcFDq048NvOCyLbyekLBzae6FDeyW83WFZfCchZeGwXwsd6uXwTodl8d2ErNU5bL+hw/oXfjdBa3Uz3aW1bq3uBUV/UfRXRX9T9HdF/1D0T0X/UvRvRS8q+o+ilxT9V9HLiv6n6BVFryp6TdHrit4I+s9WvmWYzyhqUDRMUaOi4YqaFI1QNFLRqEwwaK1OY8G1nL8w/1+Z/2/M/3fm/wfz/5P5/8X8/2b+F5n/P8z/EvP/l/lfZv7/Mf8rzP8q87/G/K8z/xvM/ybzv8X8+gH9GeZvYP5hzN/I/MOZv4n5RzD/SOYflZFfq8M2U6uufcFBWrRW9xeHuB5MyFrdX52k1V+uf6s9rXVrdX93WBY/S8ha3T9qS2vQWt0/a0mLrdX9y2FZ/Dwha3X/rjIt21rdi9WlZV2r+4/DsvhFQtbqXqo8rci1uv9WmlaRtbqXHZbFQwlZq/tfJWmVWKt7pfy0Sq7VveqwLB5OyFrda+WlVdZa3evlpFXmWt0bDsvikYSs1b1ZKq0K1ureCtyt1WnD3lVZPJqQtbpMxt1aXUPG3VrdMIdl8VhC1uoaM+7W6oZn3K3VNTksi8cTslY3IuNurW5kxt1a3SiHZfFEQubBHc4PhA7Ht+HPHc6DP5mQsnA4Dgod2vHhww7L4qmElIVDey90aK+Ejzksi6cTUhYO+7XQoV4On3RYFr9MyFqdw/YbOqx/oZT8+DpdreU8OuMKZ2e3JM5mZzjb8pI4xzjD2bVKEmeLM5y9PRqb1rEEeLRZK2s27hjjthiX7qj8sXHpTst7jUt3YP7QuD8w7j3Gvdu43zcu3clJd3XSHZ50tyfd+Ul3gdIdoXR3KN0pSneN0h2kdDcp3VlKd5nSHae3GJfuRKW7UukOVbpble5cpbtY6dzfn4xL5wT/YFw6V0jnDekc4u+M+1vj/sa4dM6Rzj/SuUg6L0nnKOl8JZ27pPOYdE6Tzm/SuU4670nnQOl8KJ0bpfOkdM6Uzp/SuVQ6r0rnWOl8K62l0horrb3Smiyt1dIaLq3trlvzpbVY49LaMa0p01ozrUHT2jStWdNaNq1x09o3rYnTWjmtodPaOq2501o8rdHT2j2t6dNaP+0BoL0BtGegVeEeq2icog0UbahoI0UbK9pE0aaKNlO0uaItFG2paCtFWyvaRtG2isYryiqaoGiiokmKJiuaomiqommKpiuaoWimolmKZiuaQ4rE/FzrlbnO9Eour7HhvdgZU8Y6D+1upmie3qth/tcQDP1x/nK1/cJ8UJ9+PVfbL5znrhxyTYAzZ4CGxs0bt8247WaPzHQTv0N5OhXNV9SlqFvRAkULFS1StFjREkVLNV5FyxQtV7Sdou0V7aBoR0U7KdpZ0S6KdlW0m6LdFe2haE9FeynaW9E+ivZVtJ+i/RUdoOhARQcpOljRIYoOVXSYosMzA3Jf9ys4KgDaONIOBUE/bgTX2ugcFnYYOpx0OsJhJdSNfHRgKbDAfeNxiRvxHilZ4aQEgaBdpXuUw0omxfdRGedl1FeJG4L69FQuewBJnKFQYzsaG5trM+eojPueggAPN/56aDqXwsdKvcIAXZnpN9edC/9oAa10tOMWI8V3gyDftWLsEZZhrrZfqCtmT8Z92axyrMW0AtBpnmvSdC2HlUJy6BWQQ6+gHEIhOfwl5t+Lk2oHf12/fJfcDydV7/+WkPUSh/UydFjWoUv5aQNKz0fbrOygQnmW3EcGP4m+ypVM0JhcXcwyztX2C3sEOgAEXCHesFQeGu9qAYXwr5gsZldisNXK8zGZeCoXl2VBdfIYMEqqLZtS8nZZNsdCWmFbm2oXq+aHq1etbuuY351fGXa2dXaubl89v7OrfdXqjvYVq+b3hu0r2vLdvfNzq8Ou3t75HW098ztXd6/q6VyNyjpc1dbWvqp7ZU/Yke9csVItW7atyK1un9+Wz61Y1TZ/1aq2rs7OFW1tqzq7Vnd1d+XzK1a3deU65s/vznXm27rzEmVzrCmbeo6kXU63YMe1xgA9LilKWwrfGgElfbxAZ3W84GhFy+E4ATmcICCHEwTlME/Iin8x5qM2qXbwn5iP2qTq/UsJGbU5rJehw7IOX/KjNv4L1wiN2k5M2qjtROFR24kCCuGVFI7aTsrEU7m8IjAyOClho7aTHY7aXnI4apMom5Nh1BbVEcR5ik0Sp1SnckrSOpVThDuVUwQ6lddifueNRKfyVyGLtVZcr9fJ4q8V5zscdsoO61/4uoDif0cZnXKt8lybcdf5DZr+jFGn/JpA2ax9G02lnmqAnpaxbErK1fYLozbnuNxpVmtaDjc4iWw3JRm6VqZSMqw1rdNjXh66wZwuYBCdIWAYniE43XyakBzeKSCHdwpPu0vI4a2YT7tLtYNgRLyn3aXqfcYx3/RzPe3usF6GDss6dCm/t8u0+6lCMyTvkpwhOV2gA3iX4AyJxvsuAYUwXEghuJ52P92h8XdmJp7KxWVZUJ08sw7T7i7L5iyH0+6orGsd4UuUzVnrYYQvdezobAP03UlR2lL4zhZQ0u8R6KzeIzha0XJ4t4AczhGQwzkZ2SMuElb8iPU7eilrdkWiHYyM+ahNqt6PSsiozWG9DB2WdTjKj9r4LzxbaNT23qSN2t4rPGp7r4BCaEnhqO3cTDyVS4vAyODchI3aznM4ahvlcNQmUTbnZeq/WcrlFJskTqlO5fykdSrnC3cq5wt0KmPr1Km4XLuN0TrQoE6lVlzj6mTx14rzfQ47ZYf1LxwnoPjfl5HfLPX+jLvOb9D0Z4w65bECZfN+S9m4Ht3Oc6h32hymdYHD/qued/1dIGQsXJhJ2F1/WhAXZtyn+wGXHaUQ3x/IOC+jut7115YQy3yeUGP7YEbwrr8POLQuqKcgwG+HbbUfMkAvygjc9aeF/0EBrfRB4UU8V3w3CPJdK8aLhWWYq+0X6op5scAQ9cMCQ/UPCy4AXiQkh0sE5HBJRnb7qoQcNor5QqhUO9g45guhUvV+k4QshDqsl6HDsg438Quh/NfXV7mSCRqTH8kIzllfLNABfERwzlrj/YiAQtgiIQuhFzs0/j6aiady2UJgXu+jGfmFUJdl8zGHC6GbOJxzlSibj2Xqv33V5XQLdlyXGqCXJUVpS+G7VEBJXy7QWV0uOFrRcrhMQA4fF5DDxwXl0CZkxW8V81GbVDvYOuajNql6v01CRm0O62XosKzDbfyojf/CS4VGbVckbdR2hfCo7QoBhTAhhaO2KzPxVC4TBEYGVyZs1HaVw1HbNg5HbRJlc1Wm/ttXXU6xSeKU6lQ+kbRO5RPCnconBDqVSQnZvupScW0sZLHWimtyQravftJhp+yw/oWTBRT/JzPy21evzrjr/DYZEc9OeZJA2Vz9NppKvcYAvTYjcNdf1OYclzvNak3L4QYnke2mJEPXylRKhrWmdV3My0M3mOsEDKJPCRiGnxKcbr5WSA6fFpDDp4Wn3SXkMC3m0+5S7WB6zKfdper9jIRMuzusl6HDsg5n+Gl3/uvrq1zJBI3cz0jOkFwn0AF8RnCGROP9jIBCmJOQaffrHBp/12fiqVzmCIwir6/DtLvLsrnB4bT7DIcjfImyuWE9jPCljh3daIB+NilKWwrfjQJK+nMCndXnBEcrWg6fFZDD5wXk8PmM7BEXCSt+XsxHbVLtIBfzUZtUvQ8TMmpzWC9Dh2Udhn7Uxn/hjUKjti8kbdT2BeFR2xcEFEJHCkdtX8zEU7l0CIwMvpiwUdtNDkdtocNRm0TZ3JSp/2Ypl1NskjilOpWbk9ap3Czcqdws0KnMT8hmKZeKa7qQxVorrq6EbJb6ksNO2WH9C7sEFP+XMvKbpb6ccdf5zRgRz055vkDZfBk65XrdVdcu1Nn9XyZhd9VpQfxfxn26X3Go6KX4/krGeRnV9cLFNqFK/NWkVWItiK8KVOJbYl6JNd+3CFRiG1YXuwm19dfgWAYuLcqvxXyN6iumvF2Xza2ZeNcd/dXp0wXqjsubx78ecxnquq3L2fW6gcM2E97qsDy+EfPy0PXlGwJt+ZsZ2b665vVPleA3BfheOCLeujsU4nuR0GyDa13rsHzCRY7XBOtlsLv8WCfivS1pBrsWxG0CBvvtMTfYNd+3J3zUmReqxN9KWiXWgviWQCW+I+aVWPN9R51Gnbnafn0K4Q6BXvfOmI8U9SjxTgG+v+248Y8KBubhtXJ8U7l547Ybt824+vcdw5BrvvTI+tsC8vquQ2ucLDL6ua4zOYdlO92kc5dK83uKvq/obkX3KPqBoh8q+pGiexXdp+jHin6i6H5FP1X0gKIHFf1M0c8V/ULRQ4oeVvSIokcVPabocUVPKHpS0VOKnlb0S0XPKPqVomcV/VrRbxT9VtHvFD2n6PeKnjczClqOwwzWDPi/x/zfZ/67mf8e5v8B8/+Q+X/E/Pcy/33M/2Pm/wnz38/8P2X+B5j/Qeb/GfP/nPl/wfwPMf/DzP8I8z/K/I8x/+PM/wTzP8n8TzH/08z/S+Z/hvl/xfzPMv+vmf83zP9b5v8d8z/H/L9n/uczQw2eSjcKVdKma9VldzlIq3d1/+97DnEtjfneB8Pzqu+7k1/33e7SCu9xWBaFRJRFb/gDZ/LrCX/oLK2u8EcOy2JZIsoiF97rSn69ufA+V2n15MIfOyyL5Ukoi65c+BNX8lN9z/2O0upVaf3UYVlsl4Cy6FE8P+BIfl0qrQcdpaVYDn/msCy2j39Z9Gqef+5Gfj06rV+4SatLp/WQw7LYIf5loZMOH3Yiv96+tB5xklZPX1qPOiyLHWNfFl19PD/mRH59MMPHXaTV25/WEw7LYqe4l0VPP89PupBfV39aT7lIq5/l8GmHZbFzzMtileH5lw54XmnSesZBWvNNWr9yWBa7xLss8nQS89naeQ4prV/XnFbXakrrNw7LYtdYl0XXSuL5t7XLb90J29/VnNb8dWk957Asdot1WXSs4/n3NfMcrkvr+Yy7OculDs/i7B6Tw7YlfqHDebPQ4bxPuNxhWeyRkLJwOD8QOhzfhjs4LIs9E1IWDsdBoUM7PtzZYVnslZCycGjvhQ7tlXA3h2Wxd0LKwmG/FjrUy+GeDstin4TcnOOw/YYO618oJb8GJr84rCtTWn9waIfqNDKO64rev/TdjPt9Rn/MuC1r13x3ZAb217jkuzfmu/51ffyjAN+rE3LHwJ8ctkeHZR2ujnm90e3lDwL1Zk3M+b5LqL0cl5D28meH7cVhWYcu5afLVu/7JTtC6wi9v/fPmYF9vi+YCuC6fnVmBvZ1uiy3E2N+q6fm+QUBvk9KyHjpBYc25l8ctlGH9SZMSll0OiyLv2Zk2nCc2gXXl38xevKvoC//JqQv52cG9r1jurXK5x0x15ea578J8L02IW30bw7b1d8d6kuH9SZMSlnMd1gW/8jItOE4tQuuL/9u9OQ/QF/+U0hfdmUGzgVhurXK5/SY60vN8z8F+D4jIW30nw7b1b8c6kuH9SZMSll0OSyLf2dk2nCc2gXXl/8yevLfoC9fFNKX3ZmBc5OYbq3yOTPm+lLz/KIA32clpI2+6LBd/cehvnRYb8KklEW3w7J4KSPThuPULri+/I/Rky+BvvyvkL5ckBk4V47p1iqf98RcX2qe/yvA9zkJaaP/ddiuXnaoLx3WmzApZbHAYVn8LyPThuPULri+fNnoyf+BvnxFSF8uzAzcu4Hp1iqf82KuLzXPrwjwfX5C2ugrDtvVqw71pcN6EyalLBY6LIvXMjJtOE7tguvLV42efA305etC+nJRZuBeIky3VvlcEHN9qXl+XYDvCxPSRl932K7ecKgvHdabMCllschhWbyZkWnDcWoXXF++YfTkm6Av3xLSl4szA/e2Ybq1yudDMdeXmue3BPi+KCFt9C2H7UpXXFe4HNabMCllsdhhWWQaZNpwnNoF15f6QevJTMOAvmww/3StL5dkBu61xHRrlc8lMdeXmmctU9fpfiQhbbTBYbsa5lBfOqw3YVLKYolDfdnYINOG49QuuL4cZvRkI+jL4UL6cmlm4N5fTLdW+Vwac32peR4uoC8vS0gbHe6wXTU51JcO602YlLJY6lBfjmiQacNxahdcXzYZPTkC9OVIIX1ZyAzci47p1iqfK2KuLzXPIwX05ZUJaaMjHbarUQ71pcN6EyalLAoO9eXoBpk2HKd2wfXlKKMnR4O+bBbSl8syA9+NwHRrlc8nY64vNc/NAvry6oS00WaH7WqMQ33psN6ESSmLZQ71ZUuDTBuOU7vg+nKM0ZMtoC9bhfTl8szAd3Uw3Vrlc13M9aXmuVVAX34qIW201WG7GutQXzqsN2FSymK5Q305rkGmDcepXXB9OdboyXGgLzcQ0pfbZQa+O4bp1iqf62OuLzXPGwjoyxsS0kY3cNiuNnSoLx3WmzApZbGdQ325UYNMG45Tu+D6ckOjJzcCfbmxkL7cPjPwXUZMt1b5fC7m+lLzvLGAvvx8Qtroxg7b1SYO9aXDehMmpSy2d6gvN22QacNxahdcX25i9OSmoC83E9KXO2QGvluL6dYqn5tiri81z5sJ6MubE9JGN3PYrjZ3qC8d1pswKWWxg0N9uUWDTBuOU7vg+nJzoye3AH25pZC+3DEz8F1vTLdW+fxfzPWl5nlLAX35lYS00S0dtqutHOpLh/UmTEpZ7OhQX27dINOG49QuuL7cyujJrUFfbiOkL3dSCf5CQF9+Leb6UvO8jYC+vDUhbXQbh+1qW4f60mG9CZNSFjs51JfjG2TacJzaBdeX2xo9OR70ZVZIX+6sEnxIQF9+M+b6UvOcFdCXtyWkjWYdtqsJDvWlw3oTJqUsdnaoLyc2yLThOLULri8nGD05EfTlJCF9uYtK8GEBfXlHzPWl5nmSgL68MyFtdJLDdjXZob50WG/CpJTFLg715ZQGmTYcp3bB9eVkoyengL6cKqQvd1UJPiKgL78bc32peZ4qoC/vSkgbneqwXU1zqC8d1pswKWWxq0N9Ob1Bpg3HqV1wfTnN6MnpoC9nCOnL3VSCjwroy7tjri81zzME9OU9CWmjMxy2q5kO9aXDehMmpSx2c6gvZzXItOE4tQuuL2caPTkL9OVsIX25u0rwMQF9+aOY60vN82wBfXlvQtrobIftao5Dfemw3oRJKYvdHerLuQ0ybThO7YLryzlGT84FfTlPSF/uoRJ8XEBf/iTm+lLzPE9AX96fkDY6z2G7yjnUlw7rTZiUstjDob4MG2TacJzaBdeXOaMnQ9CXeSF9uadK8AkBfflgzPWl5jkvoC9/lpA2mnfYrtoc6kuH9SZMSlns6VBftjfItOE4tQuuL9uMnmwHfdkhpC/3Ugk+KaAvH4q5vtQ8dwjoy4cT0kY7HLarTof60mG9CZNSFns51JfzG2TacJzaBdeXnUZPzgd92SWkL/dWCT4loC8fi7m+1Dx3CejLxxPSRrsctqtuh/rSYb0Jk1IWezvUlwsaZNpwnNoF15fdRk8uAH25UEhf7qMSfFpAXz4Vc32peV4ooC+fTkgbXeiwXS1yqC8d1pswKWWxj0N9ubhBpg3HqV1wfbnI6MnFoC+XCOnLfVWCvxTQl7+Kub7UPC8R0JfPJuWbMQ7b1VKH+tJhvQmTUhb7OtSXhQaZNhyndsH15VKjJwugL5cJ6cv9VILPCOjL38ZcX2qelwnoy98l5U5vh+1quUN96bDehEkpi/0c6svtGmTacJzaBdeXy42e3A705fZC+nJ/leCvBPTl8zHXl5rn7QX05R+Scueiw3a1g0N96bDehEkpi/0d6ssdG2TacJzaBdeXOxg9uSPoy52E9OUBKsFnBfTln2OuLzXPOwnoyxeScieOw3a1s0N96bDehEkpiwMc6stdGmTacJzaBdeXOxs9uQvoy12F9OWBKsFfC+jLv8VcX2qedxXQl39Pypllh+1qN4f60mG9CZNSFgc61Je7N8i04Ti1C64vdzN6cnfQl3sI6cuDVIK/EdCX/4q5vtQ87yGgL/+dlDMlDtvVng71pcN6EyalLA5yqC/3apBpw3FqF1xf7mn05F6gL/cW0pcHqwR/K6AvX4q5vtQ87y2gL/+blD1/DtvVPg71pcN6EyalLA52qC/3bZBpw3FqF1xf7mP05L6gL/cT0peHqAR/J6AvX4m5vtQ87yegL19Nypqsw3a1v0N96bDehEkpi0Mc6ssDGmTacJzaBdeX+xs9eQDoywOF9OWhKsHnBPTlGzHXl5rnAwX05ZtJmTNz2K4OcqgvHdabMCllcahDfXlwg0wbjlO74PryIKMnDwZ9eYiQvjxMJfh7AX2ZGRlvfal5PkRAXzaMTIhN47BdHepQXzqsN2FSyuIwh/rysAaZNhyndsH15aFGTx4G+vJwIX15uErweQF9OTzm+lLzfLiAvmxKSBs93GG7OsKhvnRYb8LElIVDfXlkg0wbjlO74PryCKMnjwR9eVRDMOjX4LjMNgzcyeaoBlldmavtF+ZVgt8U6COObnBbJ4Yp0ml+JpAt+3kOZbDCpa1pZKDTzCp3uCHWFAb9XOadYWm7rofTArf1hX4rG4Zid9ehqTSaDAXCAsoEMh2eK5m0zV85P1zdtUpSBisbZGTgGueKhOBsDOJdp+iXAf5HmeceJeNVinoVrVZ0jKJjFa1RdJyi46UbPlopkoW0qiHWhRTSA8riBOM5UbIQqEvUmT3L8hgmWAhVmgV5YxaEJzg0408UqhyuzSqXPJ9kSWtlrmdVR7iyc9X8sHdFR1dPT3dbGOZXdK7oXJnvWt27siPs6uhSafasyHep7PIresLe3IrOXt2QRweWShq4b8gnNbjXiPp3smQjkxLEyQ3u0z3FYSWT4vuUBudlJDKHdqLB6koRULouy+gdAmNMneaEoH9sVa8e/pgE9vBrjefUevTwa00PT/5TzSAYf657/GMc9vhrHVb6UxPS47vk+bSE9vinCfX4pyetx9eCOF2gxz8j5j2+5vuMhPT4pxqsrnt8l2X0ToEe/53rocc/Nt49Pv3yKIt3Gc+Z9ejxdWZvsDxc9/DHOqiYvav7f+9yWMnPTEgP75LnsyCtsKstn5/fpuN1rcqF7at68l35/KqV7bme3IqefG93e9i9uj3f3tazqmelSnNFuDq3ekVP9+quflz17OHPEurhz05aD68FcbZAD//umPfwmu93J6SHP9NgdZ3uewR65fcYS6SevfKaBPbK5xjPe+vRK59jemXy2zJ13UuvcdhLn+NQmbw3Ib20S57PTWgvfa5QL31e0nppLYjzBHrp82PeS2u+z09IL/1eg9V1uu8T6KXftx566ePi3UtbZ8vfbzwX1KOX1pnhbLnONMvydN1LH1e7Alg3W/5+h8rkgoT00i55vrAhmbPlFwr10h9IWi+tBfEBgV76gzHvpTXfH0xIL32BwepKEVC6LsvoQwI9vk5zQjD451oZZhyWU49QB+C67p/ooNz1MKs3N7+9WNnEaU97UjrnlQ7b5PEJqY/1WoSoVZ4OtzCH700Izw6PAoSrU8hzb0L0zgqHeueiBrf9s7YFLrIMLF3bWRc7wE1HU/jZQp22PlM4O+h39UDnww0DxwwaGgZ4ehPcU9l7jcZdYcJXsv9717ve9a53vetd73rXu971rne9693kubMUXQLzBLSYTvMDHzbj/0uMq+8T+gjELwQDP/3/GZCul2+63I9a6sVH/fxR6t2PNfTvqhoR1OWOpzaa08Wf6zUlh2nlpDDOSADGWQ4x4saYSxuEN8rQz/VCycccLpRc6nBxSDfgkUF97gdzeYGaBW7Naa9qX93T093ZKymDjyVkcf2ihOBMyv1giyHNy4xyudy4HzfuFca90rhXGfcTxv2kca827jXGvda41xn3U8b9tHE/Y5RmweR/vfLfoOhGRZ9V9DlFn1f0BUVfVHSTopsVfUnRlxX9n6KvKPqqolsUfU3RrYq+rugbir6p6DZFtyv6lqI7FN2p6NuKvqPou4ruUvQ9Rd9XdLeiexT9QNEPFf1I0b2K7lP0Y0U/UXS/op8qekDRg4p+pujnin6h6CFFDyt6RNGjih5T9LiiJxQ9qegpRU8r+qWiZxT9StGzin6t6DdMFr9V/t8pek7R7xU9r+gPiv6o6E+K/qzoBUV/UfRXRX9T9HdF/1D0T0X/UvRvRS8q+o+ilxT9V9HLiv6n6BVFryp6TdHrit5Q9Kait3TZKGsmo6hB0TBFjYqGK2pSNELRSEWjFI1W1KxojKIWRa2Kxioap2gDRRsq2kjRxoo2UbSpos0Uba5oC0VbKtpK0daKtlG0raLxirLDBstigvJPVDRJ0WRFUxRNVTRN0XRFMxTNVDRL0WxFcxTNVTRPUU5RqCivqE1Ru6IORZ2K5ivqUtStaIGihYoWKVqsaImipYoKipYpWq5oO0XbK9pB0Y6KdlK0s6JdFO2qaDdFuyvaQ9GeivZStLeifRTtq2g/RfsrOkDRgYoOUnSwokMUHaroMEWHKzpC0ZGKjlJ0tJFF1shihfKvVNSjaJWiXkWrFR2j6FhFaxQdp+h4RScoOlHRSYpOVnSKoncoWqvoVEWnKTpd0RmK3qnoXYrOVHSWorMVvVvRexSdo+i9is41WEghnaf85yt6n6L3K7pA0YWKPqDog4o+pOgiRRcr+rCiSxR9RNFHFX1M0aWKLlN0uaKPK7pC0ZWKrlL0CUWfVHS1omsUXavoOkWfUvRpRZ9RdL2iGxTdqOizij6n6POKvqDoi4puUnSzoi8p+rKi/1P0FUVfVXSL4WVzw8vXlP9WRV9X9A1F31R0m6LbFX1L0R2K7lT0bUXfUfRdRXcp+p6i7yu6W9E9in6g6IeKfqToXkX3KfqxyWucyesnyn+/op8qekDRg4p+pujnin6h6CFFDyt6RNGjih5T9LiiJxQ9Oaw/jadMmmQfPa38v1T0jKJfKXpW0a9N3N8Y97fDBrer3yn/c4p+r+h5RX9Q9EdFf1L0Z0UvKPqLor8q+puivyv6h6J/KvqXon8relHRfxS9pOi/il5W9D9Fryh6VdFril5X9IaiNxW9pbGozjGjqEHRMEWNioYralI0QtFIRaMUjVbUrGiMohZFrYrGKhqnaANFGyraSNHGijZRtKmizRRtrmgLRVsq2krR1oq2UbStovGKsoomNA4uk4nKP0nRZEVTFE1VNE3RdEUzFM1UNEvRbEVzFM1VNE+R3kUXmrTGmLTyyt+mqF1Rh6JORfMVdSnqVrRA0UJFixQtNremLzHuUuMWjLvMuMuNu51xtzfuDsbd0bg7GXdn4+5i3F2Nu5txdzfuHsbd07h7GXdv4+5j3H2Nu59x9zfuAcY90LgHGfdg4x5i3EONe5hxDzfuEY11ONbzcdO5kl8bMFnwf5L9/2r2/+uY/1Ms/qeZ/zMs/g3M/1nm/zzzf5H5b2b+LzP/V5j/Fua/lfm/wfy3Mf+3mP9O5v8O89/F/N9n/nuY/4fMfy/z/5j572f+B5j/Z8z/C+Z/mPkfZf7Hmf9J5n+a+Z9h/meZ/zfM/zvm/z3z/4H5/8T8LzD/X5n/78z/T+b/N/P/h/n/y/z/Y/5Xmf915n+T+fUf9DcwfyPzNzH/SOYfzfxjmL+V+ccx/4bMvzHzb8r8mzP/lsy/NfNvy/xZ5l/J/KuYfzXzH8v8xzH/Ccx/EvOfwvxrmf805j+D+d/F/Gcx/7uZ/xzmP5f5z2f+C5j/g8x/MfN/hPkvZf6PM/9VzH8181/H/J9h/huZ//PMfxPzf5n5v8r82qDMgP+b7P+3Mf+dLP632f+/w/zfZ/HvZv+/h/nvZfHvY///MfM/w/y/Zv7fMP9vmf855n+e+f/I/H9m/r8w/9+Y/x/M/y/mf5H5X2L+l5n/FeZ/jfnfYP63mF8bt+gfxvzDmX8E849i/mbmb2H+scy/AfNvxPybMP9mzL8F82/F/Nsw/3jmn8D8k5h/GvPPYv55zN/G/J3M3838i5h/KfPvwPw7Mf8uzL8b82sjuQD+g9j/D2b+Q5j/UOPHX4NxC8aN06mFqxtkJjPjzPNvhiXjpMtvh7mT35GN7sdeR5ZR13O1/QYt4NQqg8uE6nrGMc+XN9TOc7gy19bW2d0mWTYuFxivSUjZfCIh+rLRIc+fTAjPDhd7wysTwnPGIc9X1KkN1vz1QAd9GS28a2x6l9kDBqSuQ3q3kc5Du3p+8U3Dw5vw/6saBu9OajTuRSb8Y8a91rjXGfdTxv20cT9j3OuNe4NxbzTuZ437OeN+3rhfMO4XjXuTcW827peM+2Xj/p9xv2Lcrxr3FuN+zbi3Gvfrxv2Gcb9p3NuMe7txv2XcO4x7p3G/bdzvGPe7xr3LuN8z7veNe7dx7zHuD4z7Q+P+yLj3Gvc+4/7YuD8x7v3G/alxHzDug8b9mXF/btxfGPch4z5s3EeM+6hxHzPu48Z9wrhPGvcp4z5t3F8a9xnj/sq4zxr318b9jXF/a9zfGfc54/7euM8b9w/G/aNx/2TcPxv3BeP+xbh/Ne7fjPt34/7DuP807r+M+2/jvmjc/xj3JeP+17gvG/d/xn3FuK8a9zXjvm7cN4z7pnHfMq42JPval3EbjDvMuI3GHW7cJuOOMO5I444y7mjjNht3jHFbjNtq3LHGHWfcDYy7oXE3Mu7Gxt3EuJsadzPjbm7cLYy7pXG3Mu7Wxt3GuNsad7xxs8adYNyJxp1k3MnGnWLcqcadZtzpxp1h3JnGnWXc2cadY9y5xp1n3JxxQ+Pmjdtm3Hbjdhi307jzjdtl3G7jLjDuQuMuMu5i4y4x7lLjFoy7zLjLjbudcbc37g7G3dG4Oxl3Z+PuYtxdjbubcXc37h7G3dO4exl3b+PuY9x9jbufcfc37gHGPdC4Bxn3YOMeYtxDjXuYcQ837hHGPdK4Rxn3aOOuMO5K4/YYd5Vxe4272rjHGPdY464x7nHGPd64Jxj3ROOeZNyTjXuKcd9h3LXGPdW4pxn3dOOeYdx3Gvddxj3TuGcZ92zjvtu47zHuOcZ9r3HPNe55xj3fuO8z7vuNe4FxLzTuB4z7QeN+yLgXGfdi437YuJcY9yPG/ahxP2bcS417mXEvN+7HjXuFca807lXG/YRxP2ncq417jXGvNe51xv2UcT9t3M8Y93rj3mDcG437WeN+zrifN+4XjPtF495k3JuN+yXjftm4/2fcrxj3q8a9xbhfM+6txv26cb9h3G8a9zbj3m7cbxn3DuPeadxvG/c7xv2uce8y7veM+33j3m3ce4z7A+P+0Lg/Mu69xr3PuD827k+Me79xf2rcB4z7oHF/ZtyfG/cXxn3IuA8b9xHjPmrcx4z7uHGfMO6Txn3KuE8b95fGfca4vzLus8b9NdVX6v+N/3fGfc64vzfu88b9g3H/aNw/GffPxn3BuH8x7l+N+zfj/t24/zDuP437L+P+27gvGvc/xn3JuP817svG/Z9xXzHuq8Z9zbivG/cN475p3LeMGxg7O2PcBuMOM26jcYcbt8m4I4w70rijjDvauM3GHWPcFuO2GnescccZdwPjbmjcjYy7sXE3Me6mxt3MuJsbdwvjbmncrYy7tXG3Me62xh1v3KxxJxh3onEnGXeycacYd6pxpxl3unFnGHemcWcZd7Zx5xh3rnHnGTdn3NC4eeO2GbfduB3G7TTufON2GbfbuAuMu9C4i4y72LhLjLvUuAXjLjPucuNuZ9ztjbuDcXc07k7G3dm4uxh3V+PuZtzdjbuHcfc07l7G3du4+xh3X+PuZ9z9jXuAcQ807kHGPdi4hxj3UOMeZtzDjXsE1S9FR+vBIvxcz1FdKzSObxyKM8zV8GvNMJw1pDY2M4TnqlMbl3E3VzFqZN3KIlcL1xtkrDirSm3DTATPVaS2kcOyGF3vsshVx/XGmSI4K0xtk0xRnitKbVOHZdG8fsoiVynXm2VK4iw7tc0zZfBcZmpbOCyLMeuzLHLlc71lpkycZaS2VaZsnkumtrXDsmhZ/2WRK4frbTIV4Sya2raZCnkuktp4h2XRGpeyyBXnOpupAmdEahMyVfFsTW2iw7IYG6+yyEVxPSlTNc4hqU3O1MAzS22Kw7IYF8eyyA3lemqmRpyQ2rRMzTyvS226w7LYIL5lkUOuZ2Sc4OxLbWbGEc8qtVkOy2LDuJdF/y+cnXGXlsPxbYjjs1rLYqOElIXDcVDo0I4PWxyWxcYJKQuH9l7o0F4Jxzksi00SUhYO+7XQoV4ON3JYFpvWqSxq/rqJw73DDnVB6LAuh1Jl0eC4Xbgs15WNyeA545DnnoTw3OCQ51UJ4XmYQ557E8Jzo0OeVyeE5+EOeT4mITzPdcjzsQnhebZDntekkOfjUsjz8Snk+YQU8nxiCnk+KYU8n5xCnk9JIc/vSCHPa1PI86kp5Pm0FPJ8egp5PiOFPL8zhTy/K4U8n5lCns9KIc9np5Dnd6eQ5/ekkOdzUsjze1PI87kp5Pm8FPJ8fgp5fl8KeX5/Cnm+IIU8X5hCnj+QQp4/mEKeP5RCni9KIc8Xp5DnD6eQ50tSyPNHUsjzR1PI88dSyPOlKeT5shTyfHkKef54Cnm+IoU8X5lCnq9KIc+fSCHPn0whz1enkOdrUsjztSnk+boU8vypFPL86RTy/JkU8nx9Cnm+IYU835hCnj+bQp4/l0KeP59Cnr+QQp6/mEKeb0ohzzenkOcvpZDnL6eQ5/9LIc9fSSHPX00hz7ekkOevpZDnW1PI89dTyPM3UsjzN1PI820p5Pn2FPL8rRTyfEcKeb4zhTx/O4U8fyeFPH83hTzflUKev5dCnr+fQp7vTiHP96SQ5x+kkOcfppDnH6WQ53tTyPN9KeT5xynk+Scp5Pn+FPL80xTy/EAKeX4whTz/LIU8/zyFPP8ihTw/lEKeH04hz4+kkOdHU8jzYynk+fEU8vxECnl+MoU8P5VCnp9OIc+/TCHPz6SQ51+lkOdnU8jzr1PI829SyPNvU8jz71LI83Mp5Pn3KeT5+RTy/IcU8vzHFPL8pxTy/OcU8vxCCnn+Swp5/msKef5bCnn+ewp5/kcKef5nCnn+Vwp5/ncKeX4xhTz/J4U8v5RCnv+bQp5fTiHP/0shz6+kkOdXU8jzaynk+fUU8vxGCnl+M4U8v5VCnoPh6eM5k0KeG1LI87AU8tyYQp6Hp5DnphTyPCKFPI9MIc+jUsjz6BTy3JxCnsekkOeWFPLcmkKex6aQ53Ep5HmDFPK8YQp53iiFPG+cQp43SSHPm6aQ581SyPPmKeR5ixTyvGUKed4qhTxvnUKet0khz9umkOfxKeQ5m0KeJ6SQ54kp5HlSCnmenEKep6SQ56kp5HlaCnmenkKeZ6SQ55kp5HlWCnmenUKe56SQ57kp5HleCnnOpZDnMIU851PIc1sKeW5PIc8dKeS5M4U8z08hz10p5Lk7hTwvSCHPC1PI86IU8rw4hTwvSSHPS1PIcyGFPC9LIc/LU8jzdinkefsU8rxDCnneMYU875RCnndOIc+7pJDnXVPI824p5Hn3FPK8Rwp53jOFPO+VQp73TiHP+6SQ531TyPN+KeR5/xTyfEAKeT4whTwflEKeD04hz4ekkOdDU8jzYSnk+fAU8nxECnk+MoU8H5VCno9OIc8rUsjzyhTy3JNCnlelkOfeFPK8OoU8H5NCno9NIc9rUsjzcSnk+fgU8nxCCnk+MYU8n5RCnk9OIc+npJDnd6SQ57Up5PnUFPJ8Wgp5Pj2FPJ+RQp7fmUKe35VCns9MIc9npZDns1PI87tTyPN7EsLz0Y3ueD4nheX83hTyfG5CeG50yPN5CeH5ogZ3PJ+fEJ5/O8wdz+9LYXt+fwp5viCFPF+YQp4/kEKeP5hCnj+UQp4vSiHPF6eQ5w+nkOdLUsjzR1LI80dTyPPHUsjzpSnk+bIU8nx5Cnn+eAp5viIhPH/E4XzYlSks56tSyPMnUsjzJ1PI89Up5PmaFPJ8bQp5vi6FPH8qhTx/OoU8fyaFPF+fQp5vSCHPN6aQ58+mkOfPpZDnzydlT5zDOYMvJITnFQ73AX4xITzPc1i3b0phe745hTx/KYU8fzkhPE91yPP/JYTnIx3q7a+ksG5/NYU835JCnr+WQp5vTSHPX08hz99IIc/fTCHPt6WQ59tTyPO3UsjzHSnk+c4U8vztFPL8nRTy/N0U8nxXCnn+Xgp5/n4Keb47hTzfk0Kef5BCnn+YQp5/lEKe700hz/elkOcfp5Dnn6SQ5/tTyPNPU8jzAynk+cEU8vyzFPL88xTy/IsU8vxQCnl+OIU8P5JCnh9NIc+PpZDnx1PI8xMp5PnJFPL8VAp5fjqFPP8yhTw/k0Kef5VCnp9NIc+/TiHPv0khz79NIc+/SyHPz6WQ59+nkOfnU8jzH1LI8x9TyPOfUsjzn1PI8wsp5PkvKeT5rynk+W8p5PnvKeT5Hynk+Z8p5PlfKeT53ynk+cUU8vyfFPL8Ugp5/m8KeX45hTz/L4U8v5JCnl9NIc+vpZDn11PI8xsp5PnNFPL8Vgp5DprSx3MmhTw3pJDnYSnkuTGFPA9PIc9NKeR5RAp5HplCnkelkOfRCeG5ySHPzQnheYRDnsckhOeRDnluSQjPoxzy3JoQnkc75HlsQnhudsjzuITwPMYhzxskhOcWhzxvmBCeWx3yvFFCeB7rkOeNE8LzOIc8b5IQnjdwyPOmCeF5Q4c8b5YQnjdyyPPmCeF5Y4c8b5EQnjdxyPOWCeF5U4c8b5UQnjdzyPPWCeF5c4c8b5MQnrdwyPO2CeF5S4c8j08Iz1s55DmbEJ63dsjzhITwvI1DnicmhOdtHfI8KSE8j3fI8+SE8Jx1yPOUhPA8wSHPUxPC80SHPE9LCM+THPI8PSE8T3bI84yE8DzFIc8zHfKcUWk0mrRmA/8ZI4Nh5v/DFen1ZL2+qtcb9fqbXo/S6zN6vULP3+v5bD2/q+c79fyfng/T80N6vkTPH+jxtB5f6vGWHn9oe1zbp9pe0/aL7s91/5ZVpPWf1ge6fej6ouU3VdE0RdMVzVA0U9EswPyTTL+7UgHuUbRKUa+i1YqOUXSsojWKjlN0vKITFJ2o6CRFJys6RdE7FK1VdKqi0xSdrugMRe9U9C5FZyo6S9HZit6t6D2KzlH0XkXnKjpP0fmK3qfo/YouUHShog8o+qCiDym6SNHFij6s6BJFH1H0UUUfU3SpossUXa7o44quUHSloqsUfULRJxVdregaRdcquk7RpxR9WtFnFF2v6AZFNyr6rKLPKfq8oi8o+qKimxTdrOhLir6s6P8UfUXRVxXdouhrim5V9HVF31D0TUW3Kbpd0bcU3aHoTkXfVvQdRd9VdJei7yn6vqK7Fd2j6AeKfqjoR4ruVXSfoh8r+omi+xX9VNEDih5U9DNFP1f0C0UPKXpY0SOKHlX0mKLHFT2h6ElFTyl6WtEvFT2j6FeKnlX0a0W/UfRbRb9T9Jyi3yt6XtEfFP1R0Z8U/VnRC4r+ouiviv6m6O+K/qHon4r+pejfil5U9B9FLyn6r6KXFf1P0SuKXlX0mqLXFb2h6E1FbzX2N5KMogZFwxQ1KhquqEnRCEUjFY1SNFpRs6IxiloUtSoaq2icog0UbahoI0UbK9pE0aaKNlO0uaItFG2paCtFWyvaRtG2isYryiqaoGiiokmKJiuaomiqommKpiuaoWimolmKZiuao2iuonmKcopCRXlFbYraFXUo6lQ0X1GXom5FCxQtVLRI0WJFSxQt1fuxFS1TtFzRdoq2V7SDoh0V7aRoZ0W7KNpV0W6Kdle0h6I9Fe2laG9F+yjaV9F+ivZXdICiAxUdpOhgRYcoOlTRYYoOV3SEoiMVHaXoaEUrFK1U1KNolaJeRasVHaPoWEVrFB2n6HhFJyg6UdFJik5WdIqidyhaq+hURacpOl3RGYreqehdis5UdJaisxW9W9F7FJ2j6L2KzlV0nqLzFb1P0fsVXaDoQkUfUPRBRR9SdJGiixV9WNElij6i6KOKPqboUkWXKbpc0ccVXaHoSkVXKfqEok8qulrRNYquVXSdok8p+rSizyi6XtENim5U9FlFn1P0eUVfUPRFRTcpulnRlxTp78vr763r74/r73Hr71Pr7zXr7xfr7/nq79vq773q75/q74Hq72Pq70Xq7yfq7wnq7+vp783p76/p75Hp73Pp71Xp7zfp7xnp7/vo793o77/o76Ho74Po72Xo70fo7yno7wvo+/b1/fP6PnZ9P7m+r1vfX63vc9b3G+v7fvX9t/o+WH0/qr4vVN+fqe+T1Pcr6vsG9f17+j46fT+bvq9M39+l77PS9zvp+470/T/6Phx9P4y+L0XfH6Lv09D3S+j7FvT9A/o8vj6frs9r6/PL+jyvPt+qz3vq84/6PKA+H6fPi+nzU/o8kT5fo8+b6PMX+jyC7iD1fnW9f1vvZ9b7e/V+V73/U++H1PsD9X45vX9M76fS+4v0fhu9/0Tvx9D7E/R6vV6/1uu5en1Tr/fp9S+9HqTXR/R6gZ4/1/PJen5Vzzfq+Tc9H6XnZ/R8hR6/6/GsHt/p8Y62/7U9rO1DbS9p+2HLhoF+cyPoQ7c27orTTus98ZTTsqednF2xalX2nWtOOzZ78hm9a1efcPI7A9M/02+Gcfc8/YQT1qxe07s2u+rk3lOzJ518WvbEFaf1HJs9Y8UJp/dm15ykkzmp99RTdeRvQgITjbv32pPPWHPSMdmT1iW05qSeE04/dc3JJ2VXr1hzQu8qHeuwzMCbWxm3Z8UJJ/RhPfXU3rWnHXXiincdtXLNaUeduuasXv3vIyp/ZXXlrxxb+SvHV/7KiZW/ckblr7yr8lfOqfyVcyt/5f2Vv3Jh5a98tPJXLq38lY9X/sqVlb/y6cpfub7yV75Q+Ss3Vf7K1yt/5ZuVv3JX5a98v/JXflD5Kz+q/JWfVf7KLyp/5fHKX3my8leeqfyVZyt/5Y+Vv/Lnyl/5a+Wv/L3yV16u/JVXKn/lrcpfyTRU/EoLvDLVuHufvvKENT3ZVStOW5E99QRlcGjL46RpZHiAvdFa09tja3p70rCBt6fQ28bWOaU/FTKRhpo7U4ZVLKlp8Eq5Bl1PFe9s2VjZO7qajDfxdh94tW8ySP+WrV274kwlhFW978qefPpp2ZNXZ1eefPpJq07FF/et9sVDqn3x6Gpf/GNQvXz+Um2m/6r2xbGZ6tFma3h3cqZKwDMrfXFv88KUoMoXZ1f7Ylu1Ly6o9sXtq31xyyqKkt7dttoSmVzti8urQHugeWfPgVfXjWfh3VNPX3na2hU9p0UnsD8kQIPoXex46ZWDggoZpRePqDyvo6vNa21QuVAPNu8uLh8nvVKoFCe9uEcNOPepHOf+1eJcVQXOlebdveHdiiopJXBg+YzSKxX3lPTiUZXntbLavE4LKhfqmsor6ZpqK+maGirpmsor6ZpqK+maGirp2lor6drKK+naaivp2sor6dpqK+naGirpmbUK9czKhXpmtUI9s3KhnlmtUM+sQajnVd7yz6u25Z9XQ8s/r/KWf161Lf+8Glr+xbVW0osrr6QXV1tJL668kl5cbSW9uIZKelnllfSyaivpZTVU0ssqr6SXVVtJL6uhkl5TayW9pvJKek21lfSayivpNdVW0mtqqKQ31CrUGyoX6g3VCvWGyoV6Q7VCvaEGoX7FvFv1kPQrlvZVglF6peIhKb1YwZCUXjm62ryqGZLeUrk6vaVadXpLDer0lsrV6S3VqtNbalCnd9ba8u+svOXfWW3Lv7Pyln9ntS3/zhpa/t2VV9K7q62kd9dQSe+uvJLeXW0lvbuGSnp/rZX0/sor6f3VVtL7K6+k91dbSe+voZI+VKtQH6pcqA9VK9SHKhfqQ9UK9aEahPpU5S3/qWpb/lM1tPynKm/5T1Xb8p+qoeU/V2slfa7ySvpctZX0ucor6XPVVtLnaqikL1ReSV+otpK+UEMlfaHySvpCtZX0hRoq6Yu1VtIXK6+kL1ZbSV+svJK+WG0lfbGGSvpqrUJ9tXKhvlqtUF+tXKivVivUV2sQ6glmQ0g168H07rRMhYDpxcNqyPTYajNdW+2LPxpZPdrsqOrfXTCqSsA7VPvi3tW+eGS1L55Q7YtnVfviR6t98YoaivK6ajO9sYZMv1Rtpl+rIdPvVJvpPTVk+nIN7zaOrhJwa7UvbjOuerSzx1WZaVsNmZ5bbaYfrCHTy6vN9JM1ZLrJRtW/u3cN776vhnfvreHdURtX/27rxlUW0CbVvrh1tS9OqfbFWdW+mK/2xe5qXzy2hqK8odpMb6r2xVurffFb1b54T7Uv/qTaFx+p9sWnq33xX9W++Fq1Lw7fpMoXx1b74tbVvjgLXixjpz2+Glab5zHwYqWN8rRqMz272hefqAHty9Vm2rBplS/uvmn1aK+q4d3PVgv4K9W++HwNaP9dbaavV/ti22bVo126WZWZ7ljti3tX++KBNbDZtWX17y7askrAy6t98ega0J5Rw7tnVQv43Gpf/FQNaL9Rw7vfqhbwXdW++EwNaP9dw7v/rRbw69W+uOVW1aPN1fBu+1ZVAl5Q7YsH14D2pBreXVst4HdV++KVNaD9fA3v3lwt4FuqffFnNaB9ttpMf1/tiw1bV492wxre3XTrKgFvXe2LC2pAu2sN7+5ZLeD9q31xbQ1oz6/h3QurBfzhal+8uQa0d1ab6ferffHZGtD+p4Z3/1ct4DerbqTbVI92ZQ3vnrxNlYDPqPbFc6t98VJ4ccJQNk88/YTT1pxywpnRvF5Rbc631iDg26rN9JEaMn2i2kxfqSHT0dtW/27rtlUC3rjaF/M1oH13De9+qFrAH6v2xaurffH6al+8FV6sqqXeVm3Oj9RQMk9Um+l/asj0f9Vmusn46jPdYnyVmS6sIdPda3h372oBH1jti6fVgPauGt79abWAH672xWeqffG5al98GV6sSj28Vm3Om2eDqktm62yVmXbXkOniajM9tIZMj6w203NryPTSGt69olrA11T74h01oH2rhnfHTKgS8BbwYoULg9tWm+eUal/shherUhCLq8350AnVl82R1WZ6dg2ZvrfaTK+vIdNba3j3tmoBf6faF5+uAe0/a3j3P9UCfrXaFzefWD3a42p496KJVQL+YQ2ZNk+q/t3NJ1UJeOcaMt2/2kyPrvbF1TWg3XZylZlOmVx9pu3VZrqghkz/Au9W1dv8o1rUY6ZUj3rclCoznVNDpmG1me5ZQ6b7VpvpyTVkemq1mX6shkw/Xm2mt9WQ6X01vPvTagE/VO2L/6gB7fCp1b87amqVgMdW++KcGtBuV8O7O1ULeI9qXzy+BrTn1fDuBdUCvrjaF2+qAe0/anj39WoBD5tW5Yst1b64LbxYVW88sdqcl06rXsDbVZvp0TVkuqraTC+sIdOranj3mmoBX1/ti9+rAW1mevXvtk6vEvAm1b44A16sqt3MqTbnXWuQ057VZnpKDZmeV8O7F1QL+OJqX7ypBrQv1vDu8hnVv7vnjCqZPaDaFw+v9sXV1b54Qg3ymTRz4N2qGuu0mVWi3n5m9ah3rjbT3hoyXVNtphfWkOlF1Wb65Roy/W4N795dLeD7qn3x+RrQvlbDu29VC3j4rCpfnDSrerS9Nby7tlrAZ1b74iXwYlVq6dJqc/5KDXK6tdpMH60h0+drePfP1QL+R7UvtsyuHu1eNbx7+OwqAfdU++I74cWqqvDZ1eb8iRrkdG21md5VQ6Y/r+HdR6oF/FS1L75cA9qWOdW/u8GcKgFvVu2LHTWg3a2Gd/eqFvAB1b54ag1oP1TDu5dUC/jyal/8Wg1o76vh3Z9WC/ihal/8Rw1oh8+t/t1Rc6sEPLbaF+dUirbZRNot0+/ClVt9Nw0WzHOull9XuKIJEoeP/g34KWPjZhU1Y1wTrsMMr0HGhI0AKfW9w/Lpe8eEDYOwRhPWCGHDTdhwyHakc3nkOnWao1ynmwvbRxo+3Kaby+nqMSYYkE0B8hkFsmqhsnGXd4h5ZwxRPhTeCM+bQ1yKR/JoMs+EXf9/NDxHvTeSvdcKcUZb+C8EbvlvZngQv/4Nh+cNgoE2sDlgG+EcW9jVHAy0lQDkFzC89BsBeJqc48mFuizovMgxvaet+3b6Hr0nruxde+qxa045qP8DohkASwxszhjIBIOZeRPioBLD52GWsCy8PxLiFAK3laQJ8iyAn/IbCbgc5p1HpRyA7AKGh8tLRLnmcm2DOo4y8GDf476R5EIhPnPYibzpMF0tq9FMVg1MVq0QBzuA0QLyywRDDRPyU34ec30wazxcxzVDvGExwUhh2OFItME+QxLy0D/dnyyGMAGd0pYB+ZNB1sh4boQ4m2UG4i4zYS3wfzSMbWXp3lgtXpajACOWIblSfegIhmeERRbSutxdumEX6pjhETJuhDh0Szxc5rnuZ9NXOFDSvxaQFRrGAvWnDQ3jYrxRnP1K8MaN7AYLb8RTsyxvfTbDGCGZtTCZEX4cTFGcQ0vIrCVCZth++WBFiLe8TrdVSGZjmcwIfyvIjOKsKCGzsREyGwNyIllR3AaI18LeHQFx9O9N80zxsP+RHAOg7iReA8ZrwLDKlFnYXukYoBXwjHWOp789C9TNvn6D6pnrMcAGTFYNTFatEGccyG8DAfllIF9Km/yUn8fsMXvMHrPH7DF7zB6zx+wxe8wes8dcO2bt5/MMzRBvREwwUthYwGibn78XwiQ2Ytg2TBAOnJukOM9C3PvNcwv8fwTwY1vbkFhMLzY/3wQYcV2KXIl11AzkRWmPKiIfXNOgeoHzt1hHyB0HfFEY1a8xELaheR4FYTinRWGEoRXCqB5g/jSPPg7CSMYbQBjxiflXUk8IYyGoTz2h/KLqiQCedhueRoYH9UkTi0PvNkKcPxnXNqcrM2fYv3ZD+fH1jbGAkeL8tQjGDAsvBPa1m1aWhhBv7dgHcv2IvFGcfzNc+JPpc/o300nMBWveNwQedbqjLLxTnJdBTq+YZ2zf2M+MzAz9P/0yzF+A5w1Alhu757lvPnkTwFmAfDDvTQGro7xDzJv2dFE+FN4IzyMyA3E3ZfIiWRN23WboQ4CInb83kr3XCnE2svBfCNzyvzHDszHDrMvkdXgeCRuCxwlh2ihCRo0go43gmfAIrB1abQvCgZtPo/oMtOnW6VAjQ5vOQnsa7YW42tNol3Ce0Z5O8p6SeuHh8sN9FcVsEYozoUi9ktkA3m+L8PEM1lvCSHGmFMGIaRFOmy1C/I6B/wlssG7DtsBtkRbgjeLMKiF/iT0IQryHuB+BbJERFt4pTg72keXB1qAyagA5LrP8n37FbBHU9QK6L4f2F5X3Bpa8NwKsjvIeZPuRLUL5oE1IzwWwRXh/SbIm7Lq8qE4idv7eGPYe9rPjLPwXArf887mvDRhmXSYduF8RbBGBwy2hbWyEe6FIRhTHthcW5wbo/9jXSc2H8P145B8BGPmetVJ7VnfNDP6fU9xd+dXSh8G2BD5dHgbrm5MxYU0Axbnd0JWbL7N/Ot8lZD/nbPsKKR/cB0r61bVOxcNb2J9jH0bPW0BcbgNTu8G9eHjoK+o9vocSbedmC/+FwC3/3J7i+xOHB4Pte2oXcwCbex2VXxXHA2J0huuY3tP2Pn3lCWt6tl9x2or91/b2FjkbNodhzwRDz4ZRHNRp+JzCs2E5qXqF4yrSN4Qfzz9QHLptMmo8wvs6Knecv0ZZkSt1Xsz9WLRfZvwsAOG3nQWYU0JmUWcBcPxAshI+C5CXsQ37ZcbHvbjmQzKjOO0lZBY17sW5Cdu4V8DuFRpT9suMj6f5GQAcTy8sIbPWCJlhmry/awiGHhIvmHBuG9B+eZ6Gji807hZaW+iXPV8z4mcJcM1oB+NWumbUAm591oz6zxiMs2AMGMaA8avxbOgcT74L15DLwbMh4JGY05Xhs78Pp7G56zMGfF1iLJNVK8TBdRKBNapBczOUNvkpP4/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg95oLH7DF7zFVhxj23eFaW4o2LCUYKw3O6/LypXjd/GfAK7Lvowr38xc4xUJwNYI/1axBvLJNvczCw1wJlLnVeht/DyT80gPcj4t5KqXNq/I7LFot86HmYRWZ4ToZ4wD3Z/OwB1nHcV05tEtvCxiATCmuw4ENc5PJzSLhXE+sy7RXcEMJoj9dGEMbPONLZ9KTWJwE8HTY8tvNgJF9+Hgz3nFGcrTKDZYk/mX2d/fuM+PltwtYAGCnO+CIYMS3CadvjRfxuIMtbF+p9rkeRN4ozpYT8NxTAKMP74HO5dB6sxcI7xZkJfchs84ztG/ujhZb/0y/D/AV43hBkuYl7nvv2IeE56ALkg3lvBlgd5R1i3rSnnPKh8EZ4XpAZiEvxSB4ka8Kuy410MWLn7zWz91ohzsYW/guBW/43YXg2YZh1mcyDekb1SGofnc1WRr1LMqI4eGZB6owmv5ee23Vo+/E+A/fDU5ztiugstLvRXuD9uIxuG3wmldK2jVXW2bGAkfOMdvfpgDtwjbsr11bsXFsl59fwDh9+fg3P7mQgueGu+cnlpc5u9KU70nm6uRBtVfoV61eIN12PNgEZ65conSzIWGAPftEPq9n0iuu+p5IPq20Jccv5sBra14GRr+1bNuWk1xrE74NreFZcyhbjumokyFIu77zQ90j605U4w43nrulXrO3jfUu67Q+DlyidLMhY4NxmzjZf08rw4byG67Y/FtLNBEPn2tBemAdx+ZkQPA+vf3geh+I2BEN1y8gy00N7pMUil0LgVi6tDA8/36LLahLgkDqzGaWD8ByihP5Du4R+xdpSiwWPw7qaw3sWMC+Js9TV3lXSGgw+M84xZt1hHPTNMTxnt1g03/yQM/5ZCw48Z78DxF0GsqH+Cuckbd+U4/FoPtGmR1CXFZzwO1gXkI4cC3wQvxRnV+D3JMDmvizC1VgWGZM2lkEQDB0TZgN7eVGcvYxrGxM2WHgvBINtN+rDsE8jGeDdxwUnMhh8b0sjw7IBhFOcA4rwh2lxPkZY0jq4zLSCYLA9izLk6wjFMDRAnA0BD76DPFOcI1keHOeGEfmNsqS1osy0gmBwP44807sbwntob2AfYruLyHX9QRw492m7h/NY42pZnWjBPzwCP/ZfeCZVQmdhPzTWgldeNw1dM8sGQ/VOMd1kW6s8lckUf82Wd7E/PAb4pV8hkJn3yViwUdsNIuZ4MmyOB+d9qN5sYIk3EvguBG7HaE1C6Urcl1HpHTOoi/m8D6WTBRkLfMc2h/Y96d7RDJ/OG+dnHOU9aGxBeg/XmfUPv5uJ8z5R91cQdrzzA+8EtN39XU56qM9GWeRSCNzKJeo+NZyjq8e8T9R3aLHtS6yXD9JX5lfOPAricXlHQGsw9JuiQm0yrPTObNv3phFjHOa5mi14HJZPaLtfUKh95nCciO1xjqjMwz5djXcdF4Kh+2kaIU4XxA3NM+5faIAwbM+UHj2jjdDE3i31vQmKT2PmUex9W/8zDHihdKXXHRoZFrT9KM4S45a6U4nz0WRJa1mZaQXB4P4I558IK/ZvvP98k8XFNtta5D1MV/9GsXdQH+J8E86FkCvwXZucbX50GMOK5dnE4uC8A8XZ07ilvsvN58ht8xzF6hPF2bdEflFz8k2WtErNKfB1bKpPOFfO98o0BEPvjixWn4q9h3npHx8bYt+FmFpZPjheddZ/hLkcYkL8iM92H1q97tHk9bZY3UadRnF6jRs1bi3Wn70H+A1c87se9ysQn+Tyed5G+P87IR7WRffj01BoX0KYk7TVK/nmOvFmG/dSOjjnVu97grHvisM9wdtA3HLuCebrllq+XF/TuLdUenG8P1h2323x77s1iObd30ZHC6UrMVdR6R5anIvn+x1se/EF7m/MFVvfwPYhvVZEbZ9/XxPXd/IQl+9N5/YaruVQXLRlcD24nPRaA/v3KKT2ukbttcT9/VMBh9R+hygdhPsdpNb8K9nv0GrBI7XfAfOS+Bad5r0lKJ93rKMt8MwxZt1hzOH8Ph+byeU7eKxL+x04Dlz/3wnibm+eo/Y72M4HngXv2HRHvfeB2fYI7A54TwFsAuW+mu+/yAZD9xYgXlpHtJURxdnHuFF7HDjvhWCwvUb1DvMkGeBacsGNDAZ9L6eRYcF9ABTnoCL8YVqcj5GWtA4tM60gGGzD4l49wrpBGRhwbhLPIOE7yDPFOZrly3FuFJHfaEtaPWWmFQSD+27kmX/PiO9TwX7D9t1N1/UHcWQgn3EW/o8zrpbVyRb8wyPwY5+FdUpCZ2HfM86Ctw66acg+0WwwVO8U002oWynO6Ywn/DVb3uV94Lq5mcCtfUB91TDI9yzAxdcNovbuYV2nX8EV1hLzWQ2Y8ciBvG3zXCI2blf//ezu92v0pztcIF1cd7Lt1cS+T4Iv3Z8MOtdextziaHjnlBU9xy9be8zpJ/aedNqpaNQScAx7M7B/uKchGFrBMV7B+Hla2GDxMAsafPqnGwYOrjDdgnnO1fLryg364Bo/INWHnYRo3CzxTZuQWPi6j6WB8HX4ug+mQXi5E8mDjGIIW7cAB2HrFmIgbN2BP5iY3hqydV5Bu3KdQg2vW2ijVN+AhuoY/wAQbtbFhTxHeQ86zESGCN8U1AjPW0FcPilI9Qk/NIQL3lHv8cOhrRBH9IN+JTb14OYC3MxLHxsU3vjSXe3GFylZ6fTpI329J73j9N7Te/s/1Lbj6Sf1nLbm5JO2W3HCCRkAynff4P+4YuYFrn+o0HEmqBGecYchvjvCEvamcbMRfsSHSg53cvAKbes8onZ8CFtaHdihoIyC4G1tabW9TS2tNm5pNVosrca3g6XVMbf/WaRhdK/Kp9XSejqAd1jl6XuH+IOwkUyB6LBRxBeEjWby7Fv6grwpbAwoFQprYT2oDms1YbhtcSzwR+44E4ZbtDYwYdhYNjRhuFy7kQkbdFWXCcPpEToyVghcKb+wQ6e7m+t0c+19S5l7OE+33yrd06RFVinlsxvIai/z7Noq3RPSzUA+FN4IzzMhLsUjeVCnS9h1HaHp8r2KvLcre68V4uxu4b8QuOV/D4ZnD4ZZl8l4wOG+znb4Olv+r+I62wVxed2jad+3Y53FbeHu62y3r7Pl/yqusztCXF736Hqwt2OdXQg43NfZVUJ1Nu/rrPrtD3F53aOr7N6OdXYXwOG+zq4WqrNtvs6q30qIy+sezcC9HevsQYDDeZ3tzgvV2bDL19mBpX1b3aNVg7djne0FHO7rbNsqoTrr9az6nQNxed2jYwZvxzpL13bo+a89zCSc6FxCd3uvTD3uX+1Nez2+BOLy+pg1z2/Heny+edb1eH9TjydC2AEmbBLgdV+3Ozr9nEPZv4rr9nUQl9fRyeb57Vi3LwMc7utsd6e3K8pnqtI6+yWIy+se7Sp7O9bZzwAO93V2hVCdzfX4OhsEd0BcXvemm+e3Y539innW9sKtxl6YCWFfN2GzIOwbJmw2hH3ThM2BsNtM2FwIu92EzYOwb5mwHITdYcJCCLvThOUh7NsmrA3CvmPC2iHsuyasA8LuMmGdEPY9EzYfwr5vwrog7G4T1g1h95iwBRD2AxO2EMJ+aMIWQdiPTNhiCLvXhC2BsPtM2FII+7EJK0DYT0zYMgi734Qth7CfmrDtIOwBE7Y9hD1ownaAsJ+ZsB0h7OcmbCcI+4UJ2xnCHjJhNE+LOwsfMJtpRgYCVyeFPT19ezqCwb8M8xfgmTAI7XTs21m47qjPihNO2HvtmjNWnNZL+wpxXx7BJhEV21NIceKyp1Bqn5pOO+qGPNzD6POuf94Cp7LzuC2MfsWaL57Udn9DS+UntZtk8Qw6qS19GqZYPcAb2wQODuRxy2A5cscv1zjvVqq4+Qa7lQYBPEJ8Dro9xOWtmlpWLUxWI5is8JQl3tDTIiC/DORLaZMfbxngBziag8E3MMYBI4U1AB6JNlBMH2AZ4vZnLrPhMZMZ4jcW6jq9qrGOAXNVQp/r5PG2/4IFB3559eU5A9jGZQb4QsycH9tBq0LgVuaUV8B4wC9yoY6mMHrGflzCDEf7mmOk/LDuNEXwgTftFfsKLvbTKANMJwii9YnUbdNRbQNvFcPt7IRHyr6gOkHTQ9gWKG/pfs41T/y2OS5jvPFtepE6ZOszUacG5v/8SwQjg0DgVsHi5TWyjnkHRfIW0G951KUB8B8wPPQTvjU+X+kUh7QtJcRnXxttNWm5tkXHMlmNYrJqDQbfPEXyk7gRKxNE30SGN3skDTPe9It6y3b75vrEaPuKmlTfEKXDsAxtRwvxtt44yWzQTbzwTFj3kLWf8yhT6m8bmPzQfr4D7Od9StjPo1hYPW1T8uNXTogvmz2J9rOAvZS3jf24LYJ1pymCD7wZ//Ay7WeUAV4EQHnb9InU2DKqbbSAy/WypE1EdYLsMZwDIFeqbxaQcV8947dNcRnjDYhrStjPeGNWIRh6szuOd/AWZewL9C8b2G9YpaPlPI1sIGtvCej+Ptnz23IJv+1mw1NLyD7qK7vYVkheeCMfv9Wa6jnXJSR7iod3cUjOdUS1OduXiaTyDorkLdBHVTzmsH3FwRmesKfvAplKvko0FvBIfMVZqE326Vk65u16DFTq65mtEAfvd9lQQH628Q358ZZTj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9ZnqnYJ5ztf08Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg95rchZo1nlHkmrM0Qb1RMMFLYOMAzVghPA8NDfizD4ea5ySKz4TGTWQNgHGGexwDW20cO4B3jGm/Y063xtkB+BQuORohz9pyBuN822FoYZuJnNAsbCWkXArcyp7wobfJTfi0GUwD/a4HnYYCxyTVGI+cRERgpP6zfTRF8NEKce438xwVDf63AE8qAnkl3NEN6qE/WV/vFMmkAPKOE8FCdyJh0m5ksUJ+MAZnR/7FuNwhhpLwo7VFMPthPNAOeZiE8UW3N5y2go3O5fDPkQb8M8xfgeQzgkWg3zZBHOXhGyeLJtQIezEuqPUbVA9RXAvozj7q6HLmPBTwbuMfTiXZVOXjQph7nHk8oxGcObcU3HaarZbURk9VYJqtWiLMhyG8jAfllIF9Km/yUn8fsMXvM6xezxsPt5maI1xATjBSG8wIC+rlon4xlSDbUCIvMmmMmM7QtaeyNY44NRw3gFbCpOlGmNC/AcTRCnMUwL7CpidASDLWRcZ4DZe58zG1kzsfc5Kf8WoAf2zgZbWkBm65Pzk0RGCk/HWcc4Lbx0QhxJhiGbPMCyBvOPdl0h9T8WFQ72BAwEna0GaXH1zQHMMoiC6m8xzFZjPN5r8tboK+oeAwlvQ6Aba8cPBsK4ylWNsK2T984a2P36fbp2E1MWtSXEX7KrxHiLCyiPzEtwkn6lNJsAVltAjLbxD1vg8qL9Ne49ZB3UCRvgTLtG+tv6j7dvrqymUmL6grhp/waIc6OJerKZkw+VFcozRaQ1WYgs80EZFasrtQz76BI3gJlmtfpbu4+3b66soVJi+oK4af8GiHOPiXqyhZMPlRXKM0WkNUWILMt3PNWtK5Qfg3AJ+HKmvAtmBzeNOEcf7ZOPAQRPAjVjTad7pbu0+2rc1uZtKjOEX7KrxHiHFWizm3F5EN1jtJsAVltBTLbyj1vResc5dcAfG4BcRsgDv2f6hzHn6kTD0EED0J1o12nu7X7dPvq3DYmLapzhJ/ya4Q4J5aoc9sw+VCdozRbQFbbgMy2cc9b0TpH+TUAn1iHGiAO/Z/qHMefqRMPQQQPQnWjQ6e7rft0++rceJMW1TnCT/k1QpyzS9S58Uw+VOcozRaQFcXF+TjhtbSi9RDnMBvMs20OE8fO44UwRs3d2GSGY3peH7MmvIHFpfaDbY/iv13ngErt7xBZL2V7kqiNNbHyaIQ4HyvRxkrtb2oJhtZf23sUf2OIw+c/m1g6OP95ZRGcknPNUXWoqY55B0XylqpD1N75/kGsQxTnUyXqENcvtn18xNMGRd7j4+xic+gbAE6K89kSdUhqH2NUHRpRx7yDInlL1SHe1/M+BPv6L1fY1/O1QFwDGV/kPYpfrA7x/g/r0K0l6pCUHRFVh9BOIEwkh6wJ53Kn/pi3lWydeAgieJCsi2RfUl0cz2TSCHG+W6Iubsv4oLpIabYAT9sWeY/iF6uL41k6WBd/UAQn7p+jd4Xs+qL1E/MmXhzutwoxD122vO2+7eqzWe+qZH0J92pMEMIzrgI8EwBP1j2eUIjPvrWsiSYt13sGJzFZjWOyaoU4E0F+kwTkl4F8KW3yU35JxGwbxzZDvA1igpHCsoBHoD4X1WFYhvyMDcqsOWYywzMTtLeJ1nB1//Bn2GMlMF+b13i3hvwKgAPn8inOW7MH4v4N9lhtCXyQuykLk1qHzUBelDb5cY2T1hNwLYuecY+VwL6CPjlvHIER94Fye4rzgfbU/8q0p1AG9Ix7Dm37nKTOXkXNEePZK+K5Hns2qU6QHbi5RRYCNlFO6nxGJhh6lpLLGM9SDh89WNb4w7QIJ9Ufio9jB4rbEAzdv0xrFS0MC43teBq0ViFRD3W6o92nm8f+iWRP+Cm/RogztoTseV+3MZNdSzB0P2xDMLi961/WhHNdQrKneJtCfKF9EEXbHOUn1E/ksU8KAAP+CvC8MeBxX1/ac83B4D6hFJ7RgEfiTJ1Qu8gJjaX7xiFZJquNmaxaIQ6OsbMC8ssE0WcAspa8s4FbWUwoQxb1tNWjZEH5VYp5fAIxZxOI2cvZyzkKczaBmL2cvZyjMGcTiNnL2cs5CnM2gZi9nL2cozBnE4jZy9nLOQpzNoGYvZy9nKMwZxOI2cvZyzkKczaBmL2cvZyjMGcTiNnL2cs5CnM2gZi9nL2cozBnE4jZy7k+mL2cvZyjMGcTiNnL2cs5CnM2gZi9nL2cozBnE4jZy9nLOQpzNoGYvZyrw6zx8LMC+C2tTWOCkcLweyujhfBszvCQH8uQzrltaZFZc8xktjngorN9dA5Fn12Z2zyA1/3dhPm+/epbQn4FwIH3VlKcTeDcYd5gw3OHeNaQ35UqdKavT+b8TB/58R5e4gfP5fCzkc3wDtYViW/UZIKh35sgP57r4rzUQ46ZCDlK5h3VtjeSLYc8lnkA/AcMD/3wPKR7Pdd/HqmSexFGA54EndPL4fkp1+eR+P0945isWiEO9ltSd+VF9QnjLXlnA7eyyJYhi6wFT7bOsqD8KsU8KoGYvZy9nKMwezl7OUdh9nL2co7C7OXs5RyF2cvZyzkKs5ezl3MUZi9nL+cozF7OXs5RmL2cvZyjMHs5ezlHYfZy9nKOwuzl7OUchdnL2cs5CrOXs5dzFGYvZy/nKMxezl7OUZi9nL2cozB7OXs5R2H2cvZyjsLs5ezlHIU5DnLWePj5BDxbs1FMMFIYfqd9tBCeqHMnWIZ0jmRTi8yaYyYz/NaKwLdfcnjOidLXZ4kOGSOZb/85p00hv4IFRyPEmTVrIO4RBhueF8IzQuNYmNQ5jExQ3ne7bN+G4meamuEdrINS7WQsw82/x9Ri4aUecsxEyFEy7yidIayv8ljmAfAfMDz0Gw143J+L6T/nNLoCPNgHSn13SeD8Tw51u+tzThOYrEYzWdX7TDM/d0V+ys9j9pg9Zo/ZY/aYPWaP2WP2mD1mj9lj9pg9Zo/ZY/aYPWaP2WP2mD1mj7ngMXvMHrPH7DF7zIHHnKvt5zF7zB6zx+wxe8wes8fsMXvMHrPHnEjMGg8/R9AM8cbGBCOF1eM7E1HnQ7AM6bzHRhaZ1eP7SJXIDL+1IvDtl1zUd5fe1yKZb9i3d38jyK9gwdEIcb42fSDuBww2PNeDZ3ls598kzktkguizZZQfnuvBsz787FEzvIN1UKqdjGK4yT8eMHJe6iHHTIQcJfOO0hnC+iqPZR4A/wHDQ7/xgMe9bsrnUA+Wg2cC4Mk6x9N/HklAB/edR5po0nJ9HmkSk5VNt1OciSC/SQLys9k05J9kyTsbuJXF5DJkMdmCZ3KdZUH5VYp5YgIxezl7OUdh9nL2co7C7OXs5RyF2cvZyzkKs5ezl3MUZi9nL+cozF7OXs5RmL2cvZyjMHs5ezlHYfZyrg6zxsPXh5oh3qiYYKSwLOCZIIQnat0Py5DW8cZaZNYcM5nhXXcCd+8NWmem9PVa7txWyXz715nHQn4FC45GiHPftIG4eYMN12txjda2ryHrnIfiewYoP1yvxTVcvqbcDO/UY69DluEm/wTAyHmphxwzEXKUzLvUPbRC5ZDHMg+A/4Dhod8EwON+XbIth3qwHDzYB050jqd/nVlg/TWHut31OvMUJqsJTFatEGcyyG+KgPwywdB1b/JPseSdDdzKYmoZsphqwTO1zrKg/CrFPNljrgtmXzc85ijMvm54zFGYfd3wmKMw+7rhMUdh9nXDY47C7OuGxxyF2dcNjzkKs68bHnMUZl83POYozL5ueMxRmH3d8JijMPu64TFHYfZ1w2OOwuzrhscchdnXjeowazxZ80xYmyFeNiYYKWwi4JkkhCdq3xyWIe2DG2WRWXPMZIZ3gAjcSTJonyalr/dCbjF2IF/397D079PE/AqAg/JrhDhfmzoQdxuDrQXeyRoX95plQXYTnfNQfM8t5Yd7MidAWBbwkjuRhUm2k4kMN/knAUbOSz3kmImQo2TeUXcjCeurPJZ5APwHDA/9JgEe9/v6wi7Ug+XgwX5bYk+7DJ/9+zRJ17repzmNyWoSk1UrxJkK8psmIL9MMHTfKPkpP4+5PphHMvyO8u6rc9PLkMV0C57pdZbFdEve2cCtLGaUIYsZFjwz6iwLyi8NmKd6zB5zBOZpCcTs9UZ9MPs26DFHYfZ6w2OOwuzboMcchdnrjfRg1nj4vGYzxJsYE4z1PLc7geEhP5YhzT9nLTJrjpnMJgCeCe7xDLojndIfruhzsD6SdZ9ve4blVwiG3l3QCHGyEwfi3gTrIxSX6jrO8WL9l7qTJGqti/LD+yBw7QHxkjuZhUm2E35nD/mnAEbOSz3kmImQo2TeUWuqwvoqj2UeAP8Bw0M/XI9wP88b5lAPloMHbQ2JtWQZPvvXR6j/dr0+wm0IPk9ebxuCryOQv5jd4zF7zB6zx+wxe8wes8fsMXvMudp+ZWHGe2JxPobiTY4Jxnruu4maX8AypPmCiRaZ1WM+qxKZ4R4/gT2Hg+5ipPT1nNHYcQP5TnSebzjoW3k0n8X3eDZCnN9NGIi7kcEWNS9km5uU2rsdNTdJ+eG+WZwroucxgFFijiITDD3HYNs/R/qsKYKPRoizrZE/fjczsPCG83MzWJjmd6ZzfvvLhOtx8s8EjMTLDMAjfQ8z38tcj7k64pPSnl7HvCewvG18O9exYU+3zpvKmnQL1WPKrxHizClSnzEtwkk6B9s48TRTkjcjV46H86bjzDLPTSzOTOCf4rQX4V/3RWMsvEm13ai2gnkL6PK+ueWZjPdic7loy8x2j6ezORist0vhmQ14ZrnHEwrx2Te3PMek5XpueS6T1VQmq1aIMwfkN1dAfhnIl9ImP+WXRMyYdzZwW37zypDFPAueeXWWBeVXKeY5HnNdMMehbmg81L8Q1maINzMmGClsFuAR0PtF7UMsQ9tYfTY8x0lm9dh7Monlpe3bY2GsLjCvkscxFdnTfF6lEeLcnR2IewKM1Sku1XXkB+u/+/mG4nNDlJ/GSG0T954gXnInsjChMi96NncCYLTt4ZGWYyZCjpJ587mMqeuB7yCIrj/0jPM6zu1xM8YlvUNtkvKm/Bohznklxrhcz8208Mb1c934jdDFnF8dh+yTJhZnNsiE4nyoiEzWZ/tpAIzr9vOZcIqDY6aGYOjcaTZYv20Bx3XO8jb1nuw5qvezmUwaIc7HS9R7Pt6iem+r48XGadxustVFPnbCunh1mXMwtnFXIahP/aT8GoAXrG8NEIf+T/WTyzAbiNmWfXM5WD7EC/4K8IxzJ+7tyPYc2qzl4JkHeJy3ITOXI2Av983l5ExarudyQiYrmx1OcXIgv1BAfrbxJ/lDS97ZwK0s8mXIIm/Bk6+zLCi/SjHnEojZy9nLOQqzl7OXcxRmL2cv5yjMXs5ezlGYvZy9nKMwezl7OUdh9nL2co7C7OXs5RyF2cvZyzkKs5ezl3MUZi9nL+cozF7OXs5RmL2cvZyjMHs5ezlHYfZy9nKOwuzl7OUchdnL2cs5CrOXs5dzFGYvZy/nKMxezl7OUZjjIGc8S45nKine3JhgpLB6nD2OOteCZUhn/mZaZNYcM5nV4/6oGSwvfS7njg0G8nV/xqP/XqM5kF8BcNjOer17/EDc7xpsLcHQMzl4DwjW/3rd5UJ+yk9jpDNFeH8R4iV3BgsTKvOidyzZzs3OqKMcMxFylMybyofSnmXJW+p7sVgOxH/A8NAPdUHOOZ4wV+n3YrHfltDnMnz2n3Oi/tv1OSduQ0xisqq3DZFjeMift+SdDdzKoq0MWbRZ8LTVWRaUX6WYQ4/ZYw58ffaYfX3O1fbzcvaY64rZ1+f0YNZ4+Pi2GeLNiAlGCpsHeATGP0XnLbAMaR5irkVmzTGTmfDdtn1j4zksLz0XNXnDgXwF5gjaM8HQu5AJB+WHdyEv2HYg7nSDDe8XwzmmuSxMcl6W8qK0yU/5tQBfcyGMz4lFzdVKtZOoudocYOS81EOOmQg5SuZN5UNpz7HkLVAOeSzzAPgPGB76Ca8n9aAeLAcP2hoS99kI8ZlD3e56nqydyYrPS7VCnDaQX7uA/GzzduRvt+SdDdzKoqMMWXRY8HTUWRaUX6WY2zzmumD2dcNjjsLs64bHHIXZ143qMOM+DRwXU7x5McFYz/XGqHEeliGN22ZYZNYcM5nhHhKB+1pztv0qeuz+3g0H8hXY99CeCYbew8v3XOA9vJO3GYj7PphXoHdwTG6bx5K6xzNqjojywzkEHLPzOYRmeKcee8D4fajkzwNGzks95JiJkKNk3lF7kerJd1CEb4E6kMf6FoDsA4aHfjiH4H4MHM5HHVwOHrQZJOZ/hcb6OexXXM9pdDJZ8TmEVojTAfLrFJCfbY6F/JSfx+wxe8wes8fsMXvMHrPH7DF7zB6zx+wxe8xymDUePt/XDPHCmGCs5/6LqHk4LEOal51nkVlzzGSGe5AkzrDh/j1KX8/Nj9hoIF/3+8DC+RmWXyEYugetEeL8YeuBuM0GW9T8u20NSGpvadQaEOWH+/pwTp6exwBGiflY2z5rrtdwzbQpgo9GiLOpkf+4YOivFXhCGfB93M2QXj30FF8TJn8nYOTrd5LrBVH7L0OQo01P2daWpNY3o9aWcH2TwnB9U2LfaKXfchTex5rDOzOE1+crXuPB+jtfCE9HBXjmAx6J9i3EZ98aT5dJy/UaTzeTVQeTVSvE6QL5dQvILwP5Utrkp/ySiBn1E2FthnhhTDBSWCdg5Hsf+mwksMkE7Od8hucXDLWfGyHOrWCTbW+xyeLc1xM/9ejro+x93Fti60cF5JO3ySdk8sF62xTY+/5GiLNPCXtwLntXsl+qpJ/Efkmg/bejrikHTzfg6XKPJxTis6+fXGDSct1PLmSysulPirMA5LdQQH62PpD8lJ/H7DFHYUZ7hLA2Q7wwJhjrZMPl0M6h9LUtcSrYOQL9RDvO9XI7h/JrhDhngZ3zTrBzuE0TZVtK6PJitiXl1wI8YF8nZefw+fNOJosoO0dAPu02+YRMPtgeuJ2D9YDivL9MO0fYrqjYzkG7QkCvdKEOKwfPQsCzwD2eUIjPPjtnkUnLtZ2zmMnKppcpziKQ32IB+dn6VvJTfh6zx+wxe8xpwIx2O2FthnhhTDDWaawzyG6n9LVtfBvY7QJ2T5eWQxfkVwiGjh8aIc5ysNvvBLud2+hRYzAJ26TYGIzyawEe0HaTstu7GJ4uJosou11APl02+YRMPtgeuN2O9YDi3Fem3S5sJ1dst6OdLKBXulCHlYNnMeBZ5B5PKMRnn92+xKTl2m5fymRl08sUZwnIb6mA/Gx9K/kpP4/ZY/aYPeY0YEa7nbA2Q7wwJhjrNNYZZLdT+to2fgXsdon5QS2HBZBfIRg6fmiEOKPBbn8D7HZuo0eNwSRsk2JjMMqvBXhA203Kbl/A8Cxgsoiy2wXk02WTT8jkg+2B2+1YDyjO6I373VJ2u6ys+/fQYnspBEPrHeIeWwS3TSe0MT5wzzDa3AJ7mHNSYx2bzDifKLNNK5QZ7THCPcZ5i8wk1lGF2nSfzJYwmdnqGcXZpoTMlkTIDOsZyYriNkA8+l/WhNO+Jfr/myac4uG9lkL7btttMmpjuFBGUyuUEb8XDPeKoU0jxVvIeFto4Y3izC7BWxjBG5Y/8RTK8pYXsrHaM5AWyYzwLwWZUZy2EjIrRMgM75fGtk8yE+CtTae7TEhmy5nMCP8ykBnFWVBCZssjZLYUZFYwz8tBZhLnFrRN2GnBGDCM9MOzDPQenlNb7h5jxfvnUWbbCeFZXgGe7QCPQP0Mhfjss3W2N2m5ngfcgclqOZNVK8TZHuS3g4D8MpAvpU1+yi+JmPHeTsLaDPE6YoKRwpYBRv7NCa13D954AK/AmCyPczZ83E35NUKcx7caiHu4wdYCcfEMRRsLEzqfGtrOL5If72FcyOQr1b8UmwfoADz8zIGQfPI2+XQw+eC5jqbAbufiuY41Jcbdtn5S6txbNX25UL/UWWm/vQzwSH3XVIDPHNo9rvtJrj87mKxQfwrbPX1teRnDQ37Kz2P2mD3m9YvZdu9KM8TrjAlGCsPz4BL6WfPOx+vaZrsc7EkBW6MzA/Ln8waUH94T8SmwJ68Ce5L2F+F5V5u9JHVnR9T5UJzzoz1i9bjnJ+ocB8pCwL7KCcm4zybld7vY7E2Kc2OJ+SV+pw8fj+A5F7wvR+o+aYn5UdQxxea1Kc7NJWS2LEJmWMdJVhS3AeLR/7ImnK910tw/X8fV8YXGs502GXUwXCijr1coI9JLWK+IL7TlpXjjZ+/bLLxRnDtK8DYvgjcsf95fYfnT/7LB4DUhXv48DR1faj5DaD62E20ikj3hp/waIc4PSsie21ddTHZ4RwLOpQrw1oZzng7T7cT5Q5IZ4d8eZEZx7i8hsx0iZLYcZMbn2hogL/pf1oTzeUuqrzwNHV9IRu063R3dp9sn+51MWiR7wk/5NUKcR0vIfifwF4IB2VOaLSAviivEW4dOd2chme3CZEb4dwaZUZxflpDZLhEy2xFkRrKiuA0Qj/6XNeH87C7VV4o3H+ILnYsuuqcIz7SmNW+Bc8r5Su8IwTP5uwjIojkYfB6kFJ5dhPEUKxvMW0Bn9O1p29Wkxe1N1BkU598ldMaujA/az4j2JvG0K/C2q3veBsk1w+Raz7yDInlLleluJi1uZ2OZUpzXS5TpbowPKlO0s4mn3YC33dzzVrRM65l3UCRvqTLd3aTF7XcsU4rTtEm/G1WmuzM+qEzRfieedgfednfPW9EyrWfeQZG8pcp0D5MWH19gmVKccSXKdA/GB5Upji+Ipz2Atz3c81a0TCm/BuATy7YB4tD/yVbk+At14iGI4EGybuxp0uLjH6wbFGebEnVjT8YH1Q0c/xBPewJve7rnrWjdoPwa4JlwvWkw7QX+WjGtNj+d7t5VpLu6xE+nu0/teEMeEIAcGuCZ8irn/7a4e8M7O7N4bzL/iGCgjLBO0v9nF6mTQu2maJvdGfIWqNd9bZZ45+PvPS3yyZdos/swPqjN4viblxHWt0Lgbm5Br/11WfJaX/qhHnkHRfLe233efeNk1NPEf8Dw0G9vwLOvEJ69K8CzL+DZyz2eUIjPvjXC/UxarvcC7c9ktTeTVSvE2Q/kt7+A/DKQL6VNfsoviZg1Hmo3hLUZ4u0ZE4wUthfgEajPRXUYliG/SxRlNj9mMlsAGGk/Bu7TOGSTAbwC6xx9a9c7Qn4FwIFrQRTnaNgXcoTB1gJx51v4QZlLne/l59vJj+N+Gi/i2RZ6xrlZgbtx+uS8KAIj2gT8TkvOB95peWwROwvtGpQBPZPuwHJCfSJ1p35UOXUDRsK9FPBI2URUJ8geW26RhcD5sJyQjPPF9nnh/UoU5/QStjrfb0X1B9sQyQr3W0nUH8k9T3sxmfG54EaI8+4SMtsrQmZYx0lW2GdK3TUcVccpP+wzSY/jWlI99HfUPWaLAKNtXwH2N+Ruz8IkZbs9w709ky32O3gOS6AvL1rW9cw7KJK31DoslgPxHzA89MO+XmA8113pOizqAKm72QT4HLQH1fX4cm8mqy4mq1aIg2eZBOYvQptO5/OKHrPH7DF7zB5zPDFrPNw2a4Z428cEI4XhfXISc87F7DUsQ7Kh51tk1hwzmS0HXDRfhWfofwJzaQJj+m6UKV8nw/tsKM5EmEt7EObSkA9yF7EwoXmq0DZPRX6849o2v0bP+F1kgXmAbts8MB9j45iyKYIPvG/8yRJzaWMsMqBn25gZ9YnUvteoMfN8wEg845hHavyH940WgqHzyKhPsI7HabyO/QTOP0rdMRrV1nzecvc34Ry0/hUbmy8HPBLtptL7m+oxjxNVNsLzODkhXdnXX+DdPYVgqK5shDj/KzG/y+9soX4A5/xIVmj7Sp2JxjtaC8HQ86L1yDsokrdE/yc1d4djG6orhJ/ya4Q4wzbtd6PqCh8n8bMpLSAr3PcisQ9H923LLXlJjS+i6uVedcw7KJK3wH6yPI6PAuA/YHjoh3vO9nOPZ35zMHi/XSk8uO9FYg+HEJ853M/hei76ACarfZisWiHO/iC/AwTkl4F8KW3yU34es8fsMXvMlWLGuTTC2gzx9ooJRgrDfbkCfUpROwLLkO/jQpnheDYOMsN5RJqbxO/yLdl0AK/A/OJ8lCmfI8V5OYrz+y0H4i432HBeaynw083CJOeRor4DiGNA4gf3/fCza0Ljo/m2+UHKm/LD8UlTBB841tmjyFgHxxYoA74uhHvvhW3x0Db+Iv8+gJF4rseYKOr8B6658Ll1HFNg3Y7Dmgt+r3R9fXMzzXlL3NXUHAxeX9G/YmNG6bVKXP8qB4/w/EKuNbDPJ0i1x6h6gPpKai6jknNSwnMZeT+XUdvPj6PqZ29zOwPHBHvHBGM9x1FROgzLkK+joMwWxExmeLaMxi94huBDMI6SOufBzyzsyLDhmYXPwzjqEhhH8bEX7mFAma/PPQy2sRU/HyDVB2aCoXf88vPieOavKYKPRojziRLjqEUWGdCz7Rwo6hOp9ht1pnE/wEg8oz6RtoloHGWziaTPVDtMN4/nk4dHyLgR4nyuxLojP+tM9YfSbAFZUdyGYGgflTXh/Fw03VvD09DxpeqhkO7vk/2BJi2SPdf9jRDnqyVkfyD4C8GA7LGtkLwobgPEQ1nqcK5LSPYUrwvi12POi7c53Fu2vubbhPqofKVnefCsnERdrfTOyQMAz4Hu8Ui1yT49e5BJy/UY6GAmq/lMVq0Q5yCQ38EC8rONb8hP+SURM57XxL3jFK8rJhgp7EDAIzW+iNJhWIZkc+9okdmCmMkMx0A0ziD7QvejT8AYSOIeHxyzUb/NcTRCnGNhDPRLGAPZ7uKwzW8L3JlddL4d78OiscZeEGY7KyI11twxAiPaBNTOmyL4aIQ4fyhzDIQy4OuV2BeiPpFqv1HfejkAMBLPwndP9+HB8WcB/MI2Ua6edjiXMdrhL1Zoh1P9wXE1yQrtcN5HZU34gQwL2eE8DR1fqh6iXeQw3TzaGCR7wk/5NUKcN0rIntsrOzLZtYC8KG4DxENZ6nCuS0j2FG8viC+5fhvV5uqxp5Xfm2jLW6CPqnhP646AR6Ku4pxrOXik7WEhPvv07CEmLddjoEOZrHZksmqFOIeA/A4VkF8G8qW0yU/5JREz7pNAe57i7RUTjBR2MOARqM9FdRiWIb/TD2W2IGYys63vkX2h+9Epmw3glRoDHQD5FYKh63qNEGcmjIFmGGwtwdAxJq4voMyl9mlFrS/gPi3OF47dcAwk0Qfa6i7lTfnhGL8pgg+8v6/dyN9mQyFvuHeOn0WSbKtR452DACPfUyhp/1D5k+1l25csNd6pl83NZYw2d6FIfbHZ3PzOUxyfSut6tF0cpptHO4BkRvgPAZlRnJ1KyOzQCJlhHSdZHQoyk7ofM6qOd9cx76BI3gJ92HxbmZK+xD6M4uxTYZlS32bb81vMvuS2iW2dfx+WDq7zH1QEJ85xYb2Ssmmi6hXaNNTPk7ya4f/Ce05Dm/zJj3dAUhiupfKzFrh/dWkdZBt1J/WhgNE2hy+1bxj3zhUseeMe8/1iKjNbfUQ5LgeMAnsNBt3l08jkuJ+ofMKeSu+oQP0hUaeE6kEOdclIZ+l2WG31pUxWrRBHeA9ZUd1m+76JO1l0dtjGVjZZ7GvBI3WHf5Qs9rXk7VAWfXkfUoYsDrHgEbBli8riEEveDmXRrvM+rAxZHGbBc1idZUH5VYp5nxhgHsme3eQ9v0/HHV6GLA634Dm8zrI43JK3O1nk++azjyhDFkdY8BxRZ1lQfpViPiQGmEeyZzd5d/bZWkeWIYsjLXiOrLMsKL9KMR+SQMyHxwDzSPbsJu/OXp33UWXI4igLnqPqLIujLHk7lMVqnffRZcjiaAueo+ssi6MteTvsV/vsohVlyGKFBc+KOsuC8qsU8+EJxHxYAjHvk0DM+yYQ8yEJxJzENhiHujGSPbvJu7NH572yDFmstOBZWWdZUH5pwHx4AjEfkkDM+yYQ89EJxBwHOeM3CEZsLoknXNXM8JDMAoYxYBib4RnXN3qcY+y/z4Xy6oG8VrnPK7TVF/KvEs077NHprnbPU9/82zEmLVq/X23h6VjznHEsz2Mg3QzkQ+GN+Lz5QFyKR/KgdkvY9Xpjr3lG7Py9ley9VojTa+G/ELjlfzXDs5ph1mXyCuxDlKhb5dRrvQ+C2vI2xsU1XfzeSQ8Lk9SXPQw3+VcCRtKXqB8EdFHRbzhSfvgdjQNiKrNWCFsOeJqF8GzO8GxukYVU3huzvDeuY97jWN7j6pj3aJb36DrmPYrlPaqOeY9neY+vY97TWd7T65j3VJb31DrmPYvlPauOec9hec+pY94zWN4zWN4t8Izf3VruGk/Y07dOR3nQnij+PSehcUQPnoOnXznjCKl+WqhvtZ7NOoDxhPsgce+S1F69lQwPH5dVinmfBGLeN4GY63EGzteNwWtTScF8eAIxJ7E+H5FAzEmUcxLr85EJxHxUAjEfnUDMSazPSewHvS1aH8y+T6kP5iTWjRUec10we5u/PpiT2AaPTiDmOMhZz4PSnOidm0vi6d9LgXhIZgHDGDCMuAdjJchMYH9DDssH1/573edVdK9Lr2je/XspjnHPUw73F9BeimMsPK0xz673UuA+hwzkQ+GN8Hw77KWgeCQPareEXa9T0L4ExM7fO5S91wpxVlv4LwRu+T+G4TmGYdZl8mVo5xJ1q5x6rdd5qS1vA3Lx6+tu8/br6/3p+vV1+bz9+np/unFdXx8O/1vFwiRt0FUMI/kPBYxkg8ruIe3HQ3mR7cHzbmWyiqPMWiEM900MF8IT1X8Or0PeUf1nPfKO6j/rkXdU/1mPvKP6z3rkHdV/1iPvqP6zHnlH9Z/1yDuq/6xH3lH9Zz3yjuo/65G316lep9Yrb69TvU6tV96ldGoLPA8DPGNc4wl7+uaiKA/a80t5o90sMN/dt+eXxg/0K2e+W2rsIzReydnWGZoZT3hGEff8rhTgs9j840ooh0ow75NAzHE9E10Mc1zPnr/d6sZhCcQc17sU3m71+YgEYk6inJNYn49MIOajEoj56ARiTmJ9TmI/6G3R+mD2fUp9MCexbqzwmOuC2dv89cGcxDZ4dAIxx+X+NJoT/eQWknjc35/W6xzj4PvTcI+qwF1jRfdkrxbNu3/P77HuecrhPlja83ushafjzHPGsTxxP24G8qHwRni+couBuBSP5EHtlrDrdQraP4vY+Xsr2XutEOcYC/+FwC3/xzI8xzLMukwuhnYuUbfKqde2+9O0zKnNNULYSpAbhaE+pTBKe0MII5lvAmEkk80gjOrEFhBGMtsKwo63YD7BPDdA2InmuQnCTjLPIyDsZPO8LYSdYp43gLB3mOcWCFtrnreEsFPNM+5pPs08bwphp5tn3H98hnneCMLeaZ5xr/C7zPNYCDvTPOO+3rPM89YQdrZ5xj247zbPWQh7j3nG/bLnmOcpEPZe8zwdws41z5Mh7DzzPA3CzjfPuDf1feZ5AoS93zxPhLALzPNsCLvQPM+CsA+Y50kQ9kHzjHtDP2SeZ0LYReYZ93FebJ7zEPZh87wYwi4xz+0Q9hHzvATCPmqeQwj7mHkuQNil5rkTwi4zzzkIu9w8L4Swj5vnZRB2hXmeB2FXmuftIOwq87wDhH3CPO8EYZ80z7tA2NXmeVcIu8Y87wZh15rn3SHsOvO8B4R9yjzvDGGfNs97QthnzHMHhF1vnudC2A3meXsIu9E8t0HYZ83z3hD2OfO8P4R93jx3QdgXzPOBEPZF84zfYr7JPB8MYTeb524IIx3XC2FkP6K9Rvobz23RWvtqCCP9eAyEkX48FsJI96+BMNIhx0EY6Z/jIYz68hMgjNb7T4Qw0q0nQRj1LydDGOm9UyCM9OM7IIz091oIo77pVAgjfXsahJFePh3CqA87A8JIp78TwqhfexeEUX9wJoRRX3cWhFFfcjaEUf/3bggjnf4eCKM+8RwIo37tvRBGOv1cCMua5/MgjHTw+RBGOvh9EEa69f0QRrr/AgijfuNCCCPd/wEIoz7igxBG/cuHIIz08kUQRvr7YgibZZ4/DGHUb1wCYdQffATCSF98FMJIZ34MwkgHXwphpNMvgzDqNy6HMNI1H4cw6jeugDDSZ1dCGPUHV0EYfaP7ExBGOumTEEZ65WoIW2Cer4Ew6kuuhTDaN3IdhFH/9ykIo77u0xBGdyN/BsIK5vl6CKP+6gYIW26eb4Qw6q8+C2Gk0z8HYdSHfR7CdjTPX4Aw6te+CGHU59wEYdTXkZ7W+hDvIEb9vg8LGwl5FwK3YxD+vVLyU34aI/9GZws8LwDc3SxM454vhLub4SY/fnOeeOiGMHqmOpmBd3ha+O1q+hZ3U0R+jRCn2yhm2/e3RwYi373v+5Y52QM0lidsBwFGirO4CEZMi3Duw/hFWR4MvAl8xzZv443KZh8Lb9uVkP/BAhiFeA+x7tE+yH0tvFOcnbcckNOu5hn1/AEgx0Ms/6dfsbk+LO9D3fPcNy91GOAsQD6Y9+GA1VHeIeZN81L8W6aN8HzwlgNx+XdRSdZ4Xo7WGBA7f28+ew+/p3qIhf9CUJ95aMpPl8keUM+oHkn2U4dEyGg/kBHF6QYZHSCEh3/bmnBQfthHNbE49G4jxFlRRGdp3sgWIL6xv0U7QUC3Fe1vDwaMFLYjYOQ86/oyxQx6WuD/OA7eh4V5+6f88nBp/+wFcaheF7N/KM47S/S/Am2yz/6heRNu/xwAGCnO2SXsnwPBXwiK2z8HAm9S9g/njcpmHwtv55WQ/4ECGCXtHyw/na7N/qE4F0K/9EGLfbMfyPGqKu0fLG8BfZvD/o7K+2BL3ocCVkd5D+pryf6hfCi8EZ6vBPuH2w0ka8Ku2wzZqYidvzefvYd3Ox1k4b8QuOWfj30OZpj71uWgnl1VB/vnoAgZ7QUyWjf+BBntK4SH9z+Eg/LTcaj8m1gcercR4ny6hP1DtgDaP9x2ENJtIfJCaZP/QMBIYWj/cJ51fXnCTAS3wP9xvaCLhUnaEZQXpc3ljP1cF4TRM9o/3CaSrH9Rdtu+gJF4sNltaP/sG5HWjhCH12WeH9blb5bof/eDvArmOVfbr8/+ofUl6jMI236AkeLcUcL+2R/8hWCgvFG+JIP9gbcu97zlbbxR2XRZePteCfnvL4BRiPdBuofsn24L7xTnh9Av3Qv2DZXbXiDHxyz/p18x+wfLW0Df5rC/o/I+0JL3wYDVUd6D+lqyfygfnIej50fB/uF2A8masON8P2Ln7+3L3muFOAdY+C8EbvnnY58DGWZdJj+BevYY2D9S/dQBETLaEWREcfCcRbcQHt7/8LG2jkPl38Ti4LiF4vyqhP1DtgDxjbYF2gkCui1EXiht8u8PGG1zVJxnXV8+BPYP9cO4/mWb15LSrVHzKGjrkD1jm0dZCrjnszCNe28h3HzOhvx7A0abLUfPtDaagXd4Wmj/UPk1ReTXCHFeLNH/CswTdKMdR30GYcP2RnFeLmH/cJuwm/GLssS94QLlPd/G244MD/L2Rgn5C9jk8yXrOpafTneBhXeK07DVgJwazTOOqRaBHDey/J9+xewfLG8BfZvD/o7Ke39L3gcCVkd5D+pryf6hfHAejp433GogLrcbSNaEHef7ETt/r4u91wpx9rPwXwjc8s/HPvszzLpMRkA9o3okaW/sFyEjtH8oznyQ0SIhPAsYHsJhW1fg9g+92whxtjIyLLX+hetEfA5Mcr4hqr/dFzBSGO7B5Dzr+rIE7B/qh3Ff6SIWNhLeLwRu+aK8KO1FDK/GSPbMIghbBHjJ7WZhcbbb8C7Zroi00P7hddk2Bqc4YZG6LDJGMt/Ipb2B1Gdw+68R4nQUwYhpEc5FjF+UZRvwJqBvrLxxfYO8LSwh/zYBjJK6FstPp7vUwvu6OgX90nKLfbMc5LhPlfYPlreAzZdDm4/b8pg3rjU4ynuQvUn2j229kZ73BvuHjxlI1jhmsK2T8Pf4/H9rMHT+TrKv4+NBPvegy2QHqGf7gP0j1U/tFSEjtH/4WovGs1wIz1KGh3DguJrv/6E49C7u/zmkhP1DtgDaP/Qu2gkCuq1of9sGGPn+l2YLz31zh+ZwBO5RwTM5y1mYpG6lvCht8qOtQ/JdDmH0jHNdC1iY5HiA2982W8dmy9Ez1SNb2VKcpRCHzhM0ReTXCHFOLtH/dkBeBfOcq+3XZbMRCFsHYKQ4p1Zo/yxn/KIssU8S0Dd5G29UNsstvJ1Zf/snL6lrsfx0uttbeKc450C/dC7YN9ym1///qOX/9PP2T3n2z0eK2D98jrJc+4fPtcbR/nkf1LOPgv0j1U/tFSGjpSAjioP7L7YXwsP7H8JB+ek4VP5NLA7O/1Ccq0rYP2QL2OZW0E6Qsn92DAbzS360f/iYtNnCc99+ebB/SG/hWe15LEzztUyIL8qL0iY/5acx5swz/c/23lImjwykwcuf3m2EOF8o0WcJ9C19NgOdBxzO+Me+heJ8qYTNsB34C8GAHUhptgC/28ny1qnxbM94s9kMFOdrJeQvoEc6JW2GHYBHnW7OwjvFuQ10+bfAJqBy6wA53mf5P/2K2Qw4RtvJPc99NsPOgLMA+WDeuwBWR3mHmDfZDJQPhTfC871gM1A8kgfJmrDjGBGx8/fmsfdaIc6OFv4LgVv+d2J4dmKYdZl8G+rZfWAzbCeEaccIGaHNQHGWgYxyQniWMTyEg/KzjTOXMnxo6/+8hM1A/SfeW8L7W0kbqSMYzC/5tweMFIb3qHCedX253FwygesxeGfJQhYmaQtRXpQ2+Sk/nHtYKIunC20R0ns5hqcR4vy6RB/O7Rrqw3PAG/E0D3gTsM/yOD/FecP2QHGer78NlZe0TbcDHnW6iyy8U5wXQLf+1dJH4/zja1X24ctBlju45zmHOpvKewdL3jsBVkd5D+ovqA+nfCgcx2uvQh/O+z6SNWHHOVTEzt+bx95rDew2jID9NMhmpLR3YJh1mfwD6tlr0IdL6drtI2SUAxlRHNS1UvMQXPcTDtz3QeXfxOLQu40QZ5i5nCiqD6f+DPtw3v/Vc52Hj6Fag6Fj32YLz7q+HAx9OM0HhPDOIham+VosxFfUvg/KD/s5LFv+HvGJ+54pDV7+uF5NcTYqUv6a/yXO+Q/nY7kOZ/wvAYwUZ7MiGG11pI3x2wL8LhXlrd8eKjDechbeKM42JeRfEMAoxPugMQbxuNDCO8WZuPWAnCabZ2yHOGfXZvk//YrZDAWQpcA4L2eb59nOkvcOgNVR3oP6J7IZKB8Kxzmm/NYDcXlfS7Im7LjGitj5e4vYe62B3WYSsNdC25zfdgyzLpNpUM+oHmlMS4UwLY+QEdoMFGcxyEhq70aUzUD5Fesz0GagOAtL2AzUf+I8PL2LfWtBiN/FwWB+sQ8njLw/iLIZXtmo/xnPc6DNsMDC10IhvqL2HFB+uCcQy5a/R3zOhziUBi9/XCuiOLuV6LPc2779NgOV2XDGv82u2auEzcDrSBvjF+2vxaK89dsMSxhvNpuN4hxQd5ut32aQGtPgfiydbreFd4pzKOjyw8Em4Ptq9P+Pt/yffsVshiUgS4G5lZxtXmmZJe/tAKujvAf1T2QzUD4UjnNax4HNwPtakjWuVRJOxM7fW8Deaw3sNpPUvPwyhoevCeoyOQrq2fFgM0iNBwuBXUZoM1AcnGeo1/5+woH71qL6DNyTRnFOLdNmwL2L9C72rVLjlqg59SWAkfcHzRaedX25DWyGTsYD7vVGvqT2KUbdL4L76MgOwLLl7xGfHRCH76/ldQT3176vRJ/l3vbttxnQlisEQ+9NwTr6gRI2A68jbYxftL8WivKWa8e5IG4zIG8U55K622y5dskxzWLgUac738I7xbkMdPnHwSagcusEOd5o+T/9itkM+G12gXFlzjavtNSS9zLA6ijvQf0T2QxoF+kfzmndADYD72tJ1oRdtxnSsYidv9fF3msN7DaT1FpY1Dw0rhFfBfXsRrAZpMaDSyJkhDYDxcEzGfW6E9M2zqTyL2YzUJwvlWkz4JkM3t9Kjls6g8H8kn8RYKQw/MaLzWY4FWyGeYwH3DeBfHUK8RW1b4Ly0xjpmwcdonj6+/D5IKcCyI/yw/N33y7Rh/NzxNSH4/4C4gnPkUjdq9UdwZvNhrq7RB8uYEOK3quFfbVOt93CO8W5F3Trj6GP5ns8++73s/yffsX6cNSRAjojZ5vDWmTJewlgdZT3IJuJ+nDKB20pen4c+nDez5CscX2Nj5ds781n72H/tNDCfyFwy3/UmivOvf0U6tkT0IdL6dqFETLCPty2t6xdCA/X/YSD8sM9WrwPx3NC6/Z7ldmH4zk+3v9Jjo+j9t93A0Z+HqDZwnNfe4Y+PMd4wO8JIV9S+1YoL0qb/LhHkPjKQxh+K4/cdhYmdIawD3c7w83tjBbgoR3C6BnvleiISGsuxOH2KM8P7dGXSvS/znWEuVeC2z/cHkP755UK7Z884xdlifZP3jVvEbYdlU3ewttbJeTvflwTzpfhffD4geyfeRbe18XZZkBOTeYZxwU5kOMmlv/Tr5j9I3xuOoc2Hz8jjHkvBKyO8h5kb5L9Q/mgHUrPG28zEDdq/RznUMlmRez8vQ72HvbtXRb+C4Hs+JzPVeoyGQX1jOqRZD/VFSGjuSAjitMOMponhIf3P4QDz95R+TexOPRuI8TZxsiwlP2DZwm47SA5Z5MLBvPL52xag6H7+ZstPPfdyQb2D33vEfeNhixMUrdSXpQ2+dHW4XJuCQbba+S2sTBJ+5vfe2Czdbgttz7tSCFZ5FHu9CvWd6FuEBirtaEdXA4ePN8kYSsL8ZlDXfOmw3Rtur6dycr2nQnJ+aeo+dti66Aes3vMGg/XcziX3xYTjBQmO+ddXO9iGVJ/FFpkVo87ICuRWR7wCPT5ObRJKH1tk+wPNmzoPt+2DMuvADgov0aI8zrY1web56h5l7ksTNLuoLyCwG7Tom00F8LoeQxgFOjv2orZ5rgnhc/n2GxzitNTwjYfY5EBPaNNaNNTUvZ6VJvDO+aJZ7RBpOxDqhM0Vg8tspC2Uxym24b95/AIGTdCnFOK1KFy+mKcz8Q5AIn6IzSv02ab1+F3MePcyjtLyGxBhMywjvN9XA3B0DuBsyac35X3pgnnaej4kuuoAvM6bbZ9YHxeB/eBnVdC9nyNrJ3JDs9O4r6jue55K6pfcH6I+kfsQ+PUd7YGQ20C5K3BvDfT+Dtk5ZpDm6UxsPelaLNcBnOhVObDgsHlgX1wO0ub3pkJ4e0s7TruS+xBjMMZH4ssGK8sgVGgXvVI7ltCvaDTtZ01oTjXgL16HawrUH2ZAXL8suX/9Ct37kZg7T+H+/eovJdY8i4AVkd5D9o7mGFp47kXev7SNkMxkDxI1oQdzzXbsFP4XPYeniVYbOG/4Jh/vg8Ey1j/dJl8BurZl2HMJjU/vDhCRiHIiOLgnXp8vpzvX9BxqJyaWBx6txHifL2EbhGw2636z3ZnD8W5fT3pP+n7k0j/5S28U5zvQL28C/Qbt0P0/x+0/J9+Xv+Vp/8eKKL/uB4rV/+F7L046r+7oZ49CPpvhhCmxREywn1nFKecc0Go/6g9FTsXRHEeLaFbBOxfq/4jbHMBI8V5cj3pP6kxFdd/Myy8U5xfQb38Neg3vnaq//93y//p5/Vfefrvb0X0H9dj5eo/fv9MHPXf76Ce/X092H9cR6H+WwBh/P4vPFuO+xqk98xT2gssuCmMZGdbT6KxOOptvq9lJksH97W8WkQnNlve1eX63g37n217GHB9HeeO1+c+U2pvtvl/XKexrbmtz/l/23kdesb9sfMj0sL9sVSvmiLyw7nw5m373ah+0nmbMPtj+Rkafp4Zz9CMLYIR0yKctrlnkgGe2RCwAdpsvNnWsyjOJiXkLzH3LzmviuWn0w0tvFOcLbcdkNPW5hnP/6AemmX5P/2K2SlY3gJz+TnbXP5CS954jsdR3oPOx5CdQvngvOC6udxtB+LyvpRkjfcSUZ+E2Pl789l7tj4Y+S8EMnYxpc3ve9BlMh7qGdUjyX5qQYSMcP2D4uB6r8BeB2v/Y1vX4OM/vh6N47+2IjoL9wXh+SDbHkSp80FR+3BwDzc/Q9Fs4Rn3ouj2MMmEz4B35rEwzZfUXfBR557wHCzf+4xnhtD+4Xtm47avV7I9RO2fDmVlka90jhH3Xwn01+3YLsvBg+NuiXleIT5zqOtd74/lujXPZFXvPYhRYyTKz2P2mKMw49kW3JdB8epxj0U5GG1zDlLjmai+AsuQ+tB5Fpk1x0xmOcAjYKfkcB4JzzeeBHa3wDmw9gzLrwA48Ntp6+ZVxw/EXWuwoR2CttJMFiZpK1FeQWCfz0N7biaE0TPu6RXoo9uLzUvimjvVt2LzkhTnPSXGE2MsMuDn8qP01PqciySe0W6SsmnxrGMhsN/HIG1bOUy3HfvP4REyxn3hF5WYIyzVF+PccT3OgQnMNbfb9kHze5Fw/u3SEjLripAZ1nF+fqQB8qL/ZYPBe3fxrFqDJQ0dX0hGeaF5h/ZK91NfU0L2fA4pz2Rn208tOV8sMHfaXuk+6BtKyGxRhMxK7YOe6Z63ojqZ8kPbEe2OONkbrcFQOwp5azDvzTH+Nlm55tDOawzs9gfaeV+HOW++D3oee8+2x5remQPheZZ2He/UH7QPnH9/d5EF4+0lMArcEZOT4d2+D2auhfd1+wBh3v8uWD+i+jIJ5Pig5f/0K3eOrt77YDDvAmB1lHfl+wC3HYqB5EGyrnQfzEz2Xiz3AUI9exDGuVLrAIsjZDQPZMS/3WI788K/1azjUDk1sTi4z4ziPFpCt7gf69j1X7Gzu0+uJ/0nNc6LOgeCvK/bBwj18teg37gd0rd/y/J/+nn9V+Y+wCL6j+uxcvXfPPZeLPcBQj37O+i/SUKYFkfICNfXKQ7Ox/O5XNtZdConvg6ONifFeamEbhG4W9mq/2x3K1OcV9aT/pO+e5X03yQL7xTnTaiXgZnvxXV+vH94rOX/9PP6rzz91zp+KAaSB9djb6dzcMNgLYHqkeS8QtQ5uFLnQCax92zfh4m6J5jexXuCNzW81m3vaIT+m8R4Rf23ZQmMUvpPai85138zLbxTnPFQLyeAfqMyxXNwOcv/6ef1X3n6b14R/VftObgknAOZDPUsB/pP6r7PqHMgk0BGtnMgtEfPNteK+/ekznBFzbWi3VpsrpXeo7lI1Nv8HMgclg7OiS4qohObLe/2lfGG/c/+nvTqcdfjnvSZEKeSe9L3KNFPxuGe9H2KYMS0COf6uye9f22L82bbA0FxDiohf4n1Ysl1pUruST8c+o8jwQ6x3ZN+ouX/9Ctmp/h70geeTwA7JU33pK+AenYi2Cn1vicd13/X5z3pNlsj6jyp7Z7004vorCTfk855xv2Luj3MNuFzLe/MBb6k5j+j7EjKT2OcZZ5tewTR/uFnQ9b3+RXiAc9lS7UHPh9iy1tAFvlK11hwz66ErVLLmF9inUuIzxzq+jcdpmvTrTkmq3rvW48aI+E3wTxmj9mGOerODIo3LyYYbXMOUuOZqL4Cy5D60JkWmdXjTtNKZDYJ8AjYKTmcR8J9VreMF823He0jGodxHLiG+77sQNxvGGwt8A7aSpNYmKStFFXf0Fay2X30jOdABProdpt9TXkXO1fO+cC1mu+VGE+MsciAntGOtemp9TkXyXWFpE2L83+FYOgYrx62lcN027H/HB4hYzxL9ECJOcJSfTHOHdfjvHO9zs4Qftvc7yMlZNYZITOs4/zMYQPkRf/LBoPPe+CZ7AZLGjq+kIzycTmD86sSso+6u7HYGRwh3tricnbm9yVktiBCZqW+RcDvk8uacN5n8W8RTIL49Zj34bod1z3JNkH7JU52SyuEIT/03GDeo/VYtO0l7NRMMPhsB2LGPbUU538wd051h86TzGTvoY1EadM7MyA8x9KOWgNa4Jz/9kHnafg61QILxtdLYHRfr9pzMrwPXjeg8pll4Z3iZLIDchpmnrF9zQY5bmj5P/3KnesTOEOTw/0TVN6LLHkvAayO8h60d4PWqSgfCm+E5w2yA3H5PhSSNWHXOp3WehA7f28Se68V4iy08F8I3PLPzyguYpj7vhWdHXimeqQxzRHCtDBCRrhORXGK7Uux3QNA7YmvJ+G+FIqzRbbfjdIts53zb9d/hG02YKQ422SLY5TSf+55t+u/ORbeKc7E7ICcJpvnqPN0bZb/08/rv/L0Xz47ELeUHitX/81k78VR/03LDjxTPdKYZglhWhghIzxPR3GKzevbzhNTe+Ln6XA9neIsyPa7UbrFvf1r13+EDedL1+1DzRbHKKX/pMZUUfYf8k5xtssOyGkH8xx1nm5/y//p5/Vfefpvv+xA3FJ6rFz9x8/Kx1H/7ZwdeKZ6VE/7j+so1H/F7rfja5g2+4/P8aH9d1i2343SLe7P09j1H2HDb99RnKOyxTFK6T+ps0RR9h/yTnFWZQfktNo84x5q3C9+uuX/9PP6rzz9d1p2IG4pPVau/mtn78VR/63JDjxTPaqn/We7P5HvZcXvg+IZAv5NIsmzsHxtoMuCm8JIdqiT6T2aiyx2f98Mlg6uuZ2X7XejzpPwd3W53rFB/zOuY+MaLl/Xldprhvqf0uZ7VHEN17b2jHsEbPs91ufas+2ubXrG8yRtEWnNgTi8ThRbh70s2+9G9ZPO98CY8yS0LsbXPXG8RXGuzEZjxLQIp23dk58xEVpbabfxRmWTs/B2bTaaN6l1Z8l1JSw/na5tHwnFuT47IKcbzbNuj1RuOE671fJ/+hWzU7C8BdZac7Z15PmWvNetTQQyfQvZKfw77biG/bXsQFx+DoN/s8r2LR7be/wbEq0Qp9PCfyFwyz8/S8bXo3WZfD478Ez1SLKf6oyQ0RyQEcXBvUZScye8/+H77HBdl59LxXNgFOfObL8btf+Lz6/h3DLaCVLnN6POXXQARr4G3GzhGfdB6vYwzYTjvtGJLEzzNUGIL8qL0iY/5acxTjXPEyFsIuAldxYLk1y74HYs+WcDRuJhFuCRGkdMYHhseQvIIo9yp1+xvms24BE4697WDHmUgwfHShJzXEJ85nAfp+vzJHxMws+c4dk14fNKfXWb3x3I75zxmOuDWePheg7vrJoVE4wUNgfwSN2rEaV3sQypP5pokVk99sVVIrMJgEegz8/hnAylr22Sf2VF821DW4PGNBxHI8T57ISBuC9l+59bgsHfXyN3AguTtDui6hvaHTYbip7xbIZAf9cn59kRGHE+h+pbUwQfjRCH/lnqbAbKgJ7RJrTpKamzEFFtDr+Nx3WFpH1IdYLG6hMtspC2Uxym22ZbO+MyxrWzliJ1qJy+GM+1U9wGeKb/vRkMHoe7sM1Wmx+en6kk3dUlfo7OJoc8IAA5NMAzznWV+r8tbh7e4ePyN5l/RDDUhmqE/29ZpF5I9clC8/JtOC/C72fFeXKKM75Em+BzLNQmcB2C360jxFteaG6rDed3+bw97sGnOFNLyKw9Qma2eXuK2wDx6H9ZE877RTr/QfEmQPx6zNPw/oPyQzsXbaQ42UatEIb80HNDMHh+H8cPErZwJhh8FgMx47kQirNgwgBmqjt0/mMiew/tMErbtrduNku7bmtmuVwnYhzO+Gi3YFxSAqNAveoU4n3Qt4mpfKZaeKc428F4ZAfzjO1rGshxf8v/6Zdh/gI849ycwL6BHK5t8P1OmDeu/zjKe9C6Cq0r8W+C4Z14+0Fb43sdSNaEXet0modH7Py9Cew93CPRYeG/EMiu4fCzm337/6CeUT3SmGYIYeqIkNFEkBHFwX0kU9l7FB/n16icmlgcercR4hxWQrcIjMus+m8q4xX131HrSf9JjUm5/rPt86E4q6Bergb9xu2Qvn1blv/Tz+u/8vTfaUX0H9dj5eq/iey9OOq/NVDPTgf9N00IU0eEjKaCjCgOnn+bwd6j+Kj/qJyaWBy0OSnOu0voFoE5HKv+m8F4Rf137nrSf1JzhFz/TbPwTnEugHr5AdBvfG1c//9Ky//p5/VfefrviiL6j+uxcvXfVPZeHPXfRVDPrgT9JzWv0BEhoxkgI4pj+y4oxcf9r7hvRcpujdr/irj5HI1tjoLvJUTblt9bhetUFOeGIjqx2fKuLtdjTWRcK8J1Er52Inn+h68VkZ/yw3US2/oOrsPZ1lTX5/oO8YBrCPSM+5/nRaQ1A+JQ/WgKSq91fL3ec9pm/zP1VfwsO+6TpTi3l5hHDcFfCAbKG+XLv70oZAO02Xijsplt4e27JeQvMY8tOa/K75GZYOGd4twD/ccPwQ6hckM75RHL/+lXzE4R/s5Hrpw1Adzr6dpOwXPe2EfivCA9Pwx2StRYotiZAdt7fE3N1gcj/4XALf/8PAi/P06XyX1Qzx4BO0Wqn8pHyMjW3+N6vpTdxPsfvpcF1zX4OSr8ni7F+WURnYX7vvCcFLcdJPefTwwG80v+EDBSGN4/xnnGvUZ4tmoyvDOFhWm+pgrxRXlR2uSn/NBGmwJhUwAvudNYmMY9XQj3NIab/NMBI/EwDcLoGe2f6RFpYV2mcmyKyA/Xyf5Vov91PiYw9g+/+5ew4XzLuu+3lrB/+H7/KYxf2959mfLu/+4h520Cw4O8vVZC/u7Pk/d/91CqrvM12okW3tfNx00ckFODecZ5GLynaAPL/+lXzP7B8haw+QbdS0jlPduS91zA6ijvEPMm+4fv58V7a8ZNHIjL+0R+Nx7u4ULs/L2p7D3cHyu8X67omBj7sOFQz6geaUxThDDNipDRBJARxZkGMpI6/8XtAcKB57/4+h9fW8T1vy1MYJT9Q7YAzjfRu2gnSN2VEdXf4j15FIa2Aee57zvBMP+TZf9vBn4mAl9S9YryorQnMx5sNlpLMNheI3cqC5Nct+HrzzZbh9ty69OOFJJFvtK+C3WDwNxsJ7bLcvDgt1cl7AchPgfdy+P6/BfX9dOYrFDXoz0gtU+Ar3XyfQIes8fsMa9fzBoP7wNx/mVqTDBS2HTAI7VGGNUnYxmSrTLZIrPmmMlsCuARsAdzaK9S+tpePRzGN5Pd59uZYfkVAAfl1whxTp06EPdogy3KJo3bnBzxVWxOTso2KzbXh2ud/N4O21wfxTm+xLhtjEUG9IzjBb6fQLLNRd3lMQsw2ub2pMYOOM9aAD/uQbPpKdt4S2r8GzXewvEvn5OQXH+Jams+bxEdna/0LIP02g3Ok5SDpx5zAFFlg3kLtM9cPffHc12J+0MvLtIXYFqEk/oB/E41n/uV2leBc4qYl1SfMw3kUAB/Pe4miqqXwvvLKr6bCM/7SZxZb4Y8ysGDd75IrDUI8ZnDPWau56b4vrA5TFatEAfvVJbalxD1XXn8DpfHLI8Z50Nw/wfFq8celXIwUhjuEZLaoxqld7EM+To+ymxCzGSGY2kai+O+hNtgnkBg/Npm2wfB53RwbNoB8wR3wjwB36uF8wQoc6k1t6h6gWtuVB9s8wRoW0vtt50SgZHyw30CTRF84D6BH5WYJ7CtO9Iz7o2fw8Ik9wHMYTKw7ScnntF2kbLjqE6QDTmdyQL1Cc5h0v+xbkvt0+Tz5rxPwH4C54DX15xcmvMW0NF9Nj/OMQZB+eu/Eu0G5/PpVwyP8Hgsh/P59TjfE1UPhO9mzFc61kJ7TOLOJzyfVA4etKkl7EMhPnNoK7oe+/E9+LZ7LCkOntPIC8gvA/lS2uTHc4q8z26GeHNigrGed8xG6QMsQ9LfUywymx4zmeGYhM9Narv/DRiTSOhznNek/cnF5khfnjKALWM21uG+WBwH2vrs9TkmIb5sYxLsx6Xs8agxCe4lpjZUbExCccYY+UeNSWZYZEDPtjkO1CdS7TdqvI53AvJ5Bkn7guoEjUlmWmQhPcfpmqdKztFuUaQO2ebxqP7Yziljnym1bzaqvKbVMe+gSN4C+i1f6Z5U3GcjZYtOqQCP9PyupC1azX25pX5aVvyM6hQmq1aII3w3alGbBc/w2s4HcDtmfWPk37+T1LNR+sBmi86yyGx6zGSG3/Dh9yXovmTBpAG8EvsAcP6NbFF+bgy/uXsH2KJLwBadzeSLtnU9bNGoeoF2GN97i/bp+rBFKe9itijnA23RXYrYETbbO0p3rM/vZHI7SdKWwL3ahcB+9k16fsU1T1F3h+M9ZRTngBJ2J5+r4boVxwnYP0qthUaV17w65h3ENG+BvsB6Fz1fs8X6tKLC+kR9BOpkfhe97T2Kj3qS7zeewtLBNd1jyhyzY52WOl8QVacpv4Zg6HgvY8L53ALdK8/vNcmsZx7QBsM7v2znOKTsgagzElMAo21NRWptnNtYeSYfGVmEPZWureE4VqL+CJX5oLOVI52l25G3zcfwuW7cV4UYpPr8qDNKoSVvd7Lo7LCNoW2ysN27JTXWipJFmyVvh7IYdOdXMVm0W/BIfZsgShbtlrwdymLQt8aLyaLDgkfqPrIoWRS7Q60Y5jAGmEeyZzd5z+/TcZ1lyKLTgkfgzuGisui05O1OFvlB9x0Xk8V8Cx6B77oXlQXejVwJ5vYYYB7Jnt3k3dl3p1dXGbLosuCRusM5ShbF7p0uhrk9gZg7Y4B5JHt2k3dnr867uwxZdFvwdNdZFt2WvB3KYrXOe0EZslhgwbOgzrJYYMnbYb/aZxctLEMWCy14FtZZFpRfpZg7E4i5I4GYwwRibksg5vYEYk5iG4xD3RjJnt3k3dmj815UhiwWWfAsqrMsKL80YO5MIOb2BGJuSyDmBQnEHAc5496QsZMl8YSrKt0DRxia4RnXNxY7x9h/VofyWgx5LXGfV2irL+RfIpp32IP9pUOe+ubflpm0hrO0kafl5jnjWJ7LIN0M5EPhjfA8ZvJAXIpH8pgOz/qn17qXmmfEzt9bxN5rhThLLfwXHPNfYHgKDHPfGQRo5xJ1q5x6rdfyqS1vY1z8VsoE4+q2v5iFSerLxQw3+RcBRtKXqB8EdFHRtfp65h3EMO8WeMaz8QJr0313IlG9JZ1GeeO+Pooz3gCK2lezhPGWt/DG24uNX1taFAf32hDGJhZnCWCnOFOLYF+f9bwhGGq7ZE04LwvaV8P78Wzg2+r6yluqXVKfSu2S6jS2S4rTUaJdLmV8ULu0tcGlRd6j+MXa4BKWDrbBhUVw4r0ZaE8I3P9XtE5Tfg3AC7azBohD/6d2yfVYdj3zgHdoUJk3w//R7pAaB0R9k2EJYKQw3O8mcB6307bfbSmTj5TtWOmdkzimkKg/QmWes43NJzCeWoOh+3eFdGlosyW4Lq0Uc5hAzG0JxNyeQMxJrBsdCcTcmUDMSazP8xOIOYlyTmJ97kog5u4EYl6QQMxJrM9J7Ae9LVofzL5PqQ/mJNaNhR5zXTB7m78+mJPYBpNoI8VBzrhP5snJknj698kgHpJZwDAGDCPur8F50YJzjP37ZKYwLDqvZe7zKrqPaZlo3v37ZLZzz1Pf/O/2Jq3hJt3tLDztYJ4zjuW5PaSbgXwovBGeH4N9MhSP5EHtlrDrNbLl5hmx8/emsPdaIc5yC/+FwC3/2zE82zHMukzuh3YuUbfKqdd6DZDaMu6TofWYZnALLExSXxYYbvJPAYx49yrhKQjhiVrjozzwe3pLYyqzVghDfui5wfx/vPHjWlzBPeYcrm03srTxnhaK81fQE1RnhwWDywPviZnC0l63fwbCp7C0o/alCKxFdiHG4YwP296Zf5bAKGArdEmuSS8DHnW6kyy8U5yXJg/I6WXzjO0rC3JsmjL0//Qrx85ZH30y5h2HPnn4lIG4vG/NmudK++QCey+OffKrUM+oHmlMS4UwLQ/sMsLvr1CcqSDbSew9io97grLmuYnFoXcbIU6L4TVKt7j/vqVd/01ivKL+26AERin9J/VtT67/llp4pzibThmQ0+ag37gdov8/zfJ/+nn9V57+m1pE/xGmSvXfLPZeHPXfVlDPpoH+ywphWh4ho0kgI4ozB2TLv6NF8VH/UXtqYnHoXbQt55bQLQXn/Nv1H96pTxgpTn496T/3vNv1XxbyoXCKMx/qZTfoNypT/D7Hzpb/08/rv/L0305F9B/XY+Xqv0nsvTjqv0VQz3ZeD/Yf11Go//B7z1n2Hv8mEY7rm1gcehfnnPcqoVvc37ls139Zxivqv/3Wk/6Tum86yv5D3inOwVAvDwX9RmU6CeS4xvJ/+nn9V57+O7aI/uN6rFz9N4e9F0f9dwTUszWg/wS+c2XVf1xHof7D+475N4sofjH7L8vSQfvvlBK6ZZJz/u36j7DhGJ3inLae9J973u36zzY/QXHOhHp5Nui3rPn/HJDjRZb/08/rv/L034eK6D+ux8rVf1n2Xhz13zlQzy5aD/Zf1jzj99wpDt4Dws9E8m/Q4xi5icXBs1cU59ISukXgvo6i6x94fwjFuWI96T+puwCi7D/kneJcDfXyWtBvVKZZkOOXLP+nn9d/5em/m4vov6x5rlT/zWPvxVH/fRrq2ZdA/0l963F5hIxs6x+LIWyieab4eI/HRJCllN0adY8H4qawYvOWtBZd7BtP41k6+I2n24voxGbLu7pcPze2/xn3UOA3oKawsJFB/b55NYXJA79TNQXC6Hk64J7HwjTu9fnNVOIBv8tp+xZLLiKt2RCHzhc0ReSH3w/9cYl+UuC7E9ZvAxX71tQDRTBiWoRzCuPX9m0gyfLmvM1meJC3h0vIX+Ib15K8Y/npdGdaeKc4T0D/8RTYIdQWcJ7+T5b/06+YnYLlLfCtjD47pQNwFiAfzLsTsDrKO8S8yU7h31VohOc/gp3Cv9FAsibsus3QXmfEzt+by97Dbzu0WfgvBG75599NaWeYdZk8A/XsT2CnuB8D9GNqi5DRbJARxcHvsEnZH/x7loQD9/VxO8L23U6K888iOgu/M0t8Y3+LdoKEbivW3+YBI4VNAYycZ11fFli+S4rfXp/GwiTr1TTGF/+er81Gw+8sov0zl4WNDOS+QTiX4bbZOjZbjp7R/pkXkRZ+V5z6mqaI/BoxjtlAE9X/CvSTbdhP8rlcWz85ughGTItwTmP8oizr8Y13zhv/dizyNq6E/KW+Ny7FO5afTneWhXeKs8nUATltZp5RV84GOU61/J9+xewf4e+m5bAPpvK2fbMN7RRHeQ/q/8n+4d8Fa4TnKVMH4vLvdZGsCTve/1nsO1/z2Hv4na+8hf9CIGtrtDHMuky2hHpG9Uiyn8pHyGgmyIjizAUZCXwvM7TNfxMOHDMTDv6tbJz/pjhzi+gszRvZAjjfRO+inSD1Tceo/jYEjBSG9g/nWdeXN8wEWYvl//g9ULwHTkq3Ul6UNvnR1uHfhW2B5wmAezYLk5y3nM1wczsSbbTZEEbPk41rmxPk30G21WWeH9bl7Uv0vwJzeZ1ox1Gfwfck4Xhj5xL2D7cJpzN+UZY43prunrc2G298/hF527OE/AVs8jYh3gfpHrJ/Zlh4pzj7Qb90ANg3VG44Dltl+T/9itk/WN4C+jZnm+8LLXm3AVZHeQ/qa8n+oXzwTBw994D9w+0GkjVh122G7FTEzt+bw97DuY2chf9CIDPWoLRDhlmXycFQz1aB/SM9BuAymgIyojj4zW6pb6zz/odw4Liayr+JxaF3GyHOCSXsH7IFcJ6E2w6S8w18vov8uE+Cj0mbLTzr+nIb2D/0/6nwzjQWJqlbo+Z/0NaZzPhqYTySO4OFjQSZFBzjnsFwk38mYCQeZkAYPY8xrq1sKc4EiMP3MvP8cC/z+SX6X+dzsmFPN7ZJPkeC4w2Kc2EJ+4e372mMX5Ql6hsB/ddp443KZpqFtw+XkL/AmLBTUvfzu6onW3inOJdCv3Q52Dd8DVv//wbL/+lXzP7B8haw5XM2e3euJe8cYHWU96C5frJ/KB+c66Xn68H+4X20bf6Z+i/Ezt+byd7Dvn2Ohf9CUJ+xPuWny+RKqGc3gP0j1U/NiZDRBJARxZkBMpK6c5/3P4QDx9VU/k0sDr2LewtvLmH/kC1AfKNtgXaC1HxX1D4ZXH+07YnhPOv6cjjYP6NMeBbemcjCJPeAU16UNvkpvxbgYSKETQS85E5mYZLzoZMZbvLjuh3xMBnwSLUHfh+ALW8BWeRR7vQr1nfhPk+B/roN22U5eHDtWuKcvxCfOdT1bzpM16Zb+X7A1mDoHJDkWDdqjIRjXY9ZHjN+IwbXGCje5JhgtI3fpcYGUXoXy5D6o4kWmTXHTGaTAI9An5/DPcl4ZvW3YMNOdJ9vW4blVwAclF8jxPnQtIG4zxts2Kej3TGehUnaHZRXwHhAu4P4GQ9h9DwGMAr0d202W5XyxvuLqL41RfDRCHH+WcI2H2ORAT2jTWjTU+tzXo94RhtEyj6kOkFj9YkWWUjbKQ7TbcP+c3iEjBshzhsl5ttK9cU4D4vjW4n6IzRv24ZzWSQzwm+bR22cVlxmsyJkhnWcZIV3TM5kcsya8FkMC33Pj6eh4wvJKC80hm/DORQ+P4zrMevu/Sghez4fM4XJDveN4pzVePe8FdUvlB/aQdiHxqnvbA2G2gTIW4N5b2vjnyor1xzaLI2BvS9Fm2X8tAHMVObDgsHlgX3wFJY2vbM1hE9haUfN6bvfZ9M26BuGwxkfcywYJ5XA6L5eteVkeB+8xkvlM8HCO8WZDvbqTPOM7WsUyLHb8n/6lTt3I7DOm8O5eL6HGvMOAaujvAet8dO6A+WD+3/puQvaGt+vQLIutlfb9t549l4rxJlr4b8QyKy7UNrzGGZdJnOgnlE9kpwfnhsho4kgI4qDc/8T2HsUfzrEoXJqYnHo3UaIUyihW9zb7Xb9x9c5UP9tv570n9SYheu/SRbeKc4uUC93A/3G7RD9/0Mt/6ef13/l6b9Diug/rsfK1X8T2Xtx1H97Qj07FPTfKCFMcyNkhOuutjNVUeujqP+oPRVbH6U4K0roFvf2r13/ETbbHf6960n/SY2puP4bZeGd4hwH9fIE0G987VT//2zL/+nn9V95+u+sIvqP67Fy9d8E9l4c9d/JUM/OXg/2H9dRqP/w7pWseab4eBd6FmQptebC58ZmWXDz++5s60k0Fke9TTw1sTg4V0BxPlBEJzZb3tXlusXY/mfbHgZcX8e5Y6k78qP2vVB+uN5hm//HdRrbmtv6nP8nHmz7enF/7PSItMZDHKpXTUHpufBPlOgnnbcJsz8Wz34UgqH7g3E/+rUl5j/5nmHb3DPfMys0t9hm4822nkVxbighf4m5f8l5VSw/ne5EC+8U5wvQf9wEdgiVG+qhb1n+T79idgqWt8Bcfs42lz/bkjfe6eUo70F7MclO4edQcR3hdrBTeF9KssbzidQnIXb+3nT2nq0PRv4LgYxdTGnPZph1mXwZ6tm3wE6R6qdmRcgI1z/4vQFCex2s/Y9tXYOP//h6NI7/vl9EZ+G+INx7atuDKHUeJWofDp5P598WarbwjHtRdHsYbcJHwTtZFqb5miDEF+VFaZOf8sN9BFkIywJecieysLjt65VsDxMYHlveArLIVzrHiPuvpPbrVvtNFIl5XiE+c6jrXe+P5bp1EpNVvfcgRo2R8HshScOMd7zifgGKNzEmGG1jYSk7O0qHYRmSbs9aZNYcM5lNADwC/WffXtOxLC/dv78I9mDWfb75DMuvADgoP5yjOXX6QNyXDTbsH7EPH8vCJPtwyitgPGAfnjXPYyGMnnGvqUDfkbfZfZR3sXNgnA9cQ2gwZVFqrynKgJ7RvrLpqfU5R0Y8Y38uZWtlTVo07s1aZCHd5ztMN4/95/AIGeN+5bFF6lA5fTHOadbjfJLAHGge54VIZoTfNie5aQmZzYiQGdZxfq6hIRh6HiNrwrkOoL2m68oQ4o8EfyGoT1uh/LBPx/4gTv1AazC0f0PeGoLB6xRoKwnINYf9b2Ng7xew/505fQAz1R3aN5ll72Gfw+9Dwn2Tk1jadZtrz+UH7Rsdzviwre3PLYHRfb3K52R4H3ynHN8zi7xTnDawvTrMM7av0SDH7S3/p1+5Y3rnd4/k+us7v59jliVvnDd2lPeg+Viaj6Z8cP8CPW8HbY3vYSdZE3a8n7DYNzTGsvfwLoKZFv4LgezcL993r8ukC+oZ1SPJecOZETLKgowozkSQLd8jT/Fx3ziVE/+uHu5LoTi7ldAt7m1Qu/4rdtZvr/Wk/6Tsb67/Jlh4pzj7Q708EPRb1vx/LMix1/J/+nn9V57+W1VE/3E9Vq7+y7L34qj/DoF61gv6b7QQppkRMsL1OH5fnA6z3YdC/8f1Hqk9f1H7RhA3hZHsUCfTe/yMEtrjfN8QvdsIcd5RRCc2W97V5Tq3tf/ZtraD6w44D7C+7kPBuSvbXA7OudnmT9fnXI7trhl6xn1DUyPSGgtx+DnsYvMa55foJ53PKZt9Q9RX8XkEXKemOBeWmEeYDv5CYJ9H4HuJJOeVOG9jGR7k7cMl5C8xjyNZ17H8dLpZC+8U51LoPy4HO4TaAs6332D5P/2K2SlY3gL7FHLYV/IzwJg32hOO8h7UT5Odwr8ZhGe/rwc7he+3WTdvYlzbXZS29yaz91ohzgwL/4VA1ibg5691mVwJ9ewGsFOk5tZmRMgI5/8oDs7dS40bswwPXz8rtp5C7w66V6/EegrZArb9xWgnCOi2ov3tdMC47nwxYOQ847piC/CL87SjWJikHUl5Udr87IhtbxPeB4j2T5aFxW2/k9A6btE7A7KysshXOsbGtXQBXdVe6VkhHHdLzHMI8TnoPKvrfUNc10xgsqr3fpKoMRLl5zF7zFGYo85YUbxsTDDa5hykbLmovgLLkPrQURaZ1eMOnEpkNh7wSNxvo/ndiOWl7ajnwe4WOFfdnmH5FQAH5dcIcf42cyDunw22FngHbaUJLExynh/740JgvyeZ+EH7iZ5xf5aEzZAJhu4D53pNxyF91hREr1dQnP+UuT8LZUDPWePivEAWZCDV5sq5K5p4Rt2eFcJDdYLmF/icN+oprONZeCaMUvO3lBelnWXywf4H5+Wl7mGIams+74E64jDvPI6X6VdsvEEYpNoN9lX0K4YnK4sn1wp4MC+p9hhVD/z98v5++Up+tjlP2xkBf1d7+jD7++WH4vn/9s4utLKriuMnaeZOJt/JxDGMU3qTzsTpTJK5yWSSmamWK9IHwY+CUJFSK0ytoBUR+yAiWCkoKBQdFCl+YEVoLUihfVAEFX1qQVGKUhStCFKrL86LKCIiJzn/ye+urH3OTT3r5obOebnn7rP2WR97n7XXXnvttVN614tZWHBkdqTPZMb5kfWl5vOr9dt26A2YN+05D/zTmPtdLGhjnADn8Z5t1Kyfh9J+IXyc93hzP9pLAXP7854NL9zMW2LXkiwfXEt6ayF/b+7nzaHyNlk0ZZHfqo238PK72PiKSJtN7a953oIjiwCbpBVle+V87CUW5F0l/YXvEp3qP16sDcfHiP4TpJ/d3DRWPzM3zd0VMjuTkBn7uGTF2MMA3taC4knPM3ZBMrM56BnTeW+FzFLxEzwX1cYiRPqjUnrhVA9xZyW4A9ZT1702bRb/hY9t+sE9tqld96CuL4uJETz36oseG1/PeGLBfKSETvoI2K8C/DWl/eoo6JFtxDUP63uPtJvow2lnu30olNkC6In2jysGbsnIJ0YWq1f26l9rgp6I/hPlJ6M+Ga7tvRe2Yjdt3LvnRxcMaQgYs0p95mcd3PXJYuNCjnu5C1ksO/RE7UloJmSx7OCuURZuzlJPFisOPVH50poJWaw4uGuUxZZ+O9eFLM459ATkFy6VBc+c3gvNZ/uA5mFzXw/uzS0d1+pCFi2HnqizsZsJWbQc3PXJYntP4WoXslh16InK19xMyKIsx3QZzb3IMd2soHnY3NeDe2NrH8laF7JYc+hZ67EshG+vNK8cQJpbfUDzsLmvB/fGB3Lc57uQxXmHnvM9lsV5B3eNsnggx73ehSzWHXrWeyyLdQd3jePqll10oQtZXHDoudBjWQjfXmluHUCazx1Ams8eQJqXDyDNKweQ5oP4DfZD3xg29/Xg3riS497oQhYbDj0bPZaF8L0WaG4dQJpXDiDNyweQ5vUDSHM/yDlfz1go7qfORNKzev9e90qKhlHcNyGzzdpp3I7XFa5N4LpYP65Vr7/o/8VQ3KtX8vderp+nLf/b7cW7tH572eHpTcX9QM3yvB3vHQAelQ/hfvzMDqzgJA99t6I9Xye+VNyTdltvw9SbAMwlh/92Vi//lw09lw3NeZsM4juP6Fvd9Ot8HbxZ3N9c/OYy1roq92ptmrJIfblp6Nb/DdAofUn9EKCLStfqhY97gJb6VGYTKCM/uh8s6tkz7qJ0/EC2+8zOTYObMSYnoSeaRdlNWWd7cJ/chnm36jDv7IZ5dypXULN2/tdbpPGQ4aPp0Hi6gsb6+9V6KzK25CJ4zN874vAumGXEFZ8r7vl9TUGOdzjPdXVj5+zHmEzc/TAmv7lkTJas9zomb5p6/Tgmr6Gf3YHxOSrH0qWEjBYgI8Ewp7bNXyh4xsWpnRoGhvkLBXNnhW6pP+ba138jhlfqv7ftk/6Lije3+u/6OIdywbwT/fIu6Ddrh+TP73Oe67qh/7rTf+8r0X9Wj3Wr/xZMvX7Uf+9GP7sP+m8qiKZLCRmNQEaCOZ3tyNbGBQue+k/t1DAwtDkF80CFbjldO/++/lsyvFL/fWif9F/9vPv6b8rhXTAfRb/8GPSb2nQBcnzYea7rhv7rTv99ukT/WT3Wrf4bMfX6Uf89hH72MPRflF/hUkJGPCtYMGcgW7uvSPBl9p89c5n23+cqdMtC7fz7+s+esUD994V90n/18+7rv02Hd8F8Ef3yKvSb2pR5xR93nuu6of+603/fKtF/Vo91q/+WTL1+1H9fQT97fB/sP6ujqP+Yc005YT1fK/PFRp2XkPK10m61vinqZNWTL5J6WzzZcwdUlz7R75XoxFGnbt6uj4xv33NfPveAz5uyft6Xz3wCp0xZ0H7trs8daBb33rkD2hM2kKXPHeC+/72cO/DjinEyYD/2Voym7PZu9pr/rIRGvkt0zht+U+cOzNfPm7uPXm0z7/D2XM/nkq3zQby75w4sOLwL5hcYP34JO0TtxlwiLznPdZXZKWzv1/q5A3+AnZLaY73XcwcWTb1+PHfgBfSzl2CnNINoui0hI54z5J07EDV3sOOPzcmTw6j9GwZGdZm35+USncU8U+KbeXhpJ0T5ilJ5eE+DRptTYNThmTmTvNz4tH+a4CuqHVP2j/BV5aRlfIaXF3k/z4sSD955Uco7O5DtzvcqGNpINu+Rxce8R/+pGH9rz9VRnLukb0Njhs3NNgQYKfCU/WNtQmuTU5bMjRRgA6x7vKlt5h3eGiW8Bdnk65H2D9svf+8Rh/fr+ffO7shpvLhnTk7m0T7hPNdVZv+wvQP0bUfOSbX3aQc3/ZE14e4Ya2X/CA/zL+n+DWd3YK3dIFmLdp55XuZLtTmsvLMPg2zPVW/uc9rQnLfJFPqZ+lHkOPXGhIyYq0YwjBuLyrNsxx+bEyeHUfs3DAxjywRzskRnMXc2/STe2TZR/obUWQmLoNHagKMOzzwvIP8eZoty5i2fNGWRfrRJw5c9R9w7G2o86zwnSr9HTNlw1l/nRUV+DzYeyMMdIIs95x3nGRkB4/Uav8tu6JkHPc366VkN4rNjXarufNNWt1pfV6/PiUnNkRjre9BoZm430ZrKibufNHpz4Sg7O6XD2IbS7ZOOzEb7TGYjoCdg/Nw6D+iYwZWP7+85G4p3jeO25geWjiHAvAhb9Z7ifhx1OIaPmLLIMTzV3ziGe/aI7nkeULN+Gtc8u8/GyLNPNhJ8MP/lAxV27pgjA91X5e7eTx+Z1RWRthbPA2/jP2URPebX+N41jp+HEjKmr/jjFb6rqrGYPs1enHsZ4ANdo1/I7t3xfJKfrJBZlT+f/j7BDma7z8xrFuVWB/y3KBcc9Ugv5nf2W2GchHQ9x4N+GgcmUEZ+dD9Y1DsBmWZxct2y0SWrsr1TgnkUPjL1He2bs+cyc8zRu1WH++ZuMe/uma+9iBu05xGKj1MOjVcraKy/X23HDdbPe+f5eDZumrwL5quwvR6Dv1n9ZRZyfNJ5rqvbOX3E2Ur0idqc/MRNv3FNuDv8sfJH2zOAGPvxBL41u2YsWTP3v/x3ZecQ2b0NXGtedPhvZ7G+X3seQt4mX0c/exLzj2NBNC0mZDQJGQmGPmEbfyf4BcConRoGhvF3gnm6QrfUb4P6+m/K8Er99+w+6b8o+9vqv2MO74L5AfrlD6HfrB2SP3/eea7rhv7rTv89V6L/rB7rVv9Nmnr9qP9+hH72PPTfbBBNiwkZTUFGNuaOZzXQf2bjLSLjvVNxI6RbZZIddbLqyRal3hZPNm5ademT+k2JThx16ubt+t7COUK/EH0i1k8SGY+WWg8UPvpEPF8OfW7zpmy/fTnN4p7+At0zbmgh8a5jgLExcGV+jZcrxsnafcpF3JDGKutH4Dq1YP5W4UewsVSeH0EyYNxelF/J8nbM0EPerlXIP8KPE9nX2X75e0cc3gXzD4wf/4Qd0iye09/eWNr9XFeZnRJ9jh3HSrsHwIsRrdtO4R4a2i2MX79O39IOrOAkD8m6bK+BV69p6k0A5pTDfzuLtQkWDc15m/wb/Uz9KNK3dioho2OQkWDou58Mosf6+kQH/Xp2PcVb27q+JlnIMLWeYvNOptZO9usccq5X0jYoW1fMv4e5opw+26OmLNKOTJ1LJnxebNN41hnnpF8bS9Rv8U6R34P1h3i4I9aQ9zrH5lp6VBzTq/V5Rvg5gvjsyOdWd9yQ1TXeOkov40lScyThO4g0c+8z18gEN9knNHpz4SgbI6XD2IbS7UcdmY32mcymQE/A+LkVN3Tc4MrH97csheJd47it+YGlYwgwP13agb2zuB9HHY7hU6YscgxP9TeO4Z49onvGDQWMHWuenWvXB9gnGwk+uIZwV4WdO+bIwK7JpPRUM6tdBl37yKyuiLS1uJ+tne32xfZizK/xvWscPw8lZMy50r0lfaibsZh+V84Vm/XzttrLWCvR7/mF7q+Q2a0JmTUhM8lKsIPZ7ni5ZlFudYDihgQ3BfhezO/st8J1Aul6jgf9NA5MoIz86H4w61ynoK0UMe4PQFY2doRrp4L5BHxk6juKG/L2W42Yd6sO44ZGzLt75msv1s3pzyAftzo0fqqCxvr71fa6eVTsOvVL/t5Zh3fBfAa21yPwN0sWc5DjVee5rm7n9AGxUi36RNXepxzc9BvXhLvDHyt/tPAwZ4/uv4Rvza43S9bMIyT/HWm39WxcGPdonnT4b2exvt9Thua8TT6LfnYV84/jQTSdTMiI+1gFQ5+wXX8WfBMwaie735Trz4J5rEK31G+D+vpv1vBK/feNfdJ/Ufa31X/HHd4F8230y+9Av1k7JH/+rPNc1w39153+e6ZE/1k91q3+O2rq9aP+ewL97Fnov7kgmk4mZDQLGQmGvimt6dB/pjpc74nS21b/6v9x0KgyyY46WfVsjD7tcRs3pLr0Sf2kRCeOOnXzdl0pJiP0C9EnYv0kkbGTVfvE6RPxfDn0uXn+02YQ3d34crw9+Lpn3FAz8a7jgLFrwGV+jV9VjJO1+5SLuCGNVdaPMA8aBfPrCj/CAv63M9+PYGOJIveXWt7UNiMOb7+rkH+EHyfSr8D2a2e+X1Ywf8T48ScnLoj+9muvMm6I7R0Qp9DiWGlzZxE37YmacHeM07JThIf7aXT/d9gpNt5Gsi7L0eXVa5p6Xuwu+W9nsTaBzfWXt8mf0c+uwU7pVX6fZnHP8V4w9N0fDaLH+vpEB/16dj3FW9sSzL8q1lPsvrzU2kmAbisdbxdAo7cvvGxdMf8eZB9No86cKYvcN2TtQRvHxPXFOZTNgV79zpqyyP6Xsn8Z2yQeZlGme9o/RxPvGgeMPTvC4uPZERPL27+p8bd2X3Zh/9gcFHZuznj/mRIa+S7ROWf4pSz5/QXM09z8GmqbOYe3uQr5B/hT1iLnqGy//L3HHd4Fc/PyjpxuKe7phzkBOa44z3WV2T/B8zJ3P98RB3cTtNaEu0PXy/4RHu4D1/3y8g6s4CQPu47FeSNpt/XsWhLz7Y04/LezevlP5XITvrxNFtDP1I8ix6mRhIzGISO7h7uX/hfRwTmz2r9hYOj/FsxGic7KeZMtQH+TtR0ifcUnsk5+9Z/7i1XGGGjLc95f/lp0KH4Pg6hz2JTlfDWC+BIuvVv/hY9+lMMoOwx69evFTUfFA6TiphlfJR68PJG0f1J7wGn/TEMuHr4hwLy9YvydBq52cd/6f67C/pkp3mX3gE+DRsHcVWH/zOB/O9tpb8r3ui0F3g7XzVurteHxprY57PB2d4X8ZwJoDOJ9lX3P5psm74K5B+PSvbBvrM8of/6g81xXmf3D9g7Yz7xl/7wOdLaBh7i5r7Mm3KvELftHeFQ+hPsPw/4RnORhx2P6+0m7rTdl6nnrLZG2RmpuKXx5m7wf/exB2D9R49TRhIxo/3jxk9E53/Ru0eHFP1n7x1tbf6jC/pEtwHg2azsE6bbSdaIZ0Eh+RaPlOe8vM7B/rNxGsx37gfFvUb514dK79Z9rXWOgTWWj4EfPGqYsp3swiO6GoVv/B0GjbQ/aRDcVvwOoY991GDA2l4LFR//D53vtf1i9coV2nMYM0cbvTTCPVtg/1iYcNfxSltyfUXt7F7ad5c3OEcjbl/fB/xbZ19l++XvHHN4F8xjGpa/BvuH3rOdPOc91ldk/bO8AfdvieKf2nnFwMx9KTbh3xVrTHqCvV/ffhf2T8gmI9vy/7NSyXC7e2CKYaYf/dlYv/3buM2Noztvkm+hnT8H+GQ2iaToho8OQEeeoomc8iJ4xQw99A/nFMaphYFR3CDDPVNg/sgUYd6K6wXHypeMt9x/Q7tGv5TnvL98f3r6nH2UYdY6Yskj7J+XrpL60cqZPiPaPtYmGwXe7ZrpTdtsYaLQxSrTbaP+MJd41CBj160YC3xBgnqsYf2v/Jgv7Z6J4l8YMykI0CubnFfbPBP63s5325jslgwnwFrV/0fKmtjni8PZChfwnAmiMnGuy/fL3NhzeBfMixqXfwr5Rux2GHF9xnusqs3/Y3lH7kqZBZzvr1LPCPQNaa8LdMdbK/hEe+uF0/xfYP6/GZ+rVGzP1JgAz6fDfzurlP7WPjT7Y36OfvQL7p1d5UuwcgDEyXH+I8slae0B0cM4sOhoGRnWHAHOtwv6RLUBfBPnUb4BuKx1vJ/BrfSejDs95f3lHoVxo/ww5dYbAV5RuFS69244rtH849x8EP6J7xJRFzgdS/jjaOp4tp3vaP6OJdw0DRv2ukcA3RJiV7d/U+Fu7TVjYP5zbt7NyG22khEa+S3QOGn4py3HwFuUDsbypbQYd3qYq5B8xJ4zkne2Xv9fzPQrmdSs7cnp9cU9dSftn0Xmuq8z+YXsHxBu0PH/fpIObdkpNuDvGf9k/wsO17ut7sFZ2YK2PQrIm7RovSLutN2rq0bcx4fDfzmJtjUlDc94mx9HP1I8ix6mJhIyGIRfBUH9HrcfZ8Ud0CB9jSxoGhvsWBLNSorMmsk77QL/Wdoj0d6XiZLj+qDKuZVme8/4yNrAjF/7mF+0RWzaEsgHnfjDr9FnY517ZqINn2imzcUH2ffnFMaDOXHL5O2SvHHJoG8Jz+j4H6qdllfzelO2WwbQjn/8BYZFgg3HRDQA=","debug_symbols":"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nZob1am5UZ2aG9WpuVGdmhvVqblRnZob1am5UZ2aG9WpuVGdmhvVqblRnZob1am5UZ2aG9WpuVGdmhvVqblRnZob1am5UZ2aG9WpuVFhowZH3cJnPm1v4TMft7fwmc/bW/jMB+4tfOYT9xY+85F7C5/5zL2Fz3zo3sLnPnWpEVK38LlPXWqI1C187lOXGiN1C5/71KUGSd3C5z51qVFSt/C5T11qmNQtOO5TlxondQuO+9SlBkrdguM+damRUrfguE9daqjULTjuU5caK3ULn/vUpQZL3cLnPnWp0VK38LlPXWq41C187lOXGi91C5/71KUGTN3C5z51qRFTt/C5T11qyNQtfO5TlxozdQuf+9SlBk3dwuc+dalRU7fwuU9datjULXzuU5caN3ULn/vUpQZO3cLnPnWpkVO38LlPXWro1C187lOXGjt1C5/71KUGT93C5z51qdFTt/C5T11q+NQtfO5Tlxo/dQuf+9SlBlDdwuc+dakRVLfwuU9dagjVLXzuU5caQ3ULn/vUpQZR3cLnPnWpUVS38LlPXWoY1S187lOXGkd1C5/71KUGUt3C5z51qZFUt/C5T11qKNUtfO5TlxpLdQuf+9SlBlPdwuc+danRVLfwqU/dwM2mCtxsqsDNpgrcbKqwUZ+6gZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VudlUkZtNFbnZVJGbTRU36lM3crOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kSN5sqcbOpEjebKnGzqdJGfeombjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNlXiZlMlbjZV4mZTJW42VeJmUyVuNpVws6mEm00l3Gwq4WZTyUZ96go3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsqszNpsrcbKrMzabK3GyqvFGfupmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNVbjZVIWbTVW42VSFm01VNupTt3CzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpKjebqnKzqSo3m6pys6nqRn3qVm42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV42ZTNW42VeNmUzVuNlXbqE/dxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzabq3Gyqzs2m6txsqs7Npuob9anbudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdWp2VRxo2ZT3cJnPnVv4TOfurfwmU/dW/jMp+4tfOZT9xY+86l7C5/51L2Fz3zq3sLnPnWp2VS38LlPXWo21S187lOXmk11C5/71KVmU93C5z51qdlUt/C5T11qNtUtfO5Tl5pNdQuf+9SlZlPdwuc+danZVLfwuU9dajbVLXzuU5eaTXULn/vUpWZT3cLnPnWp2VS38LlPXWo21S187lOXmk11C5/71KVmU93C5z51qdlUt/C5T11qNtUtfO5Tl5pNdQuf+9SlZlPdwuc+danZVLfwuU9dajbVLXzuU5eaTXULn/vUpWZT3cLnPnWp2VS38LlPXWo21S187lOXmk11C5/71KVmU93C5z51qdlUt/C5T11qNtUtfO5Tl5pNdQuf+9SlZlPdwuc+danZVLfwuU9dajbVLXzuU5eaTXULn/vUpWZT3cLnPnWp2VS38LlPXWo21S187lOXmk11C5/71KVmU93C5z51qdlUt/C5T11qNtUtfO5Tl5pNdQuf+9SlZlPdwuc+danZVLfwqU/dwM2mCtxsqsDNpgrcbKqwUZ+6gZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VuNlUgZtNFbjZVIGbTRW42VSBm00VudlUkZtNFbnZVJGbTRU36lM3crOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqcrOpIjebKnKzqSI3mypys6kiN5sqItORssS/fzbLUfjA+/6Z8IF3npzbI/xSD8IH3nnOhA+8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6sacVsKmTo9I2JjTSpsxp5U2Y04rbWItYWNOK2HzxUckbMxpJWzG+IiErTktbM74iIStOS1s1viIhK05LWze+IiErTktbOb4iIStOS1snvmIhK05LWym+YiErTktbK75iIStOS1stvmIhK05LWy++YiErTktbMb5iIStOS1szvmIhK05LWzW+YiErTktbN75iIStOS1sPvqIhK05LXD2+oCErTktcP76gIStOS1wBvuAhK05LXAO+4CErTktcBb7gIStOS1wHvuAhK05LXAm+4CErTktcC77gIStOS1wjvuAhK05LWuM+GSNEZ+sMeKTNUZ8ssaIT9YY8ckaIz5ZY8Qna4z4ZI0Rn6wx4pM1RnyyxohP1hjxyRojPlljxCdrjPhkjRGfrDHikzVGfLLGiE/WGPHJGiM+WWPEJ2uM+GSNEZ+sMeKTNUZ8ssaIT9YY8ckaIz5ZY8Qna4z4ZI0Rn6wx4pM1RnyyxohP1hjxyRojPlljxCdrjPhkjRGfrDHikzVGvFhjxIs1RrxYY8SLNUa8bGItYWNOS6wx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiM+W2PEZ2uM+GyNEZ+tMeLzJtYSNua0sjVGfLbGiM/WGPHZGiM+W2PEZ2uM+GyNEZ+tMeKzNUZ8tsaIz9YY8dkaIz5bY8Rna4z4bI0Rn60x4rM1Rny2xojP1hjx2RojPltjxGdrjPhsjRGfrTHiszVGfLbGiM/WGPHZGiM+rwTU7jX+/dO9/vPffqW70KF0It2VUMu9tUe6vR6ku9B2dSbdhTar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liqneDlXKqffCi1VTr8VWqqcfiu0VDn9Vmipcvqt0ErlDH4rtFQ5/VZoqXL6rdBS5fRboaXKKV7Olcrpt0JLldNvhZYqp98KLVVOvxVaqpx+K7RSOaPfCi1VTr8VWqqcfiu0VDm976QpZ5b4989mOSqn951LldOdLU85P44Q78md7VLldGe7VDnd2S5VTv9751LlFC/nSuX0vpOmnJ8n8/XkfedS5fS/dy5VTv9751Ll9Fuhlcopfiu0VDn9Vmipcvqt0FLl9FuhpcopXs6Vyum3QkuV02+Fliqn3wrNLec3/uX+/HJJz18mH/Sv5fRboaXK6bdCK5Uz+63QUuX0W6Glyum3QkuV02+FliqneDlpypkfP9vrdlBOvxVaqpx+K7RUOf1WaKly+q3QUuX0W6GVyln8VmipcvqtEGg5XyXymx74EvntjXqJ+nM+tITwoUQxlvT66fiPn34VSbxI+EXym5bJRXrVKB9sdn57Al8ivxGBL5HfcsCXyG8u0EtU/TYCvkR+wzC3RDk/friGgxL5DQN8ifyGAb5E4iVCL5HfLsCXyG8X4EvktwvwJfLbBfgS+e0Ceoma3y7Al8hvF+BL5LcL8CXy24UfleglpLiQOkJ6p64kpPfTSkJ616skpPemSkJ6B6kjZPc+T0lI78aUhPSeSUlI72yUhBQXUkdI72x+EfIljtlupcanOK1++K/sFok8A0ly8N+Z2X5FX0qzHYu+lGZ7FmUpy7aZ7Vr0pTTbt+hLabZz0ZfSbO+iL6W4lFpSmu1f9KX0bkdNSu921KT0bkdNSu92tKQM3u2oSendjpqU3u2oSendjpqU4lJqSendjpqU3u2oSendjpqU3u2oSendjpaU0bsdNSm921GT0rsdNSm921GTUlxKLSm921GT0rsdNSm921GT0rsdNSm929GSMnm3oyaldztqUnq3oyaldztqUopLqSWldztqUnq3oyaldztqUnq3oyaldztaUop3O2pSerejJqV3O2pSerejJqW4lFpSerejJqV3O2pSerejJqV3O2pSerejJWX2bkdNSu921KT0bkdNSu921KQUl1JLSu921KT0bkdNSu921KT0bkdNSu92tKQs3u2oSendjpqU3u2oSendjpqU4lJqSendjpqU3u2oSendjpqU3u2oSendjpaU1bsdNSm921GT0rsdNSm921GTUlxKLSm921GT0rsdNSm921GT0rsdNSm929GSsnm3oyaldztqUnq3oyaldztqUopLqSWldztqUnq3oyaldztqUnq3oyaldztaUnbvdtSk9G5HTUrvdtSk9G5HTUpxKbWk9G5HTUrvdtSk9G5HTUrvdtSk9G5HScqwebejJqV3O2pSerejJqV3O2pSikupJaV3O2pSerejJqV3O2pSerejJqV3O1pSBu921KT0bkdNSu921KT0bkdNSnEptaT0bkdNSu921KT0bkdNSu921KT0bkdLyujdjpqU3u2oSendjpqU3u2oSSkupZaU3u2oSendjpqU3u2oSendjpqU3u1oSZm821GT0rsdNSm921GT0rsdNSnFpdSS0rsdNSm921GT0rsdNSm921GT0rsdLSnFux01Kb3bUZPSux01Kb3bUZNSXEotKb3bUZPSux01Kb3bUZPSux01Kb3b0ZIye7ejJqWJbueVromO5JWuia7hla7YSteE+36la8Ihv9I14WJf6Zpwmq90TbjBZ7o25sG/0rXlqmzMVX+lS+uqXikIfwq07ueVAq2jeaVA61JeKdA6j1cKtG7imQLvDOVXCrSn/isF2pP8lQL/6cw7I/eVAv/pzDsT9pUC/+nMOwP1lQL/6cw78/OVAv/pzDvj8pUC/+nMO9PxlQL/6Yw9wzBIeKWQyz9S+MO/1GJPGhyRMPTJPyJhaJ8wIGHs2XojEob2ICMShnYsIxKG9jcjEhZrCUN7pxEJW3Na2FPORiRszWlhTwzTTzhiz/UakbAxpxWxZ2SNSNiY04qbWEvYmNOK2LObRiRszGlF7DlIIxK25rSwZwqNSNia08KezzMiYWtOC3vWzYiErTkt7LkxIxK25rSwZ7CMSNia08KeZzIiYWtOC3s2yIiErTkt7DkbIxK25rSwZ1aMSNia08Ke/zAiYWtOC3uWwoiErTkt7LkEIxK25rSwGf8jErbmtLB5+SMStua0sNnzIxK25rSwOe4jErbmtLCZ6CMStua0sPniIxK25rSwWd0jErbmtLC51yMStua0sBnSIxK25rSwWc8jErbmtLB5zyMStua0sJnPIxK25rSwuc8jErbmtLDZzyMStua0sPnPIxK25rSwedEjErbmtLBZ1CMStua0sDnXIxK25rSwGdojErbmtLD53CMStua0sNnfIxK25rSwueIjErbmtLCZ5SMS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d/JqDvcB9xTu5NUc7uTVHO7k1Rzu5NUc7uTVFO4reTWHO3k1hzt5NYc7eTWH+4B7Cnfyag538moOd/JqDnfyag538moK9428msOdvJrDnbz6bw/yxYZMOWczYDNlQzabsyE/zdmQceZsyCFzNmSFKZuBn5+zwXPP2eCL52zwxXM2ow2b6zx//fR1PSfT9nG6kWn7eNfItH3caGTaPv4yMm0fxxiYdu/jASPT9nF1kWn7+LTItH2cV2TaYTWtlZfarbzUbuWldisvtVt5qcPKSx1WXuqw8lKHlZc6htW0Vl7qsPJSh5WXOqy81GHlpZ5WXupp5aWeVl6q0bb7yLTDalorL9Von3pkWisv1Wh3eGRaKy/VaE92ZForL9VoJ3RkWisv1Wj/cWRaKy/VaNdvZForL9Vor21kWisv1WiHa2RaKy/VaF9pZForL9VoN2dkWisv1WgPZWRaKy/VaOdiZFonL7U32i8YmdbJS+2NdulFpnXyUvtjWE3r5KX2RjvSItM6eam90T6wyLRWXqrR7qvItFZeqtGep8i0Vl6q0U6jyLRWXqrR/p7ItFZeqtGumsi0Vl6q0V6WyLRWXqrRDpLItFZeqtG+jci0Vl6q0W6JyLRWXqrRHoXItFZeqtHOgMi0Vl6q0fv4kWmtvFSjN+wj01p5qUbvzEemtfJSjd6Cj0xr5aUavdcemdbKSzV6Uz0yrZWXsnr3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd693y3evd8t3r3fLd69/ywevf8sHr3/LB69/ywevf8eAyraZ281GH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu+WH17vlh9e75YfXu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rZOXOh9OXup8OHmp8+Hkpc4+2+4j0/bZMR+a1spL9dmnHprWykv12R0emtbKS/XZkx2a1spL9dkJHZrWykv12X8cmtbKS/XZ9Rua1spL9dlrG5rWykv12eEamtbKS/XZVxqa1spL9dnNGZrWykv12UMZmtbKS/XZuRia1spL9dkvGJrWykv12aUXmtbKS/XZGxea1spL9dmRFprWykv12QcWmtbKS/XZfRWa1spL9dnzFJrWykv12WkUmtbKS/XZ3xOa1spL9dlVE5rWykv12csSmtbKS/XZQRKa1spL9dm3EZrWykv12S0RmtbKS/XZoxCa1spL9dkZEJrWykv1eR8/NK2Vl+rzhn1oWisv1eed+dC0Vl6qz1vwoWmtvFSf99pD01p5qT5vqoemtfJSVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnl9W755fVu+eX1bvnl9W755fj2E1rZOXuqzePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb/6vI29PB6Pr0Nfbz77J+dYxvmacNm349s5/nLC8/r85PXNJ+9j/fWz+9hmCrXxCG0VauNruirU5930tgq18Y9tFWrjedsq1Mant1VooFBxhdp0y20VatOHt1WITqG6QnQKmQqdryPv1z5TiE6huEJ99oe0VYhOobpCdAqZCj2/FDpmCtEpVFdooFBxhegUqitEp1BdITqF6grRKWQqtL9+12c/Zr/r02cnVVeF+uzRaqsQnUJ1hegUqitEp1BdoYFCxRWiU6iuEJ1CdYXoFKorRKdQXSE6heIK9dkn2VYhOoXqCtEpVFeITqG6QgOFiitEp1BdITqF6grRKVRXiE6hukJ0CsUV6rNXua1CdArVFaJTqK4QnUJ1hQYKFVeITqG6QnQK1RWiU6iuEJ1CdYXoFIordNIpVFeITqG6QnQK1RWiU6iu0ECh4grRKVRXiE6hukKueUj8kuLlmlrUHF2zhZqjawJQc3T16WqOA44Sjq6eV83R1ZmqObp+J6Xm6PrNkZojeUbA8Y//Nhz/8ZeNP/7b5BkNR/KMhiN5RsNxwPEf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jKcHjpDx9MDvvzs4Ku8QSyYzIDMh4+mBI2Q8PXCEjKcHjpDx9MARMp4eOECm8gasZDKeHjhCBg88I4MHnpEZkJmQwQPPyOCBZ2TwwDMyeOAZGTzwhEzlnV/JZPDAMzJ44BkZPPCMzIDMhAweeEYGDzwjgweekcEDz8jggSdkKu/8SiaDB56RwQPPyOCBZ2QGZCZk8MAzMnjgGRk88IwMHnhGBg88IVN551cymb/bz2j/cu3427csqc+/3/z8x83P/7z5+c+bn/+69/n/9k066vMvNz//evPz3/z+/ds3vGj/IvXYK9+/kfNXvn8j5698/0bOX/n+DfzV2175/g2c/6h8/0bOX/n+jZy/8v0bOX/l+zdy/sr3b6B/OCrfv5HzV75/I+evfP9Gzl/5/o2cv/L9Gzj/s/L9Gzl/5fs3cv7K92/k/JXv38j5b37/Pm9+/z5vfv8+b37/Pm9+/z5vfv+eN79/z5vfv+fN79/z5vfv3/4Su/r8N79/z5vfv+fN79/z5vfvefP797r5/Xvd/P69bn7/Xje/f//2V6DV57/5/Xvd/P69bn7/Xje/f69737/Px73v3+fj3vfv83Hv+/epeKd0eR1pXY6hPP/73796Kl4TTT3/8+bnP29+/uve51e8cpl6/uXm519vfv7t5ucfNz//ze/fpfL9+/73V59L5fs3cv7K92/k/JXv38D518r37/vfn3yule/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/RvoH9bK92/k/JXv38j5K9+/gfNvle/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/Rs5/83v3+3m9+928/t3u/n9O25+/46b37/j5vfvuPn9q3h/KfX8N79/x83v33Hz+3fc/P4dN79/95vfv/vN79/95vfvfvP7V/H+Uur5b37/7je/f/eb37/7ze/f/eb373Hz+/e4+f173Pz+PW5+/yreX0o9/z/+7/9j7K/zP66H8vyB378SvP+Te/7r3ucXvP+Te/7l5udfb37+7ebnHzc//37z8x83P//N799n5fs38Purz8r3b+D8Z+X7N3L+yvdv5PyV79/A70+ele/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/RvoH87K92/g/Ffl+zdy/sr3b+T8le/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/Rs5/83v3+ve9+/5uPf9ez7uff+ej3vfv+fj3vfv+bj3/Xs+7n3/no9737/n49737/m49/17Pm5+/y43v3+Xm9+/y83v3+Xm96/g/aXc89/8/l1ufv8uN79/l5vfv8vN79/15vfvevP7d735/bve/P4VvL+Ue/6b37/rPe/fj//rf//T//jnf/pP//W//M+P/48//sf/9S//+V//+b/9y6//81//z3//f//Lx8/+Xw=="},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":39}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"return_witnesses":[472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}],"token":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":3,"end":4}],"inputs":[{"start":0,"end":3}],"secret_hash":[{"start":4,"end":5}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[3],"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2bW0/bMBiGnVMPZIUeOLRAWW93105sbHfhYrebtD+ACk2nSkCntkxsf3L3k/ZXquHMH7x1PyCoTmQkLKHYjv29j984TkJSR/xP3s2fo/IB1OmJ2kRq210t9QzG6mbJ6TwTTtcgpwOcOD9uk0lzfRBCc1ytTG1crU6mAAottT2eTPo/O6PLQXzdGV/NOuNh53R8dTmYYsc6FPbU9qx/ft6ZjTv96TSezE4u+tcnp6PZyXT0K74VfaMyJbFoSmTCmA/dwwIE189GaYCr9tFW4oQCTFP1IfR3oI5Mp/7Fm7+ygD6lOy2ZalBHHqyLRSaSDUz7oSYKpgjyAcPjWcbjW8bjWMATiuWVRc7Dbeduf0HVu9CH+hfEcjscVzGjcaFWBGXSqwBHwRIe3zIezzIeV+O5b23LihFTBPkiw+NbxhNYxuNZxpPHmvQYT5q1lu5lcK0tArveDsdVzmhcqBVBmfQqGocNPJ5lPIFlPL5lPK7Gc9/anxUjpgjyZYanaBmPbxlPYBmPZxlPHmv2YzzctSiE/fh8sKbyeB1zmXjkM7bfdZZju0zsMsOAPoUwlkjlu6ulxCfUijQOmfDaVraEx7OMJ7CMx7eMp2gZj8vw4JptkofG7qvYdL6jXsW8F8MQxizAE0wR5CvA88o8Ty+jcXZl3HXjx+4wll5taF6Fmlfr0AYZNjLwzwFdik3lDUbbnBfvh1K7msKLKsNTzdmLKqNtzoujQ6ldS+FFjeGp5exFjdE258Xb5A1NPYUXdYannrMXdUbb4DnyUWo3UnjRYHgaOXvRYLQNepGsnZspvNhkeDZz9oL0nspcf4bM1WfIbIPPJS1vRvt9or2VwosthmcrZy+2GG2DXpxJ7e0UXmwzPNs5e0F6T2WuW8Bc0vJmtI/6UnsnhRc7DM9Ozl7sMNoG5/I7qd1M4UWT4Wnm7EWT0TboRXK/3ErhRYvhaeXsBenJZ3V6bv+bKU+vG2o8Mj30nE4MIeTx2X3XOGO3i8dnF7T2zGv1uPlC5b1stYcybtt83OQ56UDFClTcNjOm1yrvGPbzAOI6oEP1PuT/QFtqR37QeUvsct7tq/zrB/q1tH7r0GafGX8kzI6/rfG0NWZ5TH4DRxZzK828rgr+/xj0P8O5OZ63L9+WpOd5+ZZjmee+92e0fw3qXK2v3B7AezE6D1zoQ+eBx8TGayBdjypMX/Qp63sJWrP1ewl8f1axhMezjMe3jMfNkYfmL8Xe1Xgyuh4l7032MxoTXV/pXof4Sc+HNgV1cuD7BUrctZvWAIpZEcv3Fy7j41x52YZytOKYhyqhl0+JO3wkybgHq/P29ArdK8qTVpr9XNt96FPU2s21cvJtBORlwvvQxgPz4r5rgX6dke931yBG/8fFl+9n40F8PBhM4unCbzCoL9bNBa/taX1Q29O0m7r256vz89FwFE8+XY+mswUGn2EoicUfoWDeY+rmsEVW/xHWEpQN3mcm733pe+bIYFz8/YhgfBNi8b4Fv/HO4rcGa+Lu+Wg6G0/63+KvcX/gAJp+eHGrTzsqr3Loach46OnUwM+bXM0inDZ4Kv0Djfg91q03AAA=","debug_symbols":"5Z3haltHEEbfRb9N2dnZmd31q5RSlMQpAiOHWCkU43fvTStZLb7EJM6XHNCvoHh37tmQc2RL1/bD5t3Nm09//L7bv7+731z/+rC5vXu7Pezu9sujh035Zf7zl/cftvvPj+8P24+HzXW52tzs3y1/Pl5t3u9ubzbXrT9ePVs2w48LZ4+npXNtadSw49qoeZ6b/vjb1YJhBcJhEI4K4XAIR4NwBIQjIRwdwjEgHJCeVkhPK6SnFdLTCulphfS0QnpaIT2tkJ5WSE8rpKcO6alDeuqQnjqkpw7pqUN66pCeOqSn/pqeWvHTSitRX0kyKSStYEgMQ1IxJI4haRiSwJAkhqRjSDCNbZjGBqaxgWlsYBobmMYGprGBaWxgGhuYxgamsYFpbGIam5jGJqaxiWlsYhqbmMYmprGJaWxiGpuYxnZMYzumsR3T2P6qV2HHPIP4l0Fs9NNLcjbrfA7SKCBBAUkKSKeADArIhICMQgExCkilgFDKOihlHZSyDkpZB6Wsg1LWQSnrpJR1Uso6KWWdlLJOSlknpayTUtZJKeuklHVSymqFklYrlLZaocR1eXUBQ0LJ6zIBQ0IJrBVKYa1QEmsF01jDNNYwjTVMYw3TWMM01jCNNUxjDdNY0zT2OHwKh9eiHG7K4VU53JXDm3J4KIencnhXDlcaWpWGutJQVxrqSkNdaagrDXWloa401JWGutJQVxralIY2paFNaWhTGtqUhjaloU1paFMa2pSGNqWhoTQ0lIaG0tBQGhpKQ0NpaCgNDaWhoTQ0lIam0tBUGppKQ1NpaCoNTaWhqTQ0lYam0tBUGtqVhnaloV1paFca2pWGdqWhXWloVxralYZ2paFDaehQGjqUhg6loUNp6FAaOpSGDqWhQ2noUBo6lYZOpaFTaehUGjqVhk6loVNp6FQaOpWGTqGhtRTlcFMOr8rhrhzelMNDOTyVw7ty+FAOVxpqSkNNaagpDTWloaY01JSGmtJQUxqqvKeoKu8pqsp7iur6PUXLG1+nb+Re3uzpX77E8iTfjouXJ7bzD0C0WlZWe6/Hxc3OPKOeeCqMx2E8DcYTMJ6E8XQYz4DxTBbP+u1hP5EH1meH9dlhfXZYnx3WZ4f12WF9dlifHdbnButzg/W5wfrcYH1usD43WJ8brM8N1ucG63OD9TlgfQ5YnwPW54D1OWB9Dm2fjxfJH3GR71HSFk8Xyf7Cv2wfeVzc5xloeYXvBDRoQBMGlIUGZDSgSgNyGlD70UDpT0D5P6CVdyf89O7EzPnC2h7jaW77z9rTOeNCzpkXcs5+IeccF3LOeRnn7OVCzmkXcs56Ief0Czlnu5Bzrj6vpNXTrrR23nb+fb6r/917Hf10Mfeysm31s5LlSfy4y0t7/rX1+l3tL20a37JpfsOm9bvLX9pkX7dpefDn9uNu++b25n7Z8Pljn/ZvD7u7/fHh4a8P/35kWfs3"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":4,"end":5}],"caller_on_l1":[{"start":5,"end":6}],"inputs":[{"start":0,"end":3}],"nonce":[{"start":6,"end":7}],"recipient":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":40,"end":41}],"inputs":[{"start":0,"end":39}],"secret_for_L1_to_L2_message_consumption":[{"start":41,"end":42}],"secret_hash_for_redeeming_minted_notes":[{"start":39,"end":40}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"return_witnesses":[929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":4,"end":5}],"inputs":[{"start":0,"end":3}],"message_leaf_index":[{"start":6,"end":7}],"secret":[{"start":5,"end":6}],"to":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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rgcpuB6k4HqQgutBCq4HKbgepOB6kILrQQquBym4HqTgepCK60EqrgepuB6k4nqQetCYrbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBGq4HabgepOF6kIbrQdpBY7bhepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB+m4HqTjepCO60E6rgfpB43ZjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutB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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[3],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[4,5,6,7],"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2b227iMBCGE8ohNMshIYTzobQ3exdYCvSOl9l9671fad9htZ3UUwZrWjnqxIolLKFMjOP/m9+HppXre2+l9frxVdzQrrRgm7O6Zl8rW8G+sjI5fUc4a45w3gly+gwnXOsqhivM5aZ3Pc/fy1lwklBRCgUDc0fqPoK7eghKUwWBBnyWgD5lpybpnEJDCRU4BQhJIj6pw2drpA53kLvg0kVTPod9QMwT6/d1QMNL2u/cIYnxO9Cekrp6STk25HMsy7t8VaI/DdVvi9yjV20VC+6wW6rtq0+baHpqjDCekLbYDv2okTGG0vEu49/+5Lm69lyXtGky+Z892fxbGk9LY24oJigR8Gp7QEljk0G/9/L9Xo15XRuTe5JTR9zv3Qn2hNC7LvpPmTOJO4TnmzhPti0nz7ex6xJ2mX6f9+BVT/Mq1LzqkjaUoVeCfz7Rxb7xvsdoy3lxOIF238CLPsPTt+xFn9EW9OIFtCMDLyKGJ7LsRcRoy3lx/AHasYEXMcMTW/YiZrTlvNjl7xYDAy8GDM/AshcDRltwjeTzIjHwImF4EsteJIy2oBe/QHto4MWQ4Rla9mLIaAt68RO0UwMvUoYntexFymgL7p35+8XIwIsRwzOy7MWI0Rb0YgfaYwMvxgzP2LIXY0ZbcI3k2hMDLyYMz8SyF/R31CLMAweZUweZ4wowB1oso33I98+pgRdThmdq2QvUK8qcVIA50GIZ7cMzaM8MvJgxPDPLXqBeUebIQebYQeahg8yJg8ypg8xVmM+BFstoH/M9dG7gxZzhmVv2AvWKMkcOMk8dZI4rwBxosYz2Mf/b3MLAiwXDs7DsBeoVZR45yNyvAHOgxTLaxwNoLw28WDI8S8teoF5R5rGDzKmDzFMHmWMHmYcOMicOMt/WoB3mqALM9EzT31J5di+hxoOeeRqjpzGGJKbnYFbijFlGx2dFtNbyWltuvuD9ulTt3Qn63cjnlL/LP6q+8AzfhsnpScXS57keSb8+0cH6Oon/kLbYDv3AdYvsMO8eVPz0yXNL7bkuafPA5H/2ZPPfaDwbjRnG5DfhWItz7E4m87rvXdbyd8JTwj64p2dysZjsOyXtMduS8szoGb5/nuyaXmteBZpXXdKG7tHrEvwzmV835hvzR8z0fSIgdfj9itTVtFzo/zJgezgz/B/4fzqFFjUAAA==","debug_symbols":"ndpRattAGIXRveg5FN9foxkpWymluIlTDMEJiVMoIXuv3dIF5LxpJN237+kw79P94cfbz+/H08PT63T79X16fLrbn49Pp8vpfdp9qf737evz/nR98Xrev5yn27lyMx1O99en/nEzPRwfD9NtGx/fbq6bAZsVNtvnN/MONoFNwWaGTYPNAhvoYIYOZuhghg4adNCggwYdNOigQQcNOmjQQYMOGnTQoIMFOliggwU6WKCDBTpYoIMFOliggwU6WKCDDh106KBDBx066NBBhw46dNChgw4ddOhgQAcDOhjQwYAOBnQwoIMBHQzoYEAHAzpYoYMVOlihgxU6WKGDFTpYoYMVOlihgxU62KCDDTrYoIMNOtiggw062KCDDTrYoIMNOshuJ6PIqGQ0y6jJaJFRl9GQ0SojKSJSRKSISBGRIiJFRIqIFBEpIlJEpIiSIkqKKCmipIiSIkqKEGqMWGMEGyPaGOHGiDdGwDEijhFyjJhjBB0j6hhhx4g7RuAxIo8ReozYYwQfI/oY4ceIP0YAMiKQEYKMGGQEISMKGWHIiENGIDIikRGKjFhkBCMjGhnhyIhHRkAyIpIRkoyYZAQlIyoZYcmIS0ZgMiKTEZqM2GQEJyM6GeHJiE9GgDIilBGijBhlBCkjShlhyohTRqAyIpURqoxYZQQrI1oZ4cqIV0bAMiKWEbKMmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZdH1SLofSRckxSxLzLLELEvMssQs67NmeTn82r8c9z8eD9eLsNdvb6e7//diL8fz7+d/Xy7//gE="}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"1"}},{"name":"typ","value":{"kind":"string","value":"PublicMutable<AztecAddress, Context>"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"2"}},{"name":"typ","value":{"kind":"string","value":"SharedImmutable<EthAddress, Context>"}}]}}]}]}},"file_map":{"21":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"35":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"41":{"source":"impl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u64, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u64) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<N>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n}\n","path":"std/slice.nr"},"47":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}","path":"/home/josh/Documents/test/aztec-token-bridge/packages/aztec-contracts/token_bridge/src/main.nr"},"55":{"source":"use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"58":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"60":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, silo_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub fn compute_siloed_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    silo_nullifier(address, nullifier)\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/hash.nr"},"63":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    * Should be automatically convertible to [Field; N]. For example str<N> works with\n    * one char per field. Otherwise you can use CompressedString.\n    */\n    pub fn emit_unencrypted_log_with_selector<T>(&mut self, event_selector: Field, log: T) {\n        emit_unencrypted_log(event_selector, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn emit_unencrypted_log<T, N, M>(&mut self, log: T) {\n        let event_selector = 5; // Matches current PublicContext.\n        self.emit_unencrypted_log_with_selector(event_selector, log);\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log<T>(event_selector: Field, message: T) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nfn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nfn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nfn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nfn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nfn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nfn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nfn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nfn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nfn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nfn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nfn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nfn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nfn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nfn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nfn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nfn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nfn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nfn emit_unencrypted_log_opcode<T>(event_selector: Field, message: T) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nfn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nfn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nfn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nfn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"65":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::{note_interface::NoteInterface, utils::compute_note_hash_for_insertion},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_log, emit_encrypted_note_log, compute_encrypted_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Ending setup at counter {0}\",\n            [self.side_effect_counter as Field]\n        );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(&mut self, log: T) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn encrypt_and_emit_log<N, M>(\n        &mut self,\n        contract_address: AztecAddress,\n        randomness: Field, // Secret random value used later for masked_contract_address\n        event_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        preimage: [Field; N]\n    ) where [Field; N]: LensForEncryptedLog<N, M> {\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        // We are currently just encrypting it EXACTLY the same way as if it was a note.\n        let counter = self.next_counter();\n        let encrypted_log: [u8; M] = compute_encrypted_log(\n            contract_address,\n            randomness,\n            event_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n        emit_encrypted_log(contract_address, randomness, encrypted_log, counter);\n        let len = 32 + 32 + 64 + 48 + 48 + 176 + 64 + (preimage.len() as Field * 32) + 16 + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n    }\n\n    pub fn encrypt_and_emit_note<Note, N, NB, M>(\n        &mut self,\n        contract_address: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        note: Note\n    ) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n        let note_hash_counter = note.get_header().note_hash_counter;\n        let note_exists_index = find_index(\n            self.new_note_hashes.storage,\n            |n: NoteHash| n.counter == note_hash_counter\n        );\n        assert(\n            note_exists_index != MAX_NEW_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n        );\n        let preimage = note.serialize_content();\n        let counter = self.next_counter();\n\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        // TODO(#1139 | #6408): perform encryption in the circuit\n        let encrypted_log: [u8; M] = compute_encrypted_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n\n        // Current unoptimized size of the encrypted log\n        // incoming_tag (32 bytes)\n        // outgoing_tag (32 bytes)\n        // eph_pk (64 bytes)\n        // incoming_header (48 bytes)\n        // outgoing_header (48 bytes)\n        // outgoing_body (176 bytes)\n        // incoming_body_fixed (64 bytes)\n        // incoming_body_variable (N * 32 bytes + 16 bytes padding) \n        // len of processed log (4 bytes)\n        let len = 32 + 32 + 64 + 48 + 48 + 176 + 64 + (preimage.len() as Field * 32) + 16 + 4;\n\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"69":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"70":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize};\n\nuse crate::context::private_context::PrivateContext;\nuse crate::context::public_context::PublicContext;\nuse crate::context::gas::GasOpts;\nuse crate::context::public_context::FunctionReturns;\n\nuse crate::oracle::arguments;\n\nstruct PrivateCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateCallInterface<T> {\n    pub fn call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateVoidCallInterface {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nstruct PrivateStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateStaticCallInterface<T> {\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateStaticVoidCallInterface {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nstruct PublicCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicStaticCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nstruct PublicStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicStaticVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"71":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/messaging.nr"},"77":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nfn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"79":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"81":{"source":"#[oracle(packReturns)]\nfn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nfn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"82":{"source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"87":{"source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nfn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"91":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nfn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"92":{"source":"#[oracle(packArgumentsArray)]\nfn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nfn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"93":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"94":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u64 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nfn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u64, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"97":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/initializer.nr"},"115":{"source":"use crate::context::PublicContext;\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, ()> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // Note that this is the exact same implementation as for public execution, though it might change in the future\n        // since unconstrained execution might not rely on the same oracles as used for public execution (which \n        // transpile to AVM opcodes).\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"120":{"source":"use crate::{\n    context::{PrivateContext, PublicContext}, oracle::{storage::{storage_read, storage_write}},\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, ()> {\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"138":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr"},"142":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::recursion::verification_key::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::log_hash::LogHash;\nuse crate::traits::is_empty;\nuse crate::utils::{uint256::U256, field::field_from_bytes_32_trunc};\nuse crate::constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n};\nuse crate::traits::Hash;\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(address: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_encrypted_log(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_unencrypted_log(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5, counter: 1234 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"143":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u64,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"145":{"source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"146":{"source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"166":{"source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr"},"168":{"source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr"},"170":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"171":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr"},"175":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u64,\n    nullifier_read_requests: u64,\n    key_validation_requests_and_generators: u64,\n    new_note_hashes: u64,\n    new_nullifiers: u64,\n    new_l2_to_l1_msgs: u64,\n    private_call_requests: u64,\n    public_call_stack_hashes: u64,\n    note_encrypted_logs_hashes: u64,\n    encrypted_logs_hashes: u64,\n    unencrypted_logs_hashes: u64,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr"},"176":{"source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"178":{"source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr"},"179":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr"},"183":{"source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr"},"186":{"source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH}, hash::silo_nullifier,\n    traits::{Empty, Hash, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = silo_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr"},"188":{"source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr"},"189":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x0933cf2bb384c9733d5a8311bfdc089489c2557df2265026579f9ac2b21d2ef9;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr"},"190":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr"},"191":{"source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr"},"196":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr"},"197":{"source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x1f0e71146c5d4a5bdcf517f0063cda7767e51fcb9cebc877feb348a77a7a6b4a;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x079a2b28b4853de9169d7dc40ac41c6d80b465d82c60195ede91504013f8b11b;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr"},"209":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::silo_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = silo_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"211":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr"},"213":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr"},"214":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr"},"215":{"source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr"},"216":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr"},"221":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"222":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"232":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"233":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr"},"234":{"source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr"},"248":{"source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr"},"249":{"source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr"},"251":{"source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/header.nr"},"252":{"source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr"},"254":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress}\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::{auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public}};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        storage.balances.add(\n            context.msg_sender(),\n            context.msg_sender(),\n            U128::from_integer(amount)\n        );\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes[0].unwrap_unchecked();\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        storage.balances.add(context.msg_sender(), to, U128::from_integer(amount));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount);\n        // docs:start:increase_private_balance\n        storage.balances.add(from, to, amount);\n        // docs:end:increase_private_balance\n    }\n    // docs:end:transfer\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"269":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/master/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}