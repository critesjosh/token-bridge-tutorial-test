{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+a46035ba69b0a659897fe25271c346e005925a6c-x8664",
  "name": "TokenBridge",
  "functions": [
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "11235885384217001395": {
            "error_kind": "string",
            "string": "Function get_token can only be called statically"
          },
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17456365777023668047": {
            "error_kind": "string",
            "string": "Token address is not the same as seen in storage"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7408320001641276198": {
            "error_kind": "string",
            "string": "Function _assert_token_is_same can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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IwIADwAABxUiAAAYRCwIASAmAiEEBQAQASEBJgMgBAEAKCACIR88AAwAHAAhLA0gIQAoIQIhLA4hICwNICEAKCECISwOISAsDSAhACghAiEsDiEgLAgBIQAAAQIBLA4gISwIASAAAAECASwOCCAmAiMEJCwIACQsDCElLAwgJgAQACMAJAAAM4IsBAAALAwlIiYCJAQlLAgAJSwMBCYsDCInABAAJAAkAAAwMiwEAAAsDCYjJgIkBCUsCAAlLAwhJiwMICcAEAAkACQAADOCLAQAACwMJiImAiUEJiwIACYsDA0nLAwiKAAQACUAJAAAMDIsBAAALAwnJCYCJQQmLAgAJiwMIScsDCAoABAAJQAkAAAzgiwEAAAsDCciJgImBCcsCAAnLAwNKCwMIikAEAAmACQAADAyLAQAACwMKCUmAiYEJywIACcsDCEoLAwgKQAQACYAJAAAM4IsBAAALAwoIiYCIQQmLAgAJiwMDScsDCIoABAAIQAkAAAwMiwEAAAsDCcgLAgBIQAAAQIBLA4HISwIASIAAAECASwOCiIsCAEmAAABAgEmAicAbiwOJyYmAicEKCwIACgsDCEpLAwiKiwMJisAEAAnACQAADP9LAQAACwIAScAAAECASYCKQQqLAgAKiwMIysAEAApACQAADQnLAQAACwMKygsDSgpACgpAiksDikoJgIqBCssCAArLAwkLAAQACoAJAAANCcsBAAALAwsKSwNKSoAKCoCKiwOKikmAioCvCYCKwJqJgIsApsmAi0C0ywIAS4mAi8ERQAQAS8BJgMuBAEAKC4CLywMLzAsDiowACgwAjAsDiswACgwAjAsDiwwACgwAjAsDi0wACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgwAjAsDhIwACgw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DwAoDwIPLA4PBSwNBQ8AKA8CDywODwUsDQUPACgPAg8sDg8FLAgBDwAAAQIBLA4FDywIAQUAAAECASwOCAUmAiEEIiwIACIsDA8jLAwFJAAQACEAJAAAM4IsBAAALAwjICYCIgQjLAgAIywMDiQsDCAlABAAIgAkAAAwMiwEAAAsDCQhJgIiBCMsCAAjLAwPJCwMBSUAEAAiACQAADOCLAQAACwMJCAmAiMEJCwIACQsDA0lLAwgJgAQACMAJAAAMDIsBAAALAwlIiYCIwQkLAgAJCwMDyUsDAUmABAAIwAkAAAzgiwEAAAsDCUgJgIkBCUsCAAlLAwOJiwMICcAEAAkACQAADAyLAQAACwMJiMmAiAEJCwIACQsDA8lLAwFJgAQACAAJAAAM4IsBAAALAwlDiYCDwQkLAgAJCwMDSUsDA4mABAADwAkAAAwMiwEAAAsDCUFLAgBDQAAAQIBLA4HDSwIAQ4AAAECASwOCg4sCAEPAAABAgEmAiAAOiwOIA8mAiAEJCwIACQsDA0lLAwOJiwMDycAEAAgACQAADP9LAQAACwIASAAAAECASYCJQQmLAgAJiwMIScAEAAlACQAADQnLAQAACwMJyQsDSQhACghAiEsDiEkJgIlBCYsCAAmLAwiJwAQACUAJAAANCcsBAAALAwnISwNISUAKCUCJSwOJSEmAiYEJywIACcsDCMoABAAJgAkAAA0JywEAAAsDCglLA0lIwAoIwIjLA4jJSYCIwIyJgImAo0mAicC7CYCKAJpLAgBKSYCKgRlABABKgEmAykEAQAoKQIqLAwqKywOKCsAKCsCKywOIysAKCsCKywOJisAKCsCKywOJysAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEisAKCsCKywOEissDikgLAwIAyIAAB6KDDgDExIjAgASAAAoTSIAAB6cLA0gAywIARImAhMECQAQARMBJgMSBAEAKBICEywMExYsDhEWACgWAhYsDhUWACgWAhYsDhcWACgWAhYsDhkWACgWAhYsDhsWACgWAhYsDh8WACgWAhYsDhAWACgWAhYsDhQWLAgBEAAAAQIBLA4SECwIAREAAAECASYCEwRkJgIWBCMsCAAjLAwDJCwMEyUsDAgmABAAFgAkAABJViwEAAAsDCQULAwlFSwNFBYAKBYCFiwOFhQsDRQWACgWAhYsDhYULA0UFgAoFgIWLA4WFCwOFREKOBUeFiMCABYAAB+CIgAAH8IsCAEVJgIWBAkAEAEWASYDFQQBACgUAhYAKBICFwAoFQIZ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AAECASwOBgcmAgYEQAA4AwYIDjgDCAkjAgAJAAA04CQAADjaDDgCCAkjAgAJAAA0+yIAADTyLAwGBCIAADU/DDgCAwgjAgAIAAA1LSIAADUNAjgCAwgOOAMCCSMCAAkAADUkJAAATw8sDAgGIgAANTYsDAUGIgAANTYsDAYEIgAANT8mAgIEBAY4BAIGLAgBCAAAAQIBLA4GCCYCCgQEBjgECgsEOAsKDAI4BAwJCjgJBQomAgkEASMCAAoAADWhIgAANYEAOAYJCg44BgoLIwIACwAANZgkAAA42iwOCggiAAA1oSwNCAomAggCACYCCwIBLAwFBiIAADW4DDgGCgwjAgAMAAA10yIAADXKLA0HASwMBAIlLAgBDQAAAQIBLA4FDQQ4BgIOJgIQBAAKOBACDyMCAA8AADYOBjgOAhIKOBIGESMCABEAADYOJAAATXosDAUMIgAANhcMOAwCDyMCAA8AADaSIgAANiksDQcMLA0NDiYCDwQQDDgGDxAjAgAQAAA2SCQAAEzaLQQADIADJwCABAQAESQAAEzsLQiABQANACgNAg8AOA8GECwODhAAOAYJDA44BgwOIwIADgAANoUkAAA42iwODQcsDAwGIgAANbgAOA4MEA44DhARIwIAEQAANqkkAAA42gw4EAQRIwIAEQAANsQiAAA2uywMCA8iAAA3CQA4AxARDjgDERIjAgASAAA22yQAADjaJgISBEQMOBESEyMCABMAADbyJAAATNoAKAECEgA4EhETLA0TECwMEA8iAAA3CSwNDRAmAhIEEywIABMsDBAULAwLFQAQABIAJAAATyEsBAAALAwUERwMDxAEADgREA8OOBEPEiMCABIAADdMJAAAONosDg8NADgMCQ8OOAwPECMCABAAADdnJAAAONosDA8MIgAANhckAAAvjiwNAQYAKAYCBiwOBgEmAgYEBAY4AgYHJgIGBBAMOAcGCCMCAAgAADejJAAATNoAKAECBgA4BgcILA0IAiYCBgBZCjgEBggmAgYCgCMCAAgAADhoIgAAN80mAgkAhQo4BAkKIwIACgAAOC8iAAA35CYCCQCMCjgECQojAgAKAAA3/yYCCwQAOwkBCyYCCQQKLAgACiwMAgssDAMMLAwGDQAQAAkAJAAAT6gsBAAALAwLBCwMBAgiAAA4XyYCCQQKLAgACiwMAgssDAMMLAwGDQAQAAkAJAAAT6gsBAAALAwLBCwMBAgiAAA4XywMCAUiAAA4mCYCCAQJLAgACSwMAgosDAMLLAwGDAAQAAgAJAAAT6gsBAAALAwKBCwMBAUiAAA4mCYCAwQQDDgHAwQjAgAEAAA4ryQAAEzaLQQAAYADJwCABAQAESQAAEzsLQiABQACACgCAgMAOAMHBCwOBQQsDAIBJSkBAAEFRafKcRlB5BU7AQECJSQAAC+OLA0BBAAoBAIELA4EASwIAQQAAAECASwOAQQsCAEFAAABAgEsDgIFJgIHBAQGOAIHCAQ4CAcJAjgCCQYmAgcEAAo4BgcIJgIJBAQjAgAIAAA6VCIAADlIBjgCCQgCOAkGCg44BgkLIwIACwAAOWQkAABPDyYCCwQQDDgICwwjAgAMAAA5eyQAAEzaACgBAgsAOAsIDCwNDAYcDAoMAhwMDAsEHAwLDAImAgsCCAQ4CwwNJgIPAgAKOA8MDiMCAA4AADnLBjgNDBEKOBELECMCABAAADnLJAAATXoaOAYNCyYCDQQOLAgADiwMCw8sDAwQABAADQAkAABPISwEAAAsDA8GJgIMBBAMOAgMDSMCAA0AADoKJAAATNotBAABgAMnAIAEBAARJAAATOwtCIAFAAsAKAsCDAA4DAgNLA4GDSwOCwQAOAIKAQ44AgEGIwIABgAAOkskAAA42iwOAQUiAAA6VCwNBQIGOAIJBSYCAgQOJgIGBAEsDAUBIgAAOnAMOAECBSMCAAUAAD1yIgAAOoImAgUECAQ4BQMIJgILBAAKOAsDCiMCAAoAADq1BjgIAw0KOA0FDCMCAAwAADq1JAAATXocDAgDACcCAAUEAQAsCAEIJgIKBAkAEAEKASYDCAQBACgIAgpDOgADAAoABQAIACwNCAMAKAMCAywOAwgsDQgDACgDAgMsDgMIJgIDBAImAgUEAyYCCgIBLAwHASIAADsWDDgBAwcjAgAHAAA7LSIAADsoLA0EASUEOAEJByYCDAQACjgMCQsjAgALAAA7WwY4BwkOCjgOAQ0jAgANAAA7WyQAAE16LA0ECwA4AgEMDjgCDA0jAgANAAA7diQAADjaJgIOBAgMOAcODyMCAA8AADuNJAAATNoAKAgCDgA4DgcPLA0PDQA4BwYODjgHDg8jAgAPAAA7siQAADjaJgIQBAgMOA4QESMCABEAADvJJAAATNoAKAgCEAA4EA4RLA0RDwA4BwMODjgHDhAjAgAQAAA77iQAADjaJgIRBAgMOA4REiMCABIAADwFJAAATNoAKAgCEQA4EQ4SLA0SEAA4BwUODjgHDhEjAgARAAA8KiQAADjaJgIRBAgMOA4REiMCABIAADxBJAAATNoAKAgCEQA4EQ4SLA0SBxwMDQ4EJgIRBBIsCAASLAwOEywMChQAEAARACQAAE8hLAQAACwMEw0cDA8OBAA4DQ4PDjgNDxEjAgARAAA8kyQAADjaJgIOBBEsCAARLAwPEiwMChMAEAAOACQAAE8hLAQAACwMEg0cDBAOBAA4DQ4PDjgNDxAjAgAQAAA80iQAADjaJgIOBBAsCAAQLAwPESwMChIAEAAOACQAAE8hLAQAACwMEQ0cDAcOBAA4DQ4HDjgNBw8jAgAPAAA9ESQAADjaJgIOBBAMOAwODyMCAA8AAD0oJAAATNotBAALgAMnAIAEBAARJAAATOwtCIAFAA0AKA0CDgA4DgwPLA4HDywODQQAOAEGBw44AQcLIwIACwAAPWkkAAA42iwMBwEiAAA7FiwNBAUmAgoEEAw4AQoLIwIACwAAPY0kAABM2i0EAAWAAycAgAQEABEkAABM7C0IgAUACAAoCAIKADgKAQssDgcLADgBBgUOOAEFCiMCAAoAAD3KJAAAONosDggELAwFASIAADpwJAAAL44sDQIEACgEAgQsDgQCLAgBBAAAAQIBJgIFAgAsCAEGJgIHBCEAEAEHASYDBgQBACgGAgcmAggEIAA4CAcILAwHCQw4CQgKFgwKCiMCAAoAAD48LA4FCQAoCQIJIgAAPh0sCAEFAAABAgEsDgYFLAgBBiYCBwQJABABBwEmAwYEAQAoAQIHACgCAggAKAYCCT8/AAkACAAHLA0GAQAoAQIBLA4BBiwOBgQnAgABBAEAJgICBAgmAgYEBCYCBwQAJgIIBAEsDAcDIgAAPqgMOAMCCSMCAAkAAD6/IgAAProsDQUBJSwNBAomAgwECAw4AwwNIwIADQAAPtokAABM2gAoCgIMADgMAw0sDQ0LHAwLCgAsCAELJgIMBAUAEAEMASYDCwQBACgLAgxDOgAKAAwAAQAEACwNCwoAKAoCCiwOCgssDQsKACgKAgosDgoLBDgGAwomAg0EAAo4DQMMIwIADAAAP1gGOAoDDwo4DwYOIwIADgAAP1gkAABNeiwMBwkiAAA/YQw4CQYMIwIADAAAP5MiAAA/cwA4AwgJDjgDCQojAgAKAAA/iiQAADjaLAwJAyIAAD6oLA0FDAA4CgkNDjgKDQ4jAgAOAAA/riQAADjaJgIPBAQMOAkPECMCABAAAD/FJAAATNoAKAsCDwA4DwkQLA0QDiYCEAQgDDgNEBEjAgARAAA/6iQAAEzaLQQADIADJwCABAQAISQAAEzsLQiABQAPACgPAhAAOBANESwODhEsDg8FADgJCAwOOAkMDSMCAA0AAEArJAAAONosDAwJIgAAP2EkAAAvjiwIAQMAAAECASYCBAABLA4EAywIAQQAAAECASYCBQAALA4FBCwIAQYAAAECASwOBQYmAgUEACYCBwQeJgIIBA8mAgkEDicCAAoAAQAmAgsEASwMBQIiAABAkww4AggFIwIABQAAQOEiAABApSwNBgIAKAECBwA4BwgJLA0JBRwMBQEALA0DBQQ4AQUDADgCAwEsDgEGLA0EAgQ4AgUDADgBAwIsDAIBJSwNBgUCOAcCDA44AgcNIwIADQAAQPwkAABPDyYCDgQgDDgMDg8jAgAPAABBEyQAAEzaACgBAg4AOA4MDywNDw0cDA0MACwNAw0EOAwNDgA4BQ4MLA4MBgQ4DQoFLA4FAywNBAwCOAkCDQ44AgkOIwIADgAAQVwkAABPDyYCDwQgDDgNDxAjAgAQAABBcyQAAEzaACgBAg8AOA8NECwNEA4cDA4NAAQ4DQUOADgMDgUsDgUEADgCCwUOOAIFDCMCAAwAAEGrJAAAONosDAUCIgAAQJMkAAAvjiYCAgQAACgBAgQAOAQCBSwNBQMcDAMBACsCAAIAAAAAAAAAAAAAAAAA//////////////////////////8OOAECBCMCAAQAAEIIJAAAULYsDAMBJSQAAC+OJgIFBAAsCAEGJgIHBBEAEAEHASYDBgQBACgGAgcmAggEEAA4CAcILAwHCQw4CQgKFgwKCiMCAAoAAEJcLA4FCQAoCQIJIgAAQj0sCAEHAAABAgEsDgYHJgIGBEAAOAMGCA44AwgJIwIACQAAQoUkAAA42gw4AggJIwIACQAAQqAiAABClywMBgQiAABC5Aw4AgMIIwIACAAAQtIiAABCsgI4AgMIDjgDAgkjAgAJAABCySQAAE8PLAwIBiIAAELbLAwFBiIAAELbLAwGBCIAAELkJgICBAQGOAQCBiwIAQgAAAECASwOBggmAgoEBAY4BAoLBDgLCgwCOAQMCQo4CQUKJgIJBAEjAgAKAABDRiIAAEMmADgGCQoOOAYKCyMCAAsAAEM9JAAAONosDgoIIgAAQ0YsDQgKJgIIAgAmAgsCASwMBQYiAABDXQw4BgoMIwIADAAAQ3giAABDbywNBwEsDAQCJSwIAQ0AAAECASwOBQ0EOAYCDiYCEAQACjgQAg8jAgAPAABDswY4DgISCjgSBhEjAgARAABDsyQAAE16LAwFDCIAAEO8DDgMAg8jAgAPAABENyIAAEPOLA0HDCwNDQ4mAg8EEAw4Bg8QIwIAEAAAQ+0kAABM2i0EAAyAAycAgAQEABEkAABM7C0IgAUADQAoDQIPADgPBhAsDg4QADgGCQwOOAYMDiMCAA4AAEQqJAAAONosDg0HLAwMBiIAAENdADgODBAOOA4QESMCABEAAEROJAAAONoMOBAEESMCABEAAERpIgAARGAsDAgPIgAARK4AOAMQEQ44AxESIwIAEgAARIAkAAA42iYCEgTgDDgREhMjAgATAABElyQAAEzaACgBAhIAOBIREywNExAsDBAPIgAARK4sDQ0QJgISBBMsCAATLAwQFCwMCxUAEAASACQAAE8hLAQAACwMFBEcDA8QBAA4ERAPDjgRDxIjAgASAABE8SQAADjaLA4PDQA4DAkPDjgMDxAjAgAQAABFDCQAADjaLAwPDCIAAEO8KQEAAQVhvkdVaxOAkTsBAQIlKQEAAQW4ejlEs7E8VjsBAQIlJAAAL44uDAAEAAUsDAUBJSQAAC+OLAgBBgAAAQIBLA4BBiwNAgEAKAECASwOAQIsCAEBAAABAgEsDgIBLA0EAgAoAgICLA4CBCYCAgQBJgIHAQEmAggEACwMCAUiAABFmgw4BQMIIwIACAAARb0iAABFrCwNBgIsDQEDLAwCASwMAwIlIwIACAAARcokAABQyAAoBAIJLA0JCQw4BQkKIwIACgAAReUkAABM2iYCCgQDADgECgkAOAkFCiwNCggsDQYJLA0BCgAoCQILLQQACoADJwCABAQAASQAAEZcLQiABQAMLQiABgANLA4IDSwNDAgAKAgCCCwOCAwsDgsGLA4MAQA4BQIIDjgFCAkjAgAJAABGUyQAADjaLAwIBSIAAEWaLQGAA4AHAQCAAwACgAstAYALgAgBAIALAAKACy0BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANIwCADAAARqsiAABHGyMAgA0AAEa4IgAARtEtAIADgAUBAIAFAAKADi0CgAuADiIAAEcWJwCADwQAAwEAgAmAD4AOLQAAAYAFAQAAAYAOAAEnAYAFBAABAQCABQACgA4tAoALgA4BAIAOAAKADi0CgAmADiIAAEcWIgAAR28nAIAPBAACBQCAC4APgA4nAIAQBAADAQCADoAQgA8tAAABgAUBAAABgA8AAScBgAUEAAEBAIAFAAKADy0CgAuADwEAgA8AAoAPLQKADoAPIgAAR28nAIANBAADAQCABYANgAwLAIADgAWADSMAgA0AAEfTAQCACoAIgA8tAIAKgBAtAIAMgBELAIAQgA+AEiMAgBIAAEfTLQGAEIAOLQKADoARAQCAEAACgBABAIARAAKAESIAAEeiAQCADIAIgAYlLQGAA4AHAQCAAwACgAstAYALgAgBAIALAAKACy0BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANIwCADAAASCsiAABImyMAgA0AAEg4IgAASFEtAIADgAUBAIAFAAKADi0CgAuADiIAAEiWJwCADwQAAwEAgAmAD4AOLQAAAYAFAQAAAYAOAAEnAYAFBAABAQCABQACgA4tAoALgA4BAIAOAAKADi0CgAmADiIAAEiWIgAASO8nAIAPBAACBQCAC4APgA4nAIAQBAADAQCADoAQgA8tAAABgAUBAAABgA8AAScBgAUEAAEBAIAFAAKADy0CgAuADwEAgA8AAoAPLQKADoAPIgAASO8nAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOIwCADgAASU8tAYAQgBEtAoARgA8DAIAQAAKAEAMAgA8AAoAPIgAASR4tAIAMgAYlJAAAL44mAgUEACwIAQYmAgcEEQAQAQcBJgMGBAEAKAYCByYCCAQQADgIBwgsDAcJDDgJCAoWDAoKIwIACgAASaUsDgUJACgJAgkiAABJhiwIAQcAAAECASwOBgcmAgYEQAA4AwYIDjgDCAkjAgAJAABJziQAADjaDDgCCAkjAgAJAABJ6SIAAEngLAwGBCIAAEotDDgCAwgjAgAIAABKGyIAAEn7AjgCAwgOOAMCCSMCAAkAAEoSJAAATw8sDAgGIgAASiQsDAUGIgAASiQsDAYEIgAASi0mAgIEBAY4BAIGLAgBCAAAAQIBLA4GCCYCCgQEBjgECgsEOAsKDAI4BAwJCjgJBQomAgkEASMCAAoAAEqPIgAASm8AOAYJCg44BgoLIwIACwAASoYkAAA42iwOCggiAABKjywNCAomAggCACYCCwIBLAwFBiIAAEqmDDgGCgwjAgAMAABKwSIAAEq4LA0HASwMBAIlLAgBDQAAAQIBLA4FDQQ4BgIOJgIQBAAKOBACDyMCAA8AAEr8BjgOAhIKOBIGESMCABEAAEr8JAAATXosDAUMIgAASwUMOAwCDyMCAA8AAEuAIgAASxcsDQcMLA0NDiYCDwQQDDgGDxAjAgAQAABLNiQAAEzaLQQADIADJwCABAQAESQAAEzsLQiABQANACgNAg8AOA8GECwODhAAOAYJDA44BgwOIwIADgAAS3MkAAA42iwODQcsDAwGIgAASqYAOA4MEA44DhARIwIAEQAAS5ckAAA42gw4EAQRIwIAEQAAS7IiAABLqSwMCA8iAABL9wA4AxARDjgDERIjAgASAABLySQAADjaJgISBGQMOBESEyMCABMAAEvgJAAATNoAKAECEgA4EhETLA0TECwMEA8iAABL9ywNDRAmAhIEEywIABMsDBAULAwLFQAQABIAJAAATyEsBAAALAwUERwMDxAEADgREA8OOBEPEiMCABIAAEw6JAAAONosDg8NADgMCQ8OOAwPECMCABAAAExVJAAAONosDA8MIgAASwUpAQABBWbPo8pgP+MmOwEBAiUpAQABBfJBeC+4yA9POwEBAiUpAQABBZvt4joHQf2zOwEBAiUBAIADgAWABy0AgAOACC0AgASACQsAgAiAB4AKIwCACgAATNktAYAIgAYtAoAGgAkBAIAIAAKACAEAgAkAAoAJIgAATKglKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAABNByIAAE0SLQCAA4AFIgAATXktAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAABNZS0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAABNNCcBgAUEAAEDAIAGAAKABiIAAE15JSkBAAEFZGGIqMbPlMs7AQECJSQAAC+OJgIGBAAmAgcEASYCCAQDLAwGBSIAAE2pDDgFCAYjAgAGAABOFiIAAE27LA0BBSwNAgYsDQMHLA0ECCYCCQQELAgBCiYCCwQFABABCwEmAwoEAQAoBgILJgIMBAQAKAoCDT4PAAsADSwNCgYAKAYCBiwOBgosDgUBLA4KAiwOBwMsDggEJSwNAwYMOAUGCSMCAAkAAE4sIgAATt0sDQEGLA0CCSwNAwosDQQLJgINBAQMOAUNDiMCAA4AAE5TJAAATNoAKAkCDQA4DQUOLA0ODCYCDgQDDDgFDg8jAgAPAABOeCQAAEzaACgGAg4AOA4FDywNDw0AOAwNDiYCDQQEDDgFDQ8jAgAPAABOoiQAAEzaLQQACYADJwCABAQABSQAAEzsLQiABQAMACgMAg0AOA0FDywODg8sDgYBLA4MAiwOCgMsDgsEIgAATt0AOAUHBg44BQYJIwIACQAATvQkAAA42iwMBgUiAABNqSkBAAEFvh4//z6k9vo7AQECJSkBAAEFKIaSsEfc/UM7AQECJSQAAC+OJgIEBAAKOAEEBSMCAAUAAE+aIgAATz0mAgQCCAQ4BAIFJgIHAgAKOAcCBiMCAAYAAE9wBjgFAgkKOAkECCMCAAgAAE9wJAAATXoYOAEFAiYCAQIgDDgFAQQmAgEBASMCAAQAAE+RJAAAUNosDAIDIgAAT6MsDAQDIgAAT6MsDAMBJSQAAC+OJgIFBAQGOAIFBgQ4BgUHAjgCBwQmAgIEBAI4AgQFDjgEAgYjAgAGAABP3SQAAE8PHAwFBgIcDAYCBBwMAgUCJgICAggEOAIFBiYCCAIACjgIBQcjAgAHAABQHwY4BgUKCjgKAgkjAgAJAABQHyQAAE16GjgBBgImAgYEBywIAAcsDAIILAwFCQAQAAYAJAAATyEsBAAALAwIARwMAwIEJgIDBAMCOAMEBQ44BAMGIwIABgAAUGgkAABPDxwMBQQCHAwEAwQcDAMEAiYCBQQGLAgABiwMAgcsDAQIABAABQAkAABPISwEAAAsDAcDADgBAwIOOAECBCMCAAQAAFCxJAAAONosDAIBJSkBAAEFWgLkG7UeqZ87AQECJSkBAAEFxWvEWg4QAAI7AQECJSkBAAEFyW+TOxOd6RY7AQECJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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JW64yqa44Sqb4oarbIobrrIpbrjKlrgNXGVT3HCVTXHDVTbFDVfZFDcBd0vccJVNccNVNsUNV9kUN1xlU9xwlS1xW7jKprjhKpviJuDmxU1n3Iu3Y0y4oUx4cYf5PRomkFrhhjJpihvKpCVugjJpihvKpCluPO9uihvPu5viJuBuiRvPu5vixvPuprgbu0qaHylosqqA27ppbUgvNjTKvknHp3n3o0XK+hHPemH8xNot8D0e+4QkAslbJAlI3iBpvddQD0g0kLxFYoDkLRILJG+REJC8ReKA5C0Sf0Akblavbvmu6+yxWoVpflrF87vrjAnPAI+odVkBHlEZswJsraPP7wt1oQQwUpxmGp3xryzoY/Je9Zy87jl503PytufkqefkXc/J+56TDz0nH3tOvucOG3rusKHnDht67rCh5w4beu6woecOG3rusKHnDht67rCh5w4be+6wsecOG3vusLHnDtt6Hzbe5HvusLHnDhtFd1hnzZw8uXXyojtsKXnRHbaQfBLdYUvJi+6wpeRFd9hS8qI7bCl50R22lLzoDltKXnSHLSXfc4dNojusV9O5ozdmnbzoDns9ea2U6BZbzF50jy1mL7rJFrMX3WWL2Ytus8XsRffZYvaiG20xe9Gdtph9x632lH3XvVZ33Wt1171Wd91rdde9tvWr+pmz77rX6q57re6612rZvZbmR/beq0z2snttIXsju9eWspfda0vZy+61pexl99pS9rJ7bSl72b22lL3sXlvKXnavLWR/++sxndVz9otdjB+zfx5B7z6C2X0Eu/sItPsIbvcR/O4jhN1HiLuPkPYegXa/p2n3e5p2v6cJbzvkfcmN1fblWGONXh78xNvhdYdteeN9h21544WHbXnjjYdteRN4N+WNdx625Y2XHjK/Sj+lmbc2a954l35b3niZflve8JdNeXv4y7a84S/b8oa/bMsb/rItbwLvprzhL9vyht9pyxt+py1v+J2mvAP8Tlved9SD3pV4kw7T0eTPL73Nv3rXRD/vRxIXDE3IZXJas2l5rKZYWMvozfSYNXr7en2eORI4snB04MjC0YMjC8cAjiwcIziycEzgyMExKnB8F8fCr5qiBkcWjgYcWTjCz/BwJHBk4Qg/w8MRfoaHI/wMD0f4GR6O8DMsHBP8DA9H+BkejvAzPBzhZzg46gvvJzR2SsmakM4p5fJ/fOnVNFtl3WKMlyFo/yHc/kP4/YcI+w8R9x8i7T7EhVfEsQ6R73fnLU+tTX45xHOUqYqyF6LM1aj8bWWJrka5qihfFRVqovLvxXF2em7tll8a8C8xtiKGKmJcRYyviAkVMbEiJm2Pyb9DpBCjK2IqrgNbcR3k38Xh/NTB3aKBzzGuIsZXxGSvAz9v0ux1WsfEipi0PSb/3olCjK6IMRUxtiKGKmJcRYyviKm4DqjiOqCK6yD/SxwdaRbM0S9+fzk12PwPSsph2avh8WqcwrRb30f5b/cXo6gqylVF+aqokI8KZo5Kbh0Va6LyG3aeEjxbHbXOMP89umIUVUW5qqg8eWfPL95yYR0VqqJiVVSqicp/kl+M0lVRpirKVkVRVZSriqq6NmLVtRGrro1YdW2kqmsjXbg2Qpqj0ro/JFMVZauiqCoqv8pWz1Gnpz/rqFAVFauiUkWUye9aUozSVVGmKspWRVFVlKuK8lVRoSrqwrXh6PzoMayjUk2UVlVRuirKVEXZqiiqinJVUb5Cb5j8U5FiVKyKSjVR+acppZeLmvwDlZNGnZuKj5nBXFWUr4oKVVGxKiqPPkQ7+xu1+tmJyT9cKUbpqihTFWWroqgqylVF+aqoUBUVq6Kqrg2qujao6tqgqmuDqq4Nqro2qOrayD98OSnbuTEnm4kKVVGxKirVROVfj3fq8tPnoeZUxl6V7Mxnhde3Jz4NQi0GcS0G8S0GCS0GiS0GSQ0GyT9H5B5EtxjEtBikxR3vW9zxvsUd71vc8b7FHe9b3PG+xR0fWtzxocUdH1rc8aHFHR9a3PGhxR0fWtzxocUdH1rc8aHFHR9b3PGxxR0fOe746xt+nwaxLQahFoO4FoP4FoOEFoPEFoOkBoMk1WIQ3WKQFnd84rjjC9/5NYlaDOJaDOJbDBJaDBJbDJL2H8Qq1WIQ3WIQ02IQ22IQajGIazGIbzFIaDFIbDFIiztet7jjdYs7Xre44zXLHX/9w1irqcUgrsUgvsUgocUgscUgqcEgRrUYRLcYxLQYJHufBDV9uyToZZl4ifEVMdmrOMw/fwiU1jExHzP5lODtOiZtj8l/syHEqVaGFNYxuiImu6DRzCtEa2757zRE42av5tcx2QIb5+9Qx1xu7npMyqxp/llpmK+44F696fQ5JrumiSZuyZt1TNoek3+cV4jRFTH5byOoeVEf34+5jrJVUVQV5aqifFVUqIqKVVGpJurC14tLUboqquraSFXXRqq6NlLVtZGqro1UdW3knwtcrTGUt/lp/lVtspkYWxFDFTGuIsZXxITNtYxUrIjZXptJq4oYXRFjKmJsRUz+OphfnZBCWse4ihhfERMqYmJFTNoek5fqhZjSdZCLqbgOTMV1kP+WcSHGVcT4ipiKemAq6oGpqAe2oh7YinpgK64DW3Ed2IrrwFZcB7biOrAVa2or1pQq1pQ2ruk/pz/99+P3zx9/+fLpz1PE41/+9fXXH5+/fX3544///TH9zS/fP3/58vn3n//4/u3XT7/99f3Tz1++/fr4dw/q5V//0pbCB219PGXzuOzWfSD3mNnTX6rkP2it9OP/0M9H0+lo8qc8Trn8Hw==",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "ndLNCoQgFAXgd7nrFqnd/l4lhrCyEMTCbGCI3n0smqEZ2ujm4hG/6+as0IlmGWqp+3GGslpBjS23ctQurVsEjZFKyaG+XkO8D0KO9/PE9R5ny42FkiUYgdCdOyFzvpdKQJnS7REBod6CeYvEW6CvoLd/FAnGJymSLPsaQvBAGILSEJSFoDwAsdsKFMiKD0LMf9Hm4pMbyRslzor1i24vjbOvSfyVbzJjK7rFiL2Glwa6WZEsotStdavf",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::header::Header"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret_for_L1_to_L2_message_consumption",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::header::Header"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "11235885384217001395": {
            "error_kind": "string",
            "string": "Function get_token can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAACMHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAaSQAAAC1HgIAAQkmAgIAAQo4AQIDIwIAAwAAAIUkAAAAxy4MAAIAASUnAIAEBHgADQAAAIAEgAMjAIADAAAAtCkBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFm+3iOgdB/bM7AQECJS0AGMoYyg==",
      "debug_symbols": "vZTdisJADIXfZa57MUkm8+OrLCJVRymUVmpdWMR331g63eoWZV31pjTlS84hSXNU67g8bBdFtan3avZxVGW9ytuiriQ6njK1bIqyLLaL8Welzw8bOn6/y6tzuG/zplUzsEFnKlZreXVaS4VNUUY1s3jKfsNac4I18gAD0QRtyPueNhTcQAeYgD1QKu2BYQzPM+XME7x7TLCYf6P3Z/TdwNB3e6/vwJS8Awdz23tATKUDWnPl3bunegd96V0UAr5aQZb29RL8bwnrBgnr+N7G+ZCW2Qfgq6mJxT/a6ZL4gSR8RAn9A0lEU0lsfOiTmLW73WIE73pYtn50AoyfoB2C7WmHdGcgYjiVdtrY27CcIkfD/xz0BT4/SfSZN0W+LGN/1DeHajW68e3XLl6d+11Tr+L60MTz4f+5+d0iIGekuwlLQCYjKxqi8w0=",
      "brillig_names": [
        "get_token"
      ]
    },
    {
      "name": "claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBHJgAABAMmAgUEBCYCBgQAHxgABgAFgEMtCIBDAAEtCIBEAAItCIBFAAMtCIBGAAQkAAAAUicCAAEEgEcmAgIEADoNAAEAAiQAABW3LAgBBgAAAQIBJgIHAQAsDgcGLAgBBgAAAQIBJgIIAAAsDggGLAgBBgAAAQIBJgIIAAIsDggGHgIABgAeAgAJADI4AAYACQAKJgIGAQEjAgAKAAAAsSQAABXgLAgBCQAAAQIBJgILBAwsCAAMLAwBDQAQAAsAJAAAFfIsBAAALAwNCiwNCgsAKAsCCywOCwomAgwEDSwIAA0sDAIOABAADAAkAAAV8iwEAAAsDA4LLA0LDAAoDAIMLA4MCyYCDAJqJgINApsmAg4CACYCDwLTJgIQArwsCAERJgISBEUAEAESASYDEQQBACgRAhIsDBITLA4QEwAoEwITLA4MEwAoEwITLA4NEwAoEwITLA4PEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAoEwITLA4OEwAo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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim_public"
      ]
    },
    {
      "name": "exit_to_l1_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "exit_to_l1_public"
      ]
    },
    {
      "name": "exit_to_l1_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::header::Header"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::header::Header"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7X3bruTGsey/6HkeKi91279iCIYv2oYAQTJk+QAHhv99c80M2a0he1Fd5GIHi/FirLGYzeyMYlRmkMH+z3d//+Gv//7Hn3/8+X9/+dd3//On/3z30y9/+8tvP/7y8/Cv/3wn9vn/+9c///Lz2z//9dtffv3tu/+RVMOn7374+e/DnzmE/3767n9//OmH7/4n6X8/zQ7WYuXrwVrS7eCSFw62KPXrwRarvn9wDXFMo4Zk08FS4sLRYtNHi1mZjta0dHDQNB4ccrw/+PtP34mzKgtViazKQlUSdFVKHqsiQdaqkouNSZegm6qSWZWFqhRWZaEqlVWZV0XD5qpYzfr1YA/hxnLVPp9APvoEuvkEYsFvPF1v1TdbwirqWP0aPdyns7BkpMax/MPfJX6bvZ06e1/K3nOd8Cpx7ZqyaS2ry+0E5kuL2TWO14lrvtt/68LBw9cbk4+ufn/wW+7xxLmnE+eeT5x7OXHu9by5Wzhx7nLi3PXEuduJcz/xvmon3lftxPuqnXhftRPvq3bifdVPvK/6ifdVP/G+6ifeV/3E+6qfeF/1E++rfuJ91U+8r/qJ99V44n01nnhfjSfeV+OJ99V44n01nnhfjSfeV+OJ99V4+L6apns8njR8m06FSicFrHQEK53D96gU45ROnqVjWOk4VjoRK52ElU7GurKwWDlhsXLGYuUsUEs5Y7FyxmLljMXKGYuVMxYr54yVTsFKp0KlUwJWOli9clGsdAwrHcdKB4uVCxYrFyxWLlisXLBYuWKxcsXqlStWr1yxeuWK1SvXCLVJ1ISVDpaCUbEUjIrFyhKwaFkCFi9LwCJmCVjMLAGLmiVgdcwSsFpmCVg9swSsplkClsIsgiUxi2CpGSJYcoYIGD8LGD8LGD8LGD8LGD8LGD8LWP+sYP2zgvXPCtY/K5beLMfbvVfywdI2RLHEDVEwflYwflYwfjYwfjYwfjYwfjaw/vl42/BKPmD9s4H1z4alPothyc9iYPqGg+kbDsbPDsbPDsbPDsbPDsbPDsbPDtY/O1j/7GD9cwTrnyOY/hzB9OcIpm8cb2NcyQeMnyMYP0cwfo5g/BzB+DmB8XMC65/BrIEC5g0UMHOgJDD9OYHpz2D+QAEzCEoC4+cMxs9gHkEBMwkKmEtQwGyCAuYTFDCjoIA5BQXMKigZTH8uYPozmFtQwOyCUsD4uYDxM5hjUMAsgwLmGRQw06CAuQYFzDYoYL5BATMOSgXTn19gHXw/HzB9A8w8KBWMnysYP4P5BxXMP6hg/kEF8w8qmH9QA1b/rGD+QQXzD2rA0p81YOnPCuYfVDD/oAoYPwsYP4P5BxXMP6hg/kEF8w8qmH9QwfyDCuYfVDD/oCqW/qyKpT8rmH9QwfyDqmD8rGD8DOYfVDD/oIL5BxXMP6hg/kEF8w8qmH9QwfyDalj6sxqW/qxg/kEF8w+qgfGzg/EzmH9QwfyDCuYfVDD/oIL5BxXMP6hg/kEF8w+qg+nPEUx/BvMPKph/UCMYP0cwfgbzDyqYf1DB/IMK5h9UMP+ggvkHFcw/qGD+QU1g+vML/IPv5wOmb4D5BzWB8XMC42cw/6CC+QcVzD+oYP5BBfMPKph/UMH8gwrmH9QMpj9nMP0ZzD+oYP5BLWD8XMD4Gcw/qGD+QQXzDyqYf1DB/IMK5h9UMP+ggvkHtYLpzxVMfwbzDyqYf1ArGD9XMH4G8w8qmH9QwfyDBuYfNDD/oIH5Bw3MP2gBq3+2gKU/W8DSnw3MP2hg/kELYPwsYPwM5h80MP+ggfkHDcw/aGD+QQPzDxqYf9DA/IMmWPqzKZb+bGD+QQPzD5qC8bOC8TOYf9DA/IMG5h80MP+ggfkHDcw/aGD+QQPzD5ph6c/2Av/g+/mA6Rtg/kEzMH42MH4G8w8amH/QwPyDBuYfNDD/oIH5Bw3MP2hg/kFzMP3ZwfRnMP+ggfkHLYLxcwTjZzD/oIH5Bw3MP2hg/kED8w8amH/QwPyDBuYftASmPycw/RnMP2hg/kFLYPycwPgZzD9oYP5BA/MPGph/0MD8gwbmHzQw/6CB+Qctg+nPGUx/BvMPGph/0DIYPxcwfgbzDxqYf9DA/IMG5h80MP+ggfkHDcw/aGD+QStg+nMF05/B/IMG5h+0CsbPFYyfwfyDBuYfNDD/oIH5Bw3MP+hg/kEH8w86mH/QA5b+7MHB8sHSNxzMP+gBi589YPGzg/kHHcw/6GD+QQfzDzqYf9DB/IMO5h90MP+gC5b+7IKlPzuYf9DB/IOuYPysYPwM5h90MP+gg/kHHcw/6GD+QQfzDzqYf9DB/INuWPqzG5b+7GD+QQfzD7qB8bOB8TOYf9DB/IMO5h90MP+gg/kHHcw/6GD+QQfzD7qD6c8Opj+D+QcdzD/oDsbPEYyfwfyDDuYfdDD/oIP5Bx3MP+hg/kEH8w86mH/QI5j+nMD0ZzD/oIP9/qCD+QcdzD/oYL8/6GD+QU9g/XMC658TGD9nMH4G8w86mH/QwfyDDuYfdLDfH3Sw3x/0DNY/Z7D++Xj/YC4yfnQu9m0+e/gHBxFgyufuGz/IR2MeP1rz7/KZHxw9pK8HR1efJS9nTl7PnLydOXk/c/LxzMmnMyefz5x8OXPy9cTJ1zPvsPXMO2w98w5bz7zD7uFafV3yZ95h65l32HrmHbaeeYetJ95hYzjxDhvDiXfYGE68w8Zw4h02hhPvsDGceIeN4cQ7bAwn3mFjOPEOG8OZd1g58w4rZ95h5cw7rJx5h93DOf5c8u/euY4SwfJJYPlksHwO363evfMYpWLlowEsHwHLR8HyMazrS8H4WcH4WcH4WTPYegbjZwXjZwPjZwPjZwPjZzOwfBwsnwiWTwLLB6x/tgKWT8XKxwNYPmD87GD87GD87GD87GD87GD87GD9s4P1zw7WP0ew/jkK1n4RFSwfMH0jOlg+YPwcwfg5gvFzBOPnCMbPCYyfE1j/nMD65wTWPycHywdMf05g+nMC0zcSmL6RwPg5g/FzBuPnDMbPGYyfMxg/Z7D+OYP1zxmsf85g/XMG058LmP5cwPSNAqZvFDB+LmD8XMD4uYDxcwHj5wLGzwWsf65g/XMF658rWP9cwfTn4z28K/mA6RsVTN+oYPxcwfi5YvFzClj8nAIWP6eAxc8pYPXPAxmA5YPVP6eA1T+ngKU/p4ClP6eApW8kwdI3koDxs4Dxs4Dxs4Dxs4Dxs4Dxs2D1zwnMP5jA/IMJzD+YFEt/ToqlPycw/2AC8w8mBeNnBeNnMP9gAvMPJjD/YALzDyYw/2AC8w8mMP9gAvMPJsPSn5Nh6c8JzD+YwPyDycD42cH4Gcw/mMD8gwnMP5jA/IMJzD+YwPyDCcw/mMD8g8nB9OcIpj+D+QcTmH8wRTB+jmD8DOYfTGD+wQTmH0xg/sEE5h9MYP7BBOYfTGD+wZTA9OcX+AffzwdM3wDzD6YExs8JjJ/B/IMJzD+YwPyDCcw/mMD8gwnMP5jA/IMJzD+YMpj+nMH0ZzD/YALzD6YCxs8FjJ/B/IMJzD+YwPyDCcw/mMD8gwnMP5jA/IMJzD+YKpj+XMH0ZzD/YALzD6YKxs8VjJ/B/IMJzD+YwPyDGcw/mMH8gxnMP5jB/IM5YPXPOWDpzzlg6c8ZzD+YwfyDOYDxs4DxM5h/MIP5BzOYfzCD+QczmH8wg/kHM5h/MIP5B7Ng6c9ZsfTnDOYfzGD+waxg/Kxg/AzmH8xg/sEM5h/MYP7BDOYfzGD+wQzmH8xg/sFsWPpzfoF/8P18wPQNMP9gNjB+NjB+BvMPZjD/YAbzD2Yw/2AG8w9mMP9gBvMPZjD/YHYw/dnB9Gcw/2AG8w/mCMbPEYyfwfyDGcw/mMH8gxnMP5jB/IMZzD+YwfyDGcw/mBOY/pzA9Gcw/2AG8w/mBMbPCYyfwfyDGcw/mMH8gxnMP5jB/IMZzD+YwfyDGcw/mDOY/pzB9Gcw/2AG8w/mDMbPBYyfwfyDGcw/mMH8gxnMP5jB/IMZzD+YwfyDGcw/mAuY/lzB9Gcw/2AG8w/mCsbPFYyfwfyDGcw/mMH8gxnMP5jB/IMFzD9YwPyDBcw/WAKW/lyCg+WDpW8UMP9gCVj8XAIWPxcw/2AB8w8WMP9gAfMPFjD/YAHzDxYw/2AB8w8WwdKfi2DpzwXMP1jA/INFwfhZwfgZzD9YwPyDBcw/WMD8gwXMP1jA/IMFzD9YwPyDxbD052JY+nMB8w8WMP9gMTB+NjB+BvMPFjD/YAHzDxYw/2AB8w8WMP9gAfMPFjD/YHEw/dnB9Gcw/2AB8w8WB+PnCMbPYP7BAuYfLGD+wQLmHyxg/sEC5h8sYP7BAuYfLBFMf05g+jOYf7CA+QdLAuPnBMbPYP7BAuYfLGD+wQLmHyxg/sEC5h8sYP7BAuYfLBlMf36Bf/D9fMD0DTD/YMlg/JzB+BnMP1jA/IMFzD9YwPyDBcw/WMD8gwXMP1jA/IOlgOnPBUx/BvMPFjD/YKlg/FzB+BnMP1jA/IMFzD9YwPyDBcw/WMD8gwXMP1jB/IM1YOnPNWDpzxXMP1iDg+WDxc81YPFzBfMPVjD/YAXzD1Yw/2AF8w9WMP9gBfMPVjD/YBUs/bkKlv5cwfyDFez3ByuYf7CC+Qcr2O8PVjD/YFWw/vkF/sH38wHjZwXjZzD/YAXzD1Yw/2AF8w9WsN8frGC/P1gNrH9+gX/w/XwO5+dcZPzoXGyWzw78HMXGfKKXtXw05vGjNf8un/nB0UP6enB09Vny+czJlzMnX0+c/B6ex9clL2dOXs+cvJ05eT9z8vHMyZ95h/Uz77B+5h3Wz7zDxjPvsPHMO2w88w4bz7zD7uG0fV3yZ95h45l32HjmHTaeeYeNZ95h05l32HTmHTadeYdNZ95h9/BKvy75M++w6cw7bDrzDpvOvMOmM++w+fAd9v0711nA8lGwfAwsn8N3q/fvPOYIlk8CyyeD5VPA8qlY11cB4+cCxs8FjJ+LYa3nAsbPBYyfCxg/FzB+LmD8XCpWPjWA5SNg+ShYPmD9c3WwfCJYPgksHzB+rmD8XLH4WULAIughISyGHhLCoughIaweekgIq4keEsLqooeEsNroIaEMtW8MCRW0hLCUDgmCJXUMCaExtaAxtaAxtaAxtaAxtaAxtWB11ENCWC31kBBaT61oPbViqdJDQliy9JAQlu4xJORoCaExtaIxtaIxtaIxtaIxtaExtaH11IbWUxtaT22OlhCWRj0khCVSDwmhqR+Gpn4YGlM7GlM7GlM7GlM7GlM7GlM7Wk/taD21o/XUjtZTO5pOHdF06oimfkQ09SOiMXVEY+qIxtQRjakjGlNHNKaOaD11QuupE1pPndB66oSmUx9vx1xLCE39SGjqR0Jj6oTG1AmNqTMaU2c0ps5oTJ3RemowK+KQEFpPDWZGHBJC06kzmk4N5keUAGZIHBJCY+qCxtRgnsQhITSmBnMlDgmhMTWYL3FICK2nBnMmSgCzJg4JoenUFU2nBnMnDgk5WkJoTF3RmBrMoTgkhMbUaB5FQfMoCppHUdA8ioLmURzuk6MlBKZTSwDTqQXNoyhoHkUJaEwtaEyN5lEUNI+ioHkUBc2jKGgeRUHzKAqaR1HQPIoiYDq1KJhOLWgeRUHzKIqiMbWiMTWaR1HQPIqC5lEUNI+ioHkUBc2jKGgeRUHzKIqB6dTyAo/iSkJo6geaR1EMjakNjanRPIqC5lEUNI+ioHkUBc2jKGgeRUHzKAqaR1EcTad2NJ0azaMoaB5FiWhMHdGYGs2jKGgeRUHzKAqaR1HQPIqC5lEUNI+ioHkUJaHp1AlNp0bzKAqaR1ESGlMnNKZG8ygKmkdR0DyKguZRFDSPoqB5FAXNoyhoHkXJaDp1RtOp0TyKguZRlIzG1AWNqdE8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUQqaTl3RdGo0j6KgeRSlojF1RWNqNI+ioHkUBc2jKGgeRUHzKCqaR1HRPIqK5lHUAKZTa3C0hMDUD0XzKGoAY2oNYEytaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoAqZTq4Dp1IrmUVQ0j6IqGlMrGlOjeRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6IamE6tBqZTK5pHUdE8impoTG1oTI3mUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iupoOrWj6dRoHkVF8yiqozF1RGNqNI+ionkUFc2jqGgeRUXzKCqaR1HRPIqK5lHUiKZTJzSdGs2jqGgeRU1oTJ3QmBrNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FDWj6dQv8CiuJISmfqB5FDWjMXVGY2o0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUdSCplMXNJ0azaOoaB5FrWhMXdGYGs2jqGgeRUXzKCqaR1HRPIqK5lFUNI+ioXkULYDp1BbAdGpD8yhacLSEwJjaAhhTG5pH0dA8iobmUTQ0j6KheRQNzaNoaB5FQ/MomoDp1CZgOrWheRQNzaNogsbUisbUaB5FQ/MoGppH0dA8iobmUTQ0j6KheRQNzaNoCqZTm4Hp1IbmUTQ0j6IZGlMbGlOjeRQNzaNoaB5FQ/MoGppH0dA8iobmUTQ0j6I5mk79Ao/iSkJo6geaR9EcjakdjanRPIqG5lE0NI+ioXkUDc2jaGgeRUPzKBqaR9Eimk4d0XRqNI+ioXkULaExdUJjajSPoqF5FA3No2hoHkVD8ygamkfR0DyKhuZRtIymU2c0nRrNo2hov6NoaB5FQ/MoGtrvKBqaR9EyWk9d0HrqgsbUBY2p0TyKhuZRNDSPoqF5FA3tdxQN7XcUraD11BWtpz7eo5iLjB+di80T2s7UFuqYkMkd9y4nVD18PbhmvaVT4sKxcqumpHT7qpqXDi55zFlKze8frDHVsYhJ/P7gL2UxlmWpLM6yLJUlsixLZUksy1JZMsuyVJbCsiyVpbIs87L4Dp7mLssiLMtSWdjlLpaFXe5iWZxlWSoLu9zFsrDLXSwLu9zFsrDLXSzLRbvcEtNYlir2/sHF0yjlFa9hVkO5aEv8VA1zGddhKb8/+EsNL9o/71rDizbbT9Uw6XhwSW9f6t00PIYy5uFR5/QpF23kX1lyZ8k3M8VFJ4pda3jR8eOVl/5FR5tXlvyiY9OuTMEZa3MNlTPW5jlVOWNtX4ecsbbXkEPT0dv4Dm88Y8mfLDlnrO1MwRlrew05NB1+6XNoOrzknLE2M4VxxtpeQ85Ym+dU44y1fR1yxtpeQ2cND97GjUPT4SXnjLWdKThjba8hh6bDL30OTUeX3DljbWYK54y1vYacsTbPqc4Za/s6dNZwcw05NB2+jXNoOrzknLG2MwVnrO015NB09KUfOTQdXnLOWJuZInLG2l5Dzlib59QdfvCD65Az1vYacmg6fBvn0HR4yTljbWcKzliba5g4NB196ScOTYeXnDPWdqbgjLW9hs4abp1TE2es7euQM9b2GnJoOnwb59B0eMk5Y21miswZa3sNOTQdfelnDk2Hl5wz1namcNZwcw05Y22eUzNnrO3rkDPW9hpyaDp8G+fQdHTJC2eszUxROGNtryGHpsMvfQ5Nh5fcWfLNTMEZa3sNOWNtnlMLZ6zt65Az1vYacmg6ehuvHJoOLzlnrM1MUTljba8hh6bDL31nyY8uOWes7UzBGWt7DTljbZ5TK2es7euQM9bWGsbAoengbTwGDk2Hl5wz1nam4Iy1vYbOGh596XNoOrzknLG2MwVnrO015Iy1dU6NgTPW5nUonLG215BD09HbuHBoOrzknLG2M4WzhptryKHp8EufQ9PhJeeMtZ0pOGNtryFnrM1zqnLG2rwOlTPW9hpyaDp6G1cOTYeX3FnyzUzBGWt7DTk0HX7pc2g6vOScsbYzBWeszTU0zlib51TjjLV9HXLG2l5DDk1Hb+PmLPnRJeeMtZ0pOGNtryGHpsMvfQ5Nh5ecM9ZmpnDOWNtryBlr85zqnLG2r0POWNtr6Kzhwdu4c2g6vOScsbYzBWes7TXk0HT4pc+h6eiSR85Ym5kicsbaXkPOWJvn1MgZa/s6dNZwcw05NB2+jXNoOrzknLG2MwVnrO015NB09KWfODQdXnLOWJuZInHG2l5Dzlib59TkrOHmdcgZa3sNOTQdvo1zaDq85JyxtjMFZ6zNNcwcmo6+9DOHpsNLzhlrO1NwxtpeQ2cNt86p+Zozlpn4mLP9nhG/lOWaY9NqWa452qyW5Zrjx2pZrjlRrJWlXHNIWC3LNRv51bJcs9leLcs1++fVsjjLslSWi3a5eZrkLcf5AFUu2uWuleWiXe5aWS7a5a6V5aJd7kpZ6kW73LWyXLTLXSvLRbvctbJctMtdK4uzLEtlYZe7WJaLdrn1NhPVLO8fvHarpV60Jd61hhftn5+q4b53qutFe/PXlTyFi/b9OzJFChcdEnat4UUnilde+hedVl5ZcmfJNzPFRcemXWvIGWu9hu8/ipUCZ6zt65Az1vYacmg6ehsXDk2Hl5wz1mamEM5Y22vIoenwS99Z8qNLzhlrO1NwxtpeQ85Ym+dU4Yy1fR1yxtpcQ+XQdPQ2rhyaDi85Z6ztTMEZa3sNnTU8+tLn0HR4yTljbWcKzljba8gZa/OcqpyxNq9D44y1vYYcmo7exo1D0+El54y1nSmcNdxcQw5Nh1/6HJoOLzlnrO1MwRlrew05Y22eU50z1uZ16JyxtteQQ9PR27hzaDq85M6Sb2YKzljba8ih6fBLn0PT4SXnjLWdKThjba5h5Iy1eU6NnLG2r0POWNtryKHp6G08Okt+dMk5Y21nCs5Y22vIoenwS59D0+El54y1mSkSZ6ztNeSMtXlOTZyxtq9Dzljba+is4cHbeOLQdHjJOWNtZwrOWNtryKHp8EufQ9PRJc+csTYzReaMtb2GnLE2z6mZM9b2deis4eYacmg6fBvn0HR4yTljbWcKzljba8ih6ehLv3BoOrzknLE2M0XhjLW9hpyxNs+pxVnDzeuQM9b2GnJoOnwb59B0eMk5Y21nCs5Ym2tYOTQdfelXDk2Hl5wz1nam4Iy1vYbOGm6dU+s1ZywPZUzDRev7B1cNYxpVV9MI0caKD397nZf8miPZS0t+zZHspSW/5kj20pJfc4J7YclzuObA99KSX3Pge2nJrznwRU3j2BxNy7ws15zhVsviLMtSWa45aa2W5ZrT0GpZrjmxrJblmlPFalmu2fmvlUWu2Z2vluWaHfRqWdjlLpaFXe5iWfyaZbE8phHd4sonZ9M8fnS2sjqImoZpELUY5kW/aA/92qJftEN/bdEv2v8fWPQ0L/pFp4sPLfqauCgXnV1eWnS96GT02qJfdO56bdEvOtU9V3SPaSp61JVniuQt1/Hwtxty86JfdGb80KLn6lPRiy4U3Vn044vOifQFRedE+oKicyJ9QdE5kb6g6JxIjy+6cSJ9QdE5kb6g6JxI/0DRhzJNRc9J51XkiLlHFZ1VXK9iqbcqVvF5FS86BLqXqYp59ZOHOk0frWGu1NlFp7qdq3jRMW3nKl507nquihZuH21m7x/uGkdh3zXfDpa6mEiYnr7xOwv6cPAXfC46op0FH7/oNHcafC46+J0Gn4vOiKfB56LT52nwceIDjQ8nZmx8OItj48MpHxsf6gfY+FA/gMYnUj/Axof6ATY+1A+w8aF+gI2PEx9ofKgfYOND/QAbH+oH2PhQP8DGh/oBND6J+gE2PtQPsPGhfoCND/UDbHyc+EDjQ/0AGx/qB9j4UD/Axof6ATY+1A+g8cnUD7DxoX6AjQ/1A2x8qB9g4+PEBxof6gfY+FA/wMaH+gE2PtQPsPGhfgCNT6F+gI0P9QNsfKgfYOND/QAbHyc+0PhQP8DGZ1k/KGUsuVdZwUdLrl8P1iq3H5sSLwtHFxvzqeX2ythFeEry8diSUlgDM5fbq+7C3RtAl1aJBJ1edRtyvD/4S1kyy7JUlsKyLJWlsiwLZanh4LKI6Hj028/13BfmS0KClpCiJWRoCTlaQhEtoYSWUEZLqKAlVLESKuFwpg5l+mE11ThPSNASOpyps0+/rpB/D9n84NuuPdDBbR+uSxOByvTBKrH87ugvX9Wu81X9Ol819vNVk01fNS991XSdr5qv81VLP191Olj1fsiavmq9zFeVcJ2vKh1tNndf1Ra+aj/dkoY8fVXNC1+1n25p9av6db5qR93S3bWqC/uqQHdL5XZskLryXYfRZTx6aBfW7v7Y9Gt3fndXaVHp1OF84xcc7kG9f7CYTMO2WfnvFg21CHSDd3l0oHtSEHTyVEPNvnLwnvcfikC30VdHR6E7/93Q+fJdj2/9VZaQWm4nfGyG8v1DEOVrg6B65uTtzMn7mZOPZ04+nTn5fObky5mTrydO3sKZkz/zDmtn3mHtzDusnXmHtTPvsHbmHdbOvMPamXdYO/MO62feYf3MO6yfeYf1M++wfuYd1s+8w/qZd1g/8w7rZ95h/cw7bDzzDhvPvMPGM++w8cw7bDzzDhvPvMPGM++w8cw7bDzzDhvPvMOmM++w6cw7bDrzDpugd9iSxvcAlBIWkofeYdeSh95haxqXjYQgv8t+frDb7c0HVu7yWK5Lf8/MJOiGg1g+hSV0/0Usn8ISuh0llk9hCd2dE8tnsMzQwwqxfApL6NmNWD6FJfQoSyyfwhJ6sieWT2HpxLIbLKn79IMldZ9+sKTu0w+W1H36wZK6TzdYFuo+/WBJ3acfLKn79IMldZ9+sHRi2Q2W1H36wZK6Tz9YUvfpB0vqPv1gSd2nGywrdZ9+sKTu0w+W1H36wZK6Tz9YOrHsBkvqPv1gSd2nHyyp+/SDJXWffrCk7tMLljVQ9+kHS+o+/WBJ3acfLKn79IOlE8tusKTu0w+W1H36wZK6Tz9YUvfpB0vqPt1gKdR9+sGSuk8/WFL36QdL6j79YOnEshssqfv0gyV1n36wpO7TD5bUffrBkrpPN1gqdZ9+sKTu0w+W1H36wZK6Tz9YOrHsBkvqPv1gSd2nHyyp+/SDJXWffrCk7tMNlkbdpx8sqfv0gyV1n36wpO7TD5ZOLLvBkrpPP1hS9+kHS+o+/WBJ3acfLKn7dIOlU/fpB0vqPv1gSd2nHyyp+/SDpRPLbrCk7tMPltR9+sGSuk8/WFL36QdL6j7dYBmp+/SDJXWffrCk7tMPltR9+sHSiWU3WFL36QdL6j79YEndpx8sqfv0gyV1n26wTNR9+sGSuk8/WFL36QdL6j79YOnEshssqfv0gyV1n36wpO7TD5bUffrBkrpPN1hm6j79YEndpx8sqfv0gyV1n36wdGLZDZbUffrBkrpPP1hS9+kHS+o+/WBJ3acbLAt1n36wpO7TD5bUffrBkrpPP1g6sewGS+o+/WBJ3acfLKn79IMldZ9+sKTu0w2WlbpPP1hS9+kHS+o+/WBJ3acfLJ1YdoMldZ9+sKTu0w+W1H36wZK6Tz9YUvfpBEsNgbpPP1hS9+kHS+o+/WBJ3acfLJ1YdoMldZ9+sKTu0w+W1H36wZK6Tz9YUvfpBkuh7tMPltR9+sGSuk8/WFL36QdLJ5bdYEndpx8sqfv0gyV1n36wpO7TD5bUfbrBUqn79IMldZ9+sKTu0w+W1H36wdKJZTdYUvfpB0vqPv1gSd2nHyyp+/SDJXWfbrA06j79YEndpx8sqfv0gyV1n36wdGLZDZbUffrBkrpPP1hS9+kHS+o+/WBJ3acbLJ26Tz9YUvfpB0vqPv1gSd2nHyydWHaDJXWffrCk7tMPltR9+sGSuk8/WFL36QbLSN2nHyyp+/SDJXWffrCk7tMPlk4su8GSuk8/WFL36QdL6j79YEndpx8sqft0g2Wi7tMPltR9+sGSuk8/WFL36QdLPxrLlB5h+SWho8UL9RjHo6P4+4tLVMcVIGp3QAVfODrFUL4enaLd1qIsLUVTHfMwNbtbXMtfcazi8Ge+P/hLFROruEMVM6u4QxULq7hDFSur+AeqWOuYhwWJsyrmwCruUEVhFderaLdu0YLXlZLf0tB41y4uHiylTE1dDTbHR4nPS/GpUzmk5vL+wT7NK17t/ut9gdIIZS9QOqHsBUoOqS+FUgdlZzw4qG+CkpNyN1ByXH8tlCJjpVWszttSCgHY+FBigManULx4LT7q4yerlpU0xMp0H8rDXEMp1FA6ApOCy4nAjDbdP40xbek4C9WZa+LuxP2SuFP3ORPuedL7Yt2k9xWKRNfEnYrS/rjfoFxl47UbnYWK0mvx2e+WSqH41AuUlTrVS6Hc8ZZKpUrVDZTUqF4L5Yq6X6klYePjxAcaH2ozr8VnzxsqlYJLR2BSRTkRmPup5ZXqzDVxp5RzRdwlUPc5E+573SWRQJHomrhTUdod96Q6fsMU46a+WwIVJWx8nPi8FJ8dWx+KT91ASempGygpPL0Yyv16TWpJ3UBJeeiPQCkSxoNF49q4uN/bQ4bzEp+X4rPbk1giVGa6gZJiSzdQUpd5KZT7PVQn4oSyFygp4bwWyvef7xKhLoOND8UWbHyooLwWnx0fqROhhtIPmErB5URg7nd7QqnOXBN3SjnXxJ26z5lw3+2GlzpxvyTuVJT2x32/t4eIUlF6LT773VJRik/dQEmd6qVQ7nhLRalS9QKlUaN6LZQr6r5RS8LGh5oPNj7UZl6Lz543VMwJZj9gUkU5EZj7qeVGdeaauFPKuSbu1H3OhPtud0mMItElcXcqSrvjvufbKZyKEjY+VJRei89+rY9TfOoGSieUvUBJ4enFUO7Xa1JL6gbKw+WhmKeb6MniOaAcvuKUdMl53jwWVnGHKlZWcXsVY2AVd6iisIp/oIq13l6QJfOhOiqruEMVjVV85c+lrj34Hp34vBSf/Z6WjpFQ9gJlIpS9QMkh9aVQ7vjge+Sk3A2UHNdfC+XKM9iJQgA2PpQYsPGhePFafPZ87D1RQ+kITCeY5wFzv0cIEtWZa+JOKeeauFP3ORPuuz2UkigSXRN3Kkr7477jG74yFaXX4rPfLZVM8akbKKlTvRTKHW+pZKpU3UDphPKlUK6o+5laEjY+1Hyw8aE281p89ryhkim4dAQmVZQTgbmfWl6ozlwTd0o518Sdus+ZcN/tLkmhSHRN3J247437nm+QKlSUsPGhovRafHZsfSg+dQMlpaduoKTw9GIod+s1K7WkbqCkPLT/C6F3fHtIpYzzWnz2exKrUpnpBkonlL1ASV3mpVDu+FBdpYTTDZSUcF4L5crzXZW6DDY+FFuQ8RmYkvi8FJ8dH6nTQA2lIzApuJwIzN1uT2igOnNN3J24XxJ36j5nwn2vG14aKBJdE3cqSvvjvt/bQzRQUXotPrvdUtFA8akXKIU61Uuh3O+WyqBIEspeoKRG9VooV9R9oZaEjY8TH2h8qM28Fp89b6gIBZeOwKSKciIw91PLherMNXGnlHNJ3JW6z5lw3+0uiVIkuibuVJR2x33Ht1OoUlHCxseJz0vx2bH1ofjUDZSUnrqBksLTi6Hcr9ekltQNlIfLQ/kGZQnhHsrPCVlAS+jwgTrHcEtI5gkpWkKHjzbVJshqKfOEHC2h7R2pBR+vYwupriSUZSSI7Ld0hqW+cGypY+73X3T52PfJxNI1vuaDTiaNV8nwjfX9rykS09RYSSy3qrydb76+pMbx2ds363a8P/xLTgUwp8W9JQYZd7ph6y3v55RNRySyeb6dYnHDjTJesxbr7duWJYhrmPSAYVHe7fvLPUWe1rCUcPtoTUsHB50elA453h/8uS4edqhLvNXlDtjFugxQjh2O3HUW+lX5cNkhnarThWgrMEnJE07D35a2rjPXs38BO/gLVLPx6CE5sXlGizvocOTIt1GSv59RrOOXTuF2qGndfuVO7UgNydauXLthZVY2XrkRuSyvI7TEsiyVJa+VRUNaaUNlqsvbrb1tPF+2p6O3PldrWGGZGG8uhjhMWXOWqWgZxXBwRqn6CNrwd8rzjAQuI901I79TO5bbuikfS3edznCRDf/4668//vTTj//480+//O0vv/34y8//egsMb/8jD1ip6Hjq4c+7Kzy/fTt5cM2uBJWWoNoQ9GB9rgRJS5C2BFlLkLcExZaglhURW1ZEbFkRsWVFpJYVkVpWRGpZEallRaTlFVFt3MljjXUWFFuCUktQbgkqLUF1NSj7t0H5QfXKpHMPg8UsaPE7JU1TkNZ5UGkJqg1By799txa0/J3itFENQnueBZWWoNoQtPwO9rUgaQnS5aA09dyxlFmQtQR5S1BsCUqrQXfS3ZegBy9tS0mmoKR1FiQtQdoSZC1B3hK0XL00tccppW+J5YH/dC1oMb0cyiRXhDoPWr5yUx3nvpTv7tSMQaUlqDYELT9bm4pPJS+xzIKkJUhbgqwlyFuCYktQagnKDUH2AKfprkEqOuOI5btZOUw3lXNIOgvylqDYcGks32NZC8otQaUlqDYELQvia0HSEqQtQdYS1MJ73rIivGVFeMuK8JYV4S0rIrasiLjOe/OLMHpLUGwJSi1BD3ivjsSSapjt7suTWqqT6D9oPHEWZC1B3hIUW4KWq1e13ILSLCi3BJWWoNoQlENLkLQEaUvQA5zKbe2VGU45re6EPrtyc24JKi1BtSGohJYgaQnSliBrCXqwP02PXyx1LCU2tDkltQTllqDSElQbgmpoCZKWIG0JauhhbblJFB+m5vF+wPB3nYWVprDl9k3cpicsh78tzsK0LczawrwtLLaFpbaw3BZW2sJqU9hyQzccOskUb2FpFiZtYdoWZm1h3hYWnw8b/iFvBy8L+BLidF9t+Nu/veiW+8LVKGuK8qao2BSVmqJyU1RpiqotUcv94XCfqE5WthT0W3lquUFcjdKmKGuKWl4bw5H1FuWzqNgUtVz5NGxKU9Rw7+ibqOWObzjyZiJMGr5tqpZbvtUobYqypqgHlb+Zloe/47dUVWJTVGqKyk1RpSmqtkTV0BT1YG1oLLeo9C0DVG2KsqaoR2vj7voaRtb7qGXzzXSSQeotK4fH28Ax/D27dVUjYE4JMKcMmFMBzKni5SQhICYliEkpYlL2kqSs3CU1uz0e9iLzcEsqp9lZ4iFnSYecJR9ylnLIWeoRZ5FwyFnkkLM8Yha5a+p0HmZtYd4WFtvCUltYbgsrbWG1KUxDW5i0hbWtEm1bJfpoldRJaksmcRYW28JSW1huCytNYfYAbqs3MvD5A6UmbWEPSuI3rTPdm63GsAdLOebb+BVnt6/FQ1uYtIVpW5i1hXlbWGwLS21huS3swVJON3dQSjbr0B4I6UPYbXGlKO/va8NKnJzKmn9nVV7wB3kYM4p+//sFn33ND7wFr0xI0BJStIQMLSFHSyiiJZQ+NqHvH1pWdj5HOeAcz1Pk9w8tMeth0hb2qNj5doMh5W8fM5UH93ZSlumO0BA12zXyIwqqt80mh1mS2drCvC0stoWltrDcFlbawmpT2KMbSmthD9Zk1vtVMvejaFuYtYV5W9iDVZLTbSrKJczCUltYbgsrbWG1KezRraW1MGkLe7BKSriFFZkx16O7S2th3hYW28IerZJ6Hzbr5R/dR1kLK21htSVMH90vWAuTtjBtC3u0Sm66dSqeZ2HeFhbbwlJb2INVUvQ+bGZHeaT9roXVprBH6uxamLSFaVuYtYU9WiV3PVcpMguLbWGpLSy3hT1aJek+bPbI5yP9dCXskX66FiZtYdoWZm1h3hb2qC/xWztTfu8tXXrtUL79WrLlOntO/pHc+uRZyvT20uFvnbHwI3V257OUQ85SjzjLI4V557PIIWfRQ85ih5zF9znL9D7B4e/ZM7kPLJnbvsvCWdIhZ8mHnKUccpadrn2/vQuuzB76VA+HnEUOOYsechY75Cx+yFniIWdJh5xlp2s/3V2VeTYHedn/uyycpR5xlhgOOYsccpadrv06PTJjNcw4OdohZ/FDzhIPOUs65Cz5kLOUQ85SjzhL2ufar+F2VVaZiRZJ9v8uC2fRQ85ih5zFDzlLbLkT9+CFBOthuS2stIXVprC2m5MPXk2wHqZtYdYW5m1hbaskt62S3LZKctsqyW2rpLStkkd3Gd9/qk4f3WX023PzydPsXV2P7jKuhaW2sNwWVtrCalPYo7uMa2HSFqZtYdYW1rZKatsqqW2rpLatktq2SmrTKjFpe6/Dg/sQa2Ha9l4HbXuvw4M7A6thbe910Lb3Omjbex207b0O2vZeBwttYW3vdbC29zpY23sdzNvCYltYej5s+Ie+HfzolYrjPJLvXGti8mXTfz6kPB9Snw559NLG90Lk+RB9PsSeD/HnQ5ZfsVRHri5hHpKeD8nPh5TnQxbRv/2yWrl7re/XkGUJ/v0QeT5Enw9ZRP828t8PlmOIPx8Snw9Jz4csol+n9xfUaLOQ8nxIfTpkWYR9P0RWQu46mzFEnw+x50OW0S/jvljvnCRjSHw+JD0fkp8PefDSmzz1dOHux1TGoNoQ9ECKWwmSliBtCbKWIG8Jii1BqSUotwS1rIjUsiJyy4rILSsit6yIBypUuD37LHdv1nwL+vTU0d8/fF3SrqeIH3+K9PGnyB9/ivLhpyg7rKh0e5fu/as/w+efcCo7IHH/0n+ZneBpHL5/+AqnlaDaEFTLBxe41h1OcPtpk1y+PcGjV8bseQb58DPoh59hjytp8lCkXOdn8A8/Q/zwM6QPP0P+8DOUDz9D/egzSPhgWn70KpU9z6Affgb78DP4h58hfvgZ0oefIX/4GcqHn6F+9Bn0w69p/fBrWj/8mtYPv6b1w69p/dhreviXvR25TE7l9pPYgwz7ex/98A9/HDn0ebc3EN/dp5GlX2LNk+cy3/2CoHz+feFHnLbXx6ftH2/jTzvnuzctf/34vMPHT79N87sfJf/88eVjP75u//jbPYmav/n4RyS218fL5o8v06t2in+7ch7R11MfP16X5e69vl8/3rZ//GQILPPi+I4fX7+5rIZ/xHeoYSCvibtC+WNXjPh031dS+mOXwfsx9fmYBwv2/RhpiNGGGGuI8edjHtx7e3+jSG+HPnCODGtuOpverYYvPy//wAiyEuQtQbElKD0dNPwrvx27vJhinej47md7h07mc2BhHe/rWD/XcfkmvU33XMMdj1l4fH29H2LPh/jzIfH5kPR8SH4+pDwfUp8OWX5Eo0wvZL137L+FzPckSyN1Wbl7fns41fePHufY7+P1Yz/envv47x89JvJ+SHw+JD0fkp8PKc+H1KdDPDwfIs+H6PMhy+hPP5lXav3ji+v+t92/LK5lpt/v4+PHfnz62I/PH/vx5WM/vn7oxy8/WrPfx8uOHz8n1eVHdvb7ePvYj1+8aus0tFbL3/LIg0eB3g1Jz4fk50PK8yH16ZDlx4DeD5GnQ5Yf+Hg/xJ4PWURfp+FNU/52wSw/jvF+SHo+JD8fUp4PqU+HLBuL3g9ZRF/z+LYPrbOrcvklie+H2PMh/nxIfD4kPR+Snwz57/DP//eXX3/8y19/+uFfQ8jbf/33z3/77cdffv76z9/+/z/H//LXX3/86acf//Hnf/76y99++Pu/f/3hzz/98re3//Zd+Po/fzLxT2bx+8/K9p/E/JO4f/92q3X4p9b0yYK8/fMNWQvlk0mYfv/wc7zbJ0v+Nd7rp1jHaBuUKwt5IVrHaInySbKOZ9fySayM8TJMP1+TeYsXH/5rDDcR/vMx+ZPqTV3/nHT+ZHpT1T5nMiSSJ2nFPifzycN4ouGDo01Sw5cPsU9aJhHhcUSdIoatJ4cx1xo+1SGH/w54/R8=",
      "brillig_names": [
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_arguments_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "portal_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "_assert_token_is_same",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17456365777023668047": {
            "error_kind": "string",
            "string": "Token address is not the same as seen in storage"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "7408320001641276198": {
            "error_kind": "string",
            "string": "Function _assert_token_is_same can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgIEASYCAwQAHxgAAwACgEMtCIBDAAEkAAAAQCcCAAEEgEQmAgIEADoNAAEAAiQAAACjHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAADMHgIAAgEeAgADAAo4AgMEIwIABAAAAIUkAAAA3iYCAgABLgwAAgADCjgDAQIjAgACAAAAoiQAAADwJScAgAQEeAANAAAAgASAAyMAgAMAAADLKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVmz6PKYD/jJjsBAQIlKQEAAQXyQXgvuMgPTzsBAQIlLQAYyhjK",
      "debug_symbols": "5VXbboJAEP2XfeZh57I3f6VpDCoaEoIGsUlj/PcOhqWUEomKfekLYTbnzJydnctZbbLVabfMy+3+qBZvZ1Xs12md70uxzpdEraq8KPLdsn+sdPOx4Yo/HtKyMY91WtVqATboRGXlRn6d1uJhmxeZWli8JL/BWpsI1mg6MBCNoJm8b9FMwXXoACNgDxRdezDQB78nyvEM2j1GsIj/Q+1z5J2hy7udyjsYitrBBL6tPSBG1wEtD7R7N6t20D+1S4SAr44gRfv6EObpEGwMxYozFiYqDnUsZo/gBq8mEp+XM18DANybnYaE+hGSf4BENEYyhLYlGWK+nS0E71qw9FNvuLAfQTuE6NohTeRWBEfXTrO9DZYh56ibFEHb4VOQ/z93ZZ68q7HDYuDwAMm4e0kXsT7SKk9XRdZu7u2pXPcWef15yAY7/VDt19nmVGXNdv9e7Ndux5AQX5tNDOlGchJD4nwB",
      "brillig_names": [
        "_assert_token_is_same"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "portal_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::_assert_token_is_same_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::_assert_token_is_same_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret_for_L1_to_L2_message_consumption",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "107": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "111": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "114": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "115": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    utils::arr_copy_slice,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "120": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "123": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "124": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "126": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice,\n};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"
    },
    "128": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "130": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "131": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"
    },
    "133": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "148": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "166": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "185": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "203": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\npub mod arrays;\npub mod field;\npub mod reader;\npub mod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "204": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "205": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "218": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "227": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "234": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "276": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Deserialize, Empty, Serialize, ToField}, utils};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"
    },
    "289": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "292": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "295": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "299": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "302": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "329": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr",
      "source": "// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::encode_and_encrypt_note_unconstrained,\n        },\n        keys::getters::get_public_keys,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n        // TODO: constrain encryption below - we are using unconstrained here only because of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from_ovpk_m, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(&mut context, from_ovpk_m, to, from),\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from_ovpk_m, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: Field) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // recipient of the outgoing: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let from_ovpk = get_public_keys(from).ovpk_m;\n        let setup_log = note_setup_payload.encrypt_log(context, from_ovpk, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // TODO(#8271): Type the amount as U128 and nuke the ugly cast\n        let amount = U128::from_integer(amount);\n\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueud call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // recipient of the outgoing: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: Field,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: Field, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U128::from_integer(amount);\n\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Since user is the logical sender of all the notes we get user's ovpk and use that in all of them.\n        let user_ovpk = get_public_keys(user).ovpk_m;\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            user_ovpk,\n            user,\n            user,\n        ));\n\n        // 4. We prepare the partial notes\n        // TODO(#9887): In each `_prepare_private_balance_increase` call we fetch the user's ovpk_m 2 more times. This is\n        // very inefficient.\n        let fee_payer_point_slot =\n            _prepare_private_balance_increase(user, fee_payer, &mut context, storage);\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund(Field,Field,Field)\") },\n            [fee_payer_point_slot, user_point_slot, funded_amount],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 14],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_slot: Field, user_slot: Field, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, fee_payer_slot, tx_fee);\n        let user_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, user_slot, refund_amount);\n\n        // 4. At last we emit the note hashes and the final note logs.\n        fee_payer_finalization_payload.emit();\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"
    },
    "345": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "346": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr",
      "source": "// docs:start:mint_to_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_to_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes:[u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"mint_to_public(bytes32,uint256)\".as_bytes(), 31) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_to_public_content_hash_nr\n\n// docs:start:get_mint_to_private_content_hash\n// Computes a content hash of a deposit/mint_to_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_private_content_hash(\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 36];\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"mint_to_private(uint256)\".as_bytes(), 24) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_to_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"withdraw(address,uint256,address)\".as_bytes(), 33) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"
    },
    "50": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "51": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "62": {
      "path": "/home/josh/Documents/test/token-bridge-tutorial-test/packages/aztec-contracts/token_bridge/src/main.nr",
      "source": "// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract TokenBridge {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view},\n        storage::storage,\n    };\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        token: PublicImmutable<AztecAddress, Context>,\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.initialize(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read(),\n            message_leaf_index,\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_to_public(to, amount).call(&mut context);\n    }\n\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    /// TODO(#8416): Consider creating a truly private claim flow.\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read(),\n            message_leaf_index,\n        );\n\n        // Read the token address from storage\n        let token_address = storage.token.read();\n\n        // At last we mint the tokens\n        Token::at(token_address).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n    }\n\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n    }\n\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read(), content);\n\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n\n    #[public]\n    #[view]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n}\n"
    },
    "85": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "87": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "91": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "93": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        header::get_header_at,\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: Header,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "96": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "98": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "99": {
      "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    }
  }
}
