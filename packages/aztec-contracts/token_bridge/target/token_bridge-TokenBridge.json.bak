{"noir_version":"0.30.0+c363d6fb324a83b35cf5aa1bfd39f62b9198f0b6","name":"TokenBridge","functions":[{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":39}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"return_witnesses":[472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":4,"end":5}],"caller_on_l1":[{"start":5,"end":6}],"inputs":[{"start":0,"end":3}],"nonce":[{"start":6,"end":7}],"recipient":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":40,"end":41}],"inputs":[{"start":0,"end":39}],"secret_for_L1_to_L2_message_consumption":[{"start":41,"end":42}],"secret_hash_for_redeeming_minted_notes":[{"start":39,"end":40}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"return_witnesses":[929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}],"portal_address":[{"start":4,"end":5}],"token":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"5Z3hjhy3sYXfRb+Niy4Wi1X0q1xcXCiJEwgw5CBWAgRG3j3rZGZHhieid3fO0WnmlyGrm6yS9jtdO/s19dO7P3z3u7/+6f8/fPzjDz+++/Z/f3r3/Q+/f//pww8fn37107vjf+z41//98c/vP/78P3789P4vn959e3zz7ruPf3j67z++effHD99/9+7bnv/4v29+vt5eeH174fX+wuv7C6+PF14/Xnh9vvD6euH182XXtxf+/bYX/v223/73+82vLrPsebnScszni2fduTha2OXiaOO28vBLJS5TSZepJGQqGTKVpEwlJVPJVKnED5lKTKYSmYx1mYx1mYx1mYx1mYx1mYx1mYx1mYztMhnbZTK2y2Rsl8nYLpOxXSZju0zGdpmM7TIZ22UyNmQyNmQyNmQyNmQyNmQyNmQyNmQyNmQyNmQyNmQydshk7JDJ2CGTsUMmY4dMxg6ZjB0yGTtkMnbIZOyQydiUydiUydiUydiUydiUydiUydiUydiUydiUydiUydiSydiSydiSydiSydiSydiSydiSydiSydiSydiSydgpk7FTJmOnTMbOt2XsvF5p1fqXK7Fm10qsxe3irEslXaaSkKlkyFSSMpWUTCVTpRI7Dp1STKeUplOKTM7aIRO0dsgkrR0yUWuHTNbaIRO2duikremkremkremkremkremkremkremkremkremkremkbdNJ26aTtk0nbZtO2jadtG06adt00rbppG3TSdumk7auk7auk7auk7auk7auk7auk7auk7auk7auk7auk7ZdJ227Ttp2nbTtOmnbddK266Rt10nbrpO2XSdtu07ahk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7aDp20HTppO3TSduik7dBJ26GTtkMnbYdO2g6dtB06aZs6aZs6aZs6aZs6aZu8tLU5b6XE56X8+uKy67X1mal8qzpOWfU4ZdV5yqpLoOpLKVOmlDp0SjGdUppOKa5TisKT4VKKQtxfSiHO4enPpdT4chq2vL4H5MetCI9r1XnKqkuz6na9tvXbV8jTR/7Xsucpy57HOcu2c5bdzlm2n7Psfs6yQ7PsiGvZaffKFn1GrsoWfUiuyhZ9Sq7KFn1Kfrnsdog+JVdliz4lV2WLPiVXZYs+JVdlE5+S81qK+fHrb7Ma823QVSm8fPXxXEq3/uW/zKefvz9/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"},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":41,"end":42}],"caller_on_l1":[{"start":42,"end":43}],"inputs":[{"start":0,"end":39}],"nonce":[{"start":43,"end":44}],"recipient":[{"start":40,"end":41}],"token":[{"start":39,"end":40}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"return_witnesses":[1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578],"error_types":{}},"bytecode":"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","debug_symbols":"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Vam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRlZobVam5UZWaG1WpuVGVmhtVqblRjZob1ai5UY2aG9WouVFtYz5rGzU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqUXOjGjU3qlFzoxo1N6pRc6MaNTeqU3OjOjU3qlNzozo1N6pvzGdtp+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kZ1am5Up+ZGdWpuVKfmRnVqblSn5kaFjRocdQuf+bS9hc983N7CZz5vb+EzH7i38JlP3Fv4zEfuLXzmM/cWPvOhewuf+9SlRkjdwuc+dakhUrfwuU9daozULXzuU5caJHULn/vUpUZJ3cLnPnWpYVK34LhPXWqc1C047lOXGih1C4771KVGSt2C4z51qaFSt+C4T11qrNQtfO5TlxosdQuf+9SlRkvdwuc+danhUrfwuU9darzULXzuU5caMHULn/vUpUZM3cLnPnWpIVO38LlPXWrM1C187lOXGjR1C5/71KVGTd3C5z51qWFTt/C5T11q3NQtfO5Tlxo4dQuf+9SlRk7dwuc+damhU7fwuU9dauzULXzuU5caPHULn/vUpUZP3cLnPnWp4VO38LlPXWr81C187lOXGkB1C5/71KVGUN3C5z51qSFUt/C5T11qDNUtfO5TlxpEdQuf+9SlRlHdwuc+dalhVLfwuU9dahzVLXzuU5caSHULn/vUpUZS3cLnPnWpoVS38LlPXWos1S187lOXGkx1C5/71KVGU93Cpz51AzebKnCzqQI3mypws6nCRn3qBm42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV4GZTBW42VeBmUwVuNlXgZlMFbjZV5GZTRW42VeRmU0VuNlXcqE/dyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaaK3GyqyM2mitxsqsjNporcbKrIzaZK3GyqxM2mStxsqsTNpkob9ambuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VSJm02VuNlUiZtNlbjZVImbTZW42VTCzaYSbjaVcLOphJtNJRv1qSvcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqYSbTSXcbCrhZlMJN5tKuNlUws2mEm42lXCzqTI3mypzs6kyN5sqc7Op8kZ96mZuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeZmU2VuNlXmZlNlbjZV5mZTZW42VeFmUxVuNlXhZlMVbjZV2ahP3cLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mKtxsqsLNpircbKrCzaYq3Gyqws2mqtxsqsrNpqrcbKrKzaaqG/WpW7nZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUlZtNVbnZVJWbTVW52VSVm01VudlUjZtN1bjZVI2bTdW42VRtoz51GzebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqcbOpGjebqnGzqRo3m6pxs6kaN5uqc7OpOjebqnOzqTo3m6pv1Kdu52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42VedmU3VuNlXnZlN1bjZV52ZTdW42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j0jYmNNKmzGnlTZjTittYi1hY04rYfPFRyRszGklbMb4iIStOS1szviIhK05LWzW+IiErTktbN74iIStOS1s5viIhK05LWye+YiErTktbKb5iIStOS1srvmIhK05LWy2+YiErTktbL75iIStOS1sxvmIhK05LWzO+YiErTktbNb5iIStOS1s3vmIhK05LWw++oiErTktcPb6gIStOS1w/vqAhK05LXAG+4CErTktcA77gIStOS1wFvuAhK05LXAe+4CErTktcCb7gIStOS1wLvuAhK05LXCO+4CErTkta4z4ZI0Rn6wx4pM1RnyyxohP1hjxyRojPlljxCdrjPhkjRGfrDHikzVGfLLGiE/WGPHJGiM+WWPEJ2uM+GSNEZ+sMeKTNUZ8ssaIT9YY8ckaIz5ZY8Qna4z4ZI0Rn6wx4pM1RnyyxohP1hjxyRojPlljxCdrjPhkjRGfrDHikzVGfLLGiE/WGPHJGiM+WWPEJ2uM+GSNEZ+sMeKTNUa8WGPEizVGvFhjxIs1RrxsYi1hY05LrDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaI16sMeLFGiNerDHixRojXqwx4sUaIz5bY8Rna4z4bI0Rn60x4vMm1hI25rSyNUZ8tsaIz9YY8dkaIz5bY8Rna4z4bI0Rn60x4rM1Rny2xojP1hjx2RojPltjxGdrjPhsjRGfrTHiszVGfLbGiM/WGPHZGiM+W2PEZ2uM+GyNEZ+tMeKzNUZ8tsaIz9YY8dkaIz6vBNTuNf79073+899+pbvQoXQi3ZVQy721R7q9HqS70HZ1Jt2FNqsz6YqtdBdq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NSm921GT0rsdLSmbdztqUnq3oyaldztqUnq3oyaluJRaUnq3oyaldztqUnq3oyaldztqUnq3oyVl925HTUrvdtSk9G5HTUrvdtSkFJdSS0rvdtSk9G5HTUrvdtSk9G5HTUrvdpSkDJt3O2pSerejJqV3O2pSerejJqW4lFpSerejJqV3O2pSerejJqV3O2pSerejJWXwbkdNSu921KT0bkdNSu921KQUl1JLSu921KT0bkdNSu921KT0bkdNSu92tKSM3u2oSendjpqU3u2oSendjpqU4lJqSendjpqU3u2oSendjpqU3u2oSendjpaUybsdNSm921GT0rsdNSm921GTUlxKLSm921GT0rsdNSm921GT0rsdNSm929GSUrzbUZPSux01Kb3bUZPSux01KcWl1JLSux01Kb3bUZPSux01Kb3bUZPSux0tKbN3O2pSmuh2Xuma6Ehe6ZroGl7piq10TbjvV7omHPIrXRMu9pWuCaf5SteEG3yma2Me/CtdW67Kxlz1V7q0ruqVgvCnQOt+XinQOppXCrQu5ZUCrfN4pUDrJp4p8M5QfqVAe+q/UqA9yV8p8J/OvDNyXynwn868M2FfKfCfzrwzUF8p8J/OvDM/Xynwn868My5fKfCfzrwzHV8p8J/O2DMMg4RXCrn8I4U//Est9qTBEQlDn/wjEob2CQMSxp6tNyJhaA8yImFoxzIiYWh/MyJhsZYwtHcakbA1p4U95WxEwtacFvbEMP2EI/ZcrxEJG3NaEXtG1oiEjTmtuIm1hI05rYg9u2lEwsacVsSegzQiYWtOC3um0IiErTkt7Pk8IxK25rSwZ92MSNia08KeGzMiYWtOC3sGy4iErTkt7HkmIxK25rSwZ4OMSNia08KeszEiYWtOC3tmxYiErTkt7PkPIxK25rSwZymMSNia08KeSzAiYWtOC5vxPyJha04Lm5c/ImFrTgubPT8iYWtOC5vjPiJha04Lm4k+ImFrTgubLz4iYWtOC5vVPSJha04Lm3s9ImFrTgubIT0iYWtOC5v1PCJha04Lm/c8ImFrTgub+TwiYWtOC5v7PCJha04Lm/08ImFrTgub/zwiYWtOC5sXPSJha04Lm0U9ImFrTgubcz0iYWtOC5uhPSJha04Lm889ImFrTgub/T0iYWtOC5srPiJha04Lm1k+ImFrTgubhz4iYWtOC5u1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8+Hkpc4+2+4j0/bZMR+a1spL9dmnHprWykv12R0emtbKS/XZkx2a1spL9dkJHZrWykv12X8cmtbKS/XZ9Rua1spL9dlrG5rWykv12eEamtbKS/XZVxqa1spL9dnNGZrWykv12UMZmtbKS/XZuRia1spL9dkvGJrWykv12aUXmtbKS/XZGxea1spL9dmRFprWykv12QcWmtbKS/XZfRWa1spL9dnzFJrWykv12WkUmtbKS/XZ3xOa1spL9dlVE5rWykv12csSmtbKS/XZQRKa1spL9dm3EZrWykv12S0RmtbKS/XZoxCa1spL9dkZEJrWykv1eR8/NK2Vl+rzhn1oWisv1eed+dC0Vl6qz1vwoWmtvFSf99pD01p5qT5vqoemtfJSVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnp9W756fVu+en1bvnl9W755fVu+eX1bvnl9W755fj2E1rZOXuqzePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb+s3j2/rN49v6zePb/6vI29PB6Pr0Nfbz77J+dYxvmacNm349s5/nLC8/r85PXNJ+9j/fWz+9hmCrXxCG0VauNruirU5930tgq18Y9tFWrjedsq1Mant1VooFBxhdp0y20VatOHt1WITqG6QnQKmQqdryPv1z5TiE6huEJ99oe0VYhOobpCdAqZCj2/FDpmCtEpVFdooFBxhegUqitEp1BdITqF6grRKWQqtL9+12c/Zr/r02cnVVeF+uzRaqsQnUJ1hegUqitEp1BdoYFCxRWiU6iuEJ1CdYXoFKorRKdQXSE6heIK9dkn2VYhOoXqCtEpVFeITqG6QgOFiitEp1BdITqF6grRKVRXiE6hukJ0CsUV6rNXua1CdArVFaJTqK4QnUJ1hQYKFVeITqG6QnQK1RWiU6iuEJ1CdYXoFIordNIpVFeITqG6QnQK1RWiU6iu0ECh4grRKVRXiE6hukKueUj8kuLlmlrUHF2zhZqjawJQc3T16WqOA44Sjq6eV83R1ZmqObp+J6Xm6PrNkZojeUbA8Y//Nhzfcnz7svHHf5s8o+FIntFwJM9oOA44vuX49rXQj/82eUbD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vzs4Ku8QSyYzIDMh4+mBI2Q8PXCEjKcHjpDx9MARMp4eOECm8gasZDKeHjhCBg88I4MHnpEZkJmQwQPPyOCBZ2TwwDMyeOAZGTzwhEzlnV/JZPDAMzJ44BkZPPCMzIDMhAweeEYGDzwjgweekcEDz8jggSdkKu/8SiaDB56RwQPPyOCBZ2QGZCZk8MAzMnjgGRk88IwMHnhGBg88IVN551cymb/bz2j/cu3427csqc+/3/z8x83P/7z5+c+bn/+69/n/9k066vMvNz//evPz3/z+/ds3vGj/IvXYK9+/kfNXvn8j5698/0bOX/n+DfzV2175/g2c/6h8/0bOX/n+jZy/8v0bOX/l+zdy/sr3b6B/OCrfv5HzV75/I+evfP9Gzl/5/o2cv/L9Gzj/s/L9Gzl/5fs3cv7K92/k/JXv38j5b37/Pm9+/z5vfv8+b37/Pm9+/z5vfv+eN79/z5vfv+fN79/z5vfv3/4Su/r8N79/z5vfv+fN79/z5vfvefP797r5/Xvd/P69bn7/Xje/f//2V6DV57/5/Xvd/P69bn7/Xje/f69737/Px73v3+fj3vfv83Hv+/epeKd0eR1pXY6hPP/73796Kl4TTT3/8+bnP29+/uve51e8cpl6/uXm519vfv7t5ucfNz//ze/fpfL9+/73V59L5fs3cv7K92/k/JXv38D518r37/vfn3yule/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/RvoH9bK92/k/JXv38j5K9+/gfNvle/fyPkr37+R81e+fyPnr3z/Rs5f+f6NnL/y/Rs5/83v3+3m9+928/t3u/n9O25+/46b37/j5vfvuPn9q3h/KfX8N79/x83v33Hz+3fc/P4dN79/95vfv/vN79/95vfvfvP7V/H+Uur5b37/7je/f/eb37/7ze/f/eb373Hz+/e4+f173Pz+PW5+/yreX0o9/3/83//H2F/nf1wP5fkDv38leP8n9/zXvc8veP8n9/zLzc+/3vz8283PP25+/v3m5z9ufv6b37/Pyvdv4PdXn5Xv38D5z8r3b+T8le/fyPkr37+B3588K9+/kfNXvn8j5698/0bOX/n+jZy/8v0bOX/l+zfQP5yV79/A+a/K92/k/JXv38j5K9+/kfNXvn8j5698/0bOX/n+jZy/8v0bOX/l+zdy/pvfv9e979/zce/793zc+/49H/e+f8/Hve/f83Hv+/d83Pv+PR/3vn/Px73v3/Nx7/v3fNz8/l1ufv8uN79/l5vfv8vN71/B+0u557/5/bvc/P5dbn7/Lje/f5eb37/rze/f9eb373rz+3e9+f0reH8p9/w3v3/Xe96/H//X//6n//HP//Sf/ut/+Z8f/x9//I//61/+87/+83/7l1//57/+n//+//6Xj5/9vw=="},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}],"token":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":3,"end":4}],"inputs":[{"start":0,"end":3}],"secret_hash":[{"start":4,"end":5}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[4,5,6,7],"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2b227iMBCGE8ohNMshIYTzobQ3exdYCvSOl9l9671fad9htZ3UUwZrWjnqxIolLKFMjOP/m9+HppXre2+l9frxVdzQrrRgm7O6Zl8rW8G+sjI5fUc4a45w3gly+gwnXOsqhivM5aZ3Pc/fy1lwklBRCgUDc0fqPoK7eghKUwWBBnyWgD5lpybpnEJDCRU4BQhJIj6pw2drpA53kLvg0kVTPod9QMwT6/d1QMNL2u/cIYnxO9Cekrp6STk25HMsy7t8VaI/DdVvi9yjV20VC+6wW6rtq0+baHpqjDCekLbYDv2okTGG0vEu49/+5Lm69lyXtGky+Z892fxbGk9LY24oJigR8Gp7QEljk0G/9/L9Xo15XRuTe5JTR9zv3Qn2hNC7LvpPmTOJO4TnmzhPti0nz7ex6xJ2mX6f9+BVT/Mq1LzqkjaUoVeCfz7Rxb7xvsdoy3lxOIF238CLPsPTt+xFn9EW9OIFtCMDLyKGJ7LsRcRoy3lx/AHasYEXMcMTW/YiZrTlvNjl7xYDAy8GDM/AshcDRltwjeTzIjHwImF4EsteJIy2oBe/QHto4MWQ4Rla9mLIaAt68RO0UwMvUoYntexFymgL7p35+8XIwIsRwzOy7MWI0Rb0YgfaYwMvxgzP2LIXY0ZbcI3k2hMDLyYMz8SyF/R31CLMAweZUweZ4wowB1oso33I98+pgRdThmdq2QvUK8qcVIA50GIZ7cMzaM8MvJgxPDPLXqBeUebIQebYQeahg8yJg8ypg8xVmM+BFstoH/M9dG7gxZzhmVv2AvWKMkcOMk8dZI4rwBxosYz2Mf/b3MLAiwXDs7DsBeoVZR45yNyvAHOgxTLaxwNoLw28WDI8S8teoF5R5rGDzKmDzFMHmWMHmYcOMicOMt/WoB3mqALM9EzT31J5di+hxoOeeRqjpzGGJKbnYFbijFlGx2dFtNbyWltuvuD9ulTt3Qn63cjnlL/LP6q+8AzfhsnpScXS57keSb8+0cH6Oon/kLbYDv3AdYvsMO8eVPz0yXNL7bkuafPA5H/2ZPPfaDwbjRnG5DfhWItz7E4m87rvXdbyd8JTwj64p2dysZjsOyXtMduS8szoGb5/nuyaXmteBZpXXdKG7tHrEvwzmV835hvzR8z0fSIgdfj9itTVtFzo/zJgezgz/B/4fzqFFjUAAA==","debug_symbols":"ndpRattAGIXRveg5FN9foxkpWymluIlTDMEJiVMoIXuv3dIF5LxpJN237+kw79P94cfbz+/H08PT63T79X16fLrbn49Pp8vpfdp9qf737evz/nR98Xrev5yn27lyMx1O99en/nEzPRwfD9NtGx/fbq6bAZsVNtvnN/MONoFNwWaGTYPNAhvoYIYOZuhghg4adNCggwYdNOigQQcNOmjQQYMOGnTQoIMFOliggwU6WKCDBTpYoIMFOliggwU6WKCDDh106KBDBx066NBBhw46dNChgw4ddOhgQAcDOhjQwYAOBnQwoIMBHQzoYEAHAzpYoYMVOlihgxU6WKGDFTpYoYMVOlihgxU62KCDDTrYoIMNOtiggw062KCDDTrYoIMNOshuJ6PIqGQ0y6jJaJFRl9GQ0SojKSJSRKSISBGRIiJFRIqIFBEpIlJEpIiSIkqKKCmipIiSIkqKEGqMWGMEGyPaGOHGiDdGwDEijhFyjJhjBB0j6hhhx4g7RuAxIo8ReozYYwQfI/oY4ceIP0YAMiKQEYKMGGQEISMKGWHIiENGIDIikRGKjFhkBCMjGhnhyIhHRkAyIpIRkoyYZAQlIyoZYcmIS0ZgMiKTEZqM2GQEJyM6GeHJiE9GgDIilBGijBhlBCkjShlhyohTRqAyIpURqoxYZQQrI1oZ4cqIV0bAMiKWEbKMmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZYlZlphliVmWmGWJWZaYZdH1SLofSRckxSxLzLLELEvMssQs67NmeTn82r8c9z8eD9eLsNdvb6e7//diL8fz7+d/Xy7//gE="},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[3],"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2bW0/bMBiGnVMPZIUeOLRAWW93105sbHfhYrebtD+ACk2nSkCntkxsf3L3k/ZXquHMH7x1PyCoTmQkLKHYjv29j984TkJSR/xP3s2fo/IB1OmJ2kRq210t9QzG6mbJ6TwTTtcgpwOcOD9uk0lzfRBCc1ytTG1crU6mAAottT2eTPo/O6PLQXzdGV/NOuNh53R8dTmYYsc6FPbU9qx/ft6ZjTv96TSezE4u+tcnp6PZyXT0K74VfaMyJbFoSmTCmA/dwwIE189GaYCr9tFW4oQCTFP1IfR3oI5Mp/7Fm7+ygD6lOy2ZalBHHqyLRSaSDUz7oSYKpgjyAcPjWcbjW8bjWMATiuWVRc7Dbeduf0HVu9CH+hfEcjscVzGjcaFWBGXSqwBHwRIe3zIezzIeV+O5b23LihFTBPkiw+NbxhNYxuNZxpPHmvQYT5q1lu5lcK0tArveDsdVzmhcqBVBmfQqGocNPJ5lPIFlPL5lPK7Gc9/anxUjpgjyZYanaBmPbxlPYBmPZxlPHmv2YzzctSiE/fh8sKbyeB1zmXjkM7bfdZZju0zsMsOAPoUwlkjlu6ulxCfUijQOmfDaVraEx7OMJ7CMx7eMp2gZj8vw4JptkofG7qvYdL6jXsW8F8MQxizAE0wR5CvA88o8Ty+jcXZl3HXjx+4wll5taF6Fmlfr0AYZNjLwzwFdik3lDUbbnBfvh1K7msKLKsNTzdmLKqNtzoujQ6ldS+FFjeGp5exFjdE258Xb5A1NPYUXdYannrMXdUbb4DnyUWo3UnjRYHgaOXvRYLQNepGsnZspvNhkeDZz9oL0nspcf4bM1WfIbIPPJS1vRvt9or2VwosthmcrZy+2GG2DXpxJ7e0UXmwzPNs5e0F6T2WuW8Bc0vJmtI/6UnsnhRc7DM9Ozl7sMNoG5/I7qd1M4UWT4Wnm7EWT0TboRXK/3ErhRYvhaeXsBenJZ3V6bv+bKU+vG2o8Mj30nE4MIeTx2X3XOGO3i8dnF7T2zGv1uPlC5b1stYcybtt83OQ56UDFClTcNjOm1yrvGPbzAOI6oEP1PuT/QFtqR37QeUvsct7tq/zrB/q1tH7r0GafGX8kzI6/rfG0NWZ5TH4DRxZzK828rgr+/xj0P8O5OZ63L9+WpOd5+ZZjmee+92e0fw3qXK2v3B7AezE6D1zoQ+eBx8TGayBdjypMX/Qp63sJWrP1ewl8f1axhMezjMe3jMfNkYfmL8Xe1Xgyuh4l7032MxoTXV/pXof4Sc+HNgV1cuD7BUrctZvWAIpZEcv3Fy7j41x52YZytOKYhyqhl0+JO3wkybgHq/P29ArdK8qTVpr9XNt96FPU2s21cvJtBORlwvvQxgPz4r5rgX6dke931yBG/8fFl+9n40F8PBhM4unCbzCoL9bNBa/taX1Q29O0m7r256vz89FwFE8+XY+mswUGn2EoicUfoWDeY+rmsEVW/xHWEpQN3mcm733pe+bIYFz8/YhgfBNi8b4Fv/HO4rcGa+Lu+Wg6G0/63+KvcX/gAJp+eHGrTzsqr3Loach46OnUwM+bXM0inDZ4Kv0Djfg91q03AAA=","debug_symbols":"5Z3dahxHEEbfZa9F6Orq6u7Sq4QQZFsOC2JlrHUgCL17xsn+JGiwsOXPPrBXYrTVNV8tOmelmdbu4+bd7ZtPf/y+3b2/f9hc//q4ubt/e7Pf3u+Wo8dN+SX/+ebDh5vd5+OH/c3H/ea6XG1ud++Wr09Xm/fbu9vNdRtPV8/KMvxQmCNOpTlXSqOGHWqj9nPf7k+/XS0xrEByGCRHheRwSI4GyRGQHB2SY0ByTEgOiE8rxKcV4tMK8WmF+LRCfFohPq0Qn1aITyvEpxXiU4f41CE+dYhPHeJTh/jUIT51iE8d4lN/jU+t+LHSStRXJklKklYwSQyTpGKSOCZJwyQJTJKOSTIwSTCObRjHBsaxgXFsYBwbGMcGxrGBcWxgHBsYxwbGsYFxbMc4tmMc2zGO7RjHdoxjO8axHePYjnFsxzi2Yxw7MI4dGMcOjGPHq67CzjwH8S8HsTmOl+Qsaz4P0ihBghKkU4IMSpBJCZKQILNQghglSKUEoZh1Usw6KWadFLNOilknxayTYtakmDUpZk2KWZNi1qSYNSlmTYpZk2LWpJg1KWa1QlGrFYpbrVDkulxdwCSh6HXpgElCEawVimGtUBRrBeNYwzjWMI41jGMN41jDONYwjjWMYw3jWNM49tA8hc1rUTY3ZfOqbO7K5k3ZPJTNu7L5UDZXElqVhLqSUFcS6kpCXUmoKwl1JaGuJNSVhLqSUFcS2pSENiWhTUloUxLalIQ2JaFNSWhTEtqUhDYloaEkNJSEhpLQUBIaSkJDSWgoCQ0loaEkNJSEdiWhXUloVxLalYR2JaFdSWhXEtqVhHYloV1J6FASOpSEDiWhQ0noUBI6lIQOJaFDSehQEjqUhE4loVNJ6FQSOpWETiWhU0noVBI6lYROJaFTSWgqCU0loakkNJWEppLQVBKaSkJTSWgqCU0hobUUZXNTNq/K5q5s3pTNQ9m8K5sPZfOpbK4k1JSEmpJQUxJqSkJNSagpCTUloaYkVLmnqCr3FFXlnqK6vqdoufF1/Efu5WbP+PIplpfKfiheXh7OxVZtpdpHPRQ3O+eZp/dfrrA8DsvTYHkClqfD8gxYngnLk6w869vDfmIemJ8d5meH+dlhfnaYnx3mZ4f52WF+dpifG8zPDebnBvNzg/m5wfzcYH5uMD83mJ8bzM8N5ueA+Tlgfg6YnwPm54D5ObR+Ppyk/4iTfA+T9nE6ycwXntkxj4lGnj8WZbmidgw0aYESFqgXWiCjBaq0QE4L1H50oO6nQP1/gVbuTvjx7kT2fKF2xDz1bf+pPc4ZFzJnv5A5x4XMOS9kzryMOUe5kDntQuasFzKnX8ic7ULmXH1d6VaPq7q187Lz5/mu/riPOo8TD/eysmz1t5J6ep68tOd/W6/van9p0fyWRfkNi9Z3l7+0yL5u0XLw583H7c2bu9uHZcHnxz7t3u6397vD4f6vD/8+stT+DQ=="},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"amount":[{"start":4,"end":5}],"inputs":[{"start":0,"end":3}],"message_leaf_index":[{"start":6,"end":7}],"secret":[{"start":5,"end":6}],"to":[{"start":3,"end":4}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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HqTgepCC60EKrgcpuB6k4HqQgutBCq4HKbgepOB6kILrQQquB6m4HqTiepCK60EqrgepB43ZiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4nqQiutBKq4HqbgepOJ6kIrrQSquB6m4HqTiepCK60EqrgepuB6k4XqQhutBGq4HabgepB00ZhuuB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kIbrQRquB2m4HqThepCG60EargdpuB6k4XqQhutBGq4HabgepOF6kI7rQTquB+m4HqTjepB+0JjtuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfpuB6k43qQjutBOq4H6bgepON6kI7rQTquB+m4HqTjepCO60E6rgfp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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":3}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[3],"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"1"}},{"name":"typ","value":{"kind":"string","value":"PublicMutable<AztecAddress, Context>"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"2"}},{"name":"typ","value":{"kind":"string","value":"SharedImmutable<EthAddress, Context>"}}]}}]}]}},"file_map":{"21":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"35":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"41":{"source":"impl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u64, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u64) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<N>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n}\n","path":"std/slice.nr"},"47":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n","path":"/home/josh/Documents/test/aztec-token-bridge/packages/aztec-contracts/token_bridge/src/main.nr"},"55":{"source":"use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"58":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"60":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, silo_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub fn compute_siloed_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    silo_nullifier(address, nullifier)\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"63":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    * Should be automatically convertible to [Field; N]. For example str<N> works with\n    * one char per field. Otherwise you can use CompressedString.\n    */\n    pub fn emit_unencrypted_log_with_selector<T>(&mut self, event_selector: Field, log: T) {\n        emit_unencrypted_log(event_selector, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn emit_unencrypted_log<T, N, M>(&mut self, log: T) {\n        let event_selector = 5; // Matches current PublicContext.\n        self.emit_unencrypted_log_with_selector(event_selector, log);\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log<T>(event_selector: Field, message: T) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nfn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nfn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nfn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nfn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nfn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nfn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nfn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nfn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nfn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nfn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nfn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nfn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nfn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nfn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nfn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nfn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nfn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nfn emit_unencrypted_log_opcode<T>(event_selector: Field, message: T) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nfn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nfn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nfn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nfn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"65":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::{note_interface::NoteInterface, utils::compute_note_hash_for_insertion},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_log, emit_encrypted_note_log, compute_encrypted_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Ending setup at counter {0}\",\n            [self.side_effect_counter as Field]\n        );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(&mut self, log: T) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn encrypt_and_emit_log<N, M>(\n        &mut self,\n        contract_address: AztecAddress,\n        randomness: Field, // Secret random value used later for masked_contract_address\n        event_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        preimage: [Field; N]\n    ) where [Field; N]: LensForEncryptedLog<N, M> {\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        // We are currently just encrypting it EXACTLY the same way as if it was a note.\n        let counter = self.next_counter();\n        let encrypted_log: [u8; M] = compute_encrypted_log(\n            contract_address,\n            randomness,\n            event_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n        emit_encrypted_log(contract_address, randomness, encrypted_log, counter);\n        let len = 32 + 32 + 64 + 48 + 48 + 176 + 64 + (preimage.len() as Field * 32) + 16 + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n    }\n\n    pub fn encrypt_and_emit_note<Note, N, NB, M>(\n        &mut self,\n        contract_address: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        note: Note\n    ) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n        let note_hash_counter = note.get_header().note_hash_counter;\n        let note_exists_index = find_index(\n            self.new_note_hashes.storage,\n            |n: NoteHash| n.counter == note_hash_counter\n        );\n        assert(\n            note_exists_index != MAX_NEW_NOTE_HASHES_PER_CALL, \"Can only emit a note log for an existing note.\"\n        );\n        let preimage = note.serialize_content();\n        let counter = self.next_counter();\n\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n\n        // TODO(#1139 | #6408): perform encryption in the circuit\n        let encrypted_log: [u8; M] = compute_encrypted_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n\n        // Current unoptimized size of the encrypted log\n        // incoming_tag (32 bytes)\n        // outgoing_tag (32 bytes)\n        // eph_pk (64 bytes)\n        // incoming_header (48 bytes)\n        // outgoing_header (48 bytes)\n        // outgoing_body (176 bytes)\n        // incoming_body_fixed (64 bytes)\n        // incoming_body_variable (N * 32 bytes + 16 bytes padding) \n        // len of processed log (4 bytes)\n        let len = 32 + 32 + 64 + 48 + 48 + 176 + 64 + (preimage.len() as Field * 32) + 16 + 4;\n\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"69":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"71":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize};\n\nuse crate::context::private_context::PrivateContext;\nuse crate::context::public_context::PublicContext;\nuse crate::context::gas::GasOpts;\nuse crate::context::public_context::FunctionReturns;\n\nuse crate::oracle::arguments;\n\nstruct PrivateCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateCallInterface<T> {\n    pub fn call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateVoidCallInterface {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nstruct PrivateStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateStaticCallInterface<T> {\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateStaticVoidCallInterface {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nstruct PublicCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicStaticCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nstruct PublicStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicStaticVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"72":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"78":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nfn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"80":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"82":{"source":"#[oracle(packReturns)]\nfn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nfn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"83":{"source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"88":{"source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nfn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"92":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nfn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"93":{"source":"#[oracle(packArgumentsArray)]\nfn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nfn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"94":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"95":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u64 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nfn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u64, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"98":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"116":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // This looks the same as the &mut PublicContext impl, but is actually very different. In public execution the\n        // storage read oracle gets transpiled to SLOAD opcodes, whereas in unconstrained execution the PXE returns\n        // historical data.\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"121":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"139":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr"},"143":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::recursion::verification_key::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::log_hash::LogHash;\nuse crate::traits::is_empty;\nuse crate::utils::{uint256::U256, field::field_from_bytes_32_trunc};\nuse crate::constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n};\nuse crate::traits::Hash;\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(address: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_encrypted_log(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_unencrypted_log(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5, counter: 1234 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"144":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u64,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"146":{"source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"147":{"source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"167":{"source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr"},"169":{"source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr"},"171":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"172":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr"},"176":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u64,\n    nullifier_read_requests: u64,\n    key_validation_requests_and_generators: u64,\n    new_note_hashes: u64,\n    new_nullifiers: u64,\n    new_l2_to_l1_msgs: u64,\n    private_call_requests: u64,\n    public_call_stack_hashes: u64,\n    note_encrypted_logs_hashes: u64,\n    encrypted_logs_hashes: u64,\n    unencrypted_logs_hashes: u64,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr"},"177":{"source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"179":{"source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr"},"180":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr"},"184":{"source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr"},"187":{"source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH}, hash::silo_nullifier,\n    traits::{Empty, Hash, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = silo_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr"},"189":{"source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr"},"190":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x0933cf2bb384c9733d5a8311bfdc089489c2557df2265026579f9ac2b21d2ef9;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr"},"191":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr"},"192":{"source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr"},"197":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr"},"198":{"source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x1f0e71146c5d4a5bdcf517f0063cda7767e51fcb9cebc877feb348a77a7a6b4a;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x079a2b28b4853de9169d7dc40ac41c6d80b465d82c60195ede91504013f8b11b;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr"},"210":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::silo_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = silo_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"212":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr"},"214":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr"},"215":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr"},"216":{"source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr"},"217":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr"},"222":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"223":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"233":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"234":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr"},"235":{"source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr"},"249":{"source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr"},"250":{"source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr"},"252":{"source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/header.nr"},"253":{"source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr"},"255":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress}\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::{auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public}};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        storage.balances.add(\n            context.msg_sender(),\n            context.msg_sender(),\n            U128::from_integer(amount)\n        );\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes[0].unwrap_unchecked();\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        storage.balances.add(context.msg_sender(), to, U128::from_integer(amount));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount);\n        // docs:start:increase_private_balance\n        storage.balances.add(from, to, amount);\n        // docs:end:increase_private_balance\n    }\n    // docs:end:transfer\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"270":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.42.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}