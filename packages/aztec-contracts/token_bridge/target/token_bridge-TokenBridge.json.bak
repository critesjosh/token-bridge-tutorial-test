{"noir_version":"1.0.0-beta.0+a46035ba69b0a659897fe25271c346e005925a6c-x8664","name":"TokenBridge","functions":[{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7043145299448266897":{"error_kind":"string","string":"L1-to-L2 message is already nullified"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7408320001641276198":{"error_kind":"string","string":"Function _assert_token_is_same can only be called internally"},"11235885384217001395":{"error_kind":"string","string":"Function get_token can only be called statically"},"13293000217372736598":{"error_kind":"string","string":"Tried to consume nonexistent L1-to-L2 message"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16541607464495309456":{"error_kind":"fmtstring","length":16,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17456365777023668047":{"error_kind":"string","string":"Token address is not the same as seen in storage"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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JW64yqa44Sqb4oarbIobrrIpbrjKlrgNXGVT3HCVTXHDVTbFDVfZFDcBd0vccJVNccNVNsUNV9kUN1xlU9xwlS1xW7jKprjhKpviJuDmxU1n3Iu3Y0y4oUx4cYf5PRomkFrhhjJpihvKpCVugjJpihvKpCluPO9uihvPu5viJuBuiRvPu5vixvPuprgbu0qaHylosqqA27ppbUgvNjTKvknHp3n3o0XK+hHPemH8xNot8D0e+4QkAslbJAlI3iBpvddQD0g0kLxFYoDkLRILJG+REJC8ReKA5C0Sf0Akblavbvmu6+yxWoVpflrF87vrjAnPAI+odVkBHlEZswJsraPP7wt1oQQwUpxmGp3xryzoY/Je9Zy87jl503PytufkqefkXc/J+56TDz0nH3tOvucOG3rusKHnDht67rCh5w4beu6woecOG3rusKHnDht67rCh5w4be+6wsecOG3vusLHnDtt6Hzbe5HvusLHnDhtFd1hnzZw8uXXyojtsKXnRHbaQfBLdYUvJi+6wpeRFd9hS8qI7bCl50R22lLzoDltKXnSHLSXfc4dNojusV9O5ozdmnbzoDns9ea2U6BZbzF50jy1mL7rJFrMX3WWL2Ytus8XsRffZYvaiG20xe9Gdtph9x632lH3XvVZ33Wt1171Wd91rdde9tvWr+pmz77rX6q57re6612rZvZbmR/beq0z2snttIXsju9eWspfda0vZy+61pexl99pS9rJ7bSl72b22lL3sXlvKXnavLWR/++sxndVz9otdjB+zfx5B7z6C2X0Eu/sItPsIbvcR/O4jhN1HiLuPkPYegXa/p2n3e5p2v6cJbzvkfcmN1fblWGONXh78xNvhdYdteeN9h21544WHbXnjjYdteRN4N+WNdx625Y2XHjK/Sj+lmbc2a954l35b3niZflve8JdNeXv4y7a84S/b8oa/bMsb/rItbwLvprzhL9vyht9pyxt+py1v+J2mvAP8Tlved9SD3pV4kw7T0eTPL73Nv3rXRD/vRxIXDE3IZXJas2l5rKZYWMvozfSYNXr7en2eORI4snB04MjC0YMjC8cAjiwcIziycEzgyMExKnB8F8fCr5qiBkcWjgYcWTjCz/BwJHBk4Qg/w8MRfoaHI/wMD0f4GR6O8DMsHBP8DA9H+BkejvAzPBzhZzg46gvvJzR2SsmakM4p5fJ/fOnVNFtl3WKMlyFo/yHc/kP4/YcI+w8R9x8i7T7EhVfEsQ6R73fnLU+tTX45xHOUqYqyF6LM1aj8bWWJrka5qihfFRVqovLvxXF2em7tll8a8C8xtiKGKmJcRYyviAkVMbEiJm2Pyb9DpBCjK2IqrgNbcR3k38Xh/NTB3aKBzzGuIsZXxGSvAz9v0ux1WsfEipi0PSb/3olCjK6IMRUxtiKGKmJcRYyviKm4DqjiOqCK6yD/SxwdaRbM0S9+fzk12PwPSsph2avh8WqcwrRb30f5b/cXo6gqylVF+aqokI8KZo5Kbh0Va6LyG3aeEjxbHbXOMP89umIUVUW5qqg8eWfPL95yYR0VqqJiVVSqicp/kl+M0lVRpirKVkVRVZSriqq6NmLVtRGrro1YdW2kqmsjXbg2Qpqj0ro/JFMVZauiqCoqv8pWz1Gnpz/rqFAVFauiUkWUye9aUozSVVGmKspWRVFVlKuK8lVRoSrqwrXh6PzoMayjUk2UVlVRuirKVEXZqiiqinJVUb5Cb5j8U5FiVKyKSjVR+acppZeLmvwDlZNGnZuKj5nBXFWUr4oKVVGxKiqPPkQ7+xu1+tmJyT9cKUbpqihTFWWroqgqylVF+aqoUBUVq6Kqrg2qujao6tqgqmuDqq4Nqro2qOrayD98OSnbuTEnm4kKVVGxKirVROVfj3fq8tPnoeZUxl6V7Mxnhde3Jz4NQi0GcS0G8S0GCS0GiS0GSQ0GyT9H5B5EtxjEtBikxR3vW9zxvsUd71vc8b7FHe9b3PG+xR0fWtzxocUdH1rc8aHFHR9a3PGhxR0fWtzxocUdH1rc8aHFHR9b3PGxxR0fOe746xt+nwaxLQahFoO4FoP4FoOEFoPEFoOkBoMk1WIQ3WKQFnd84rjjC9/5NYlaDOJaDOJbDBJaDBJbDJL2H8Qq1WIQ3WIQ02IQ22IQajGIazGIbzFIaDFIbDFIiztet7jjdYs7Xre44zXLHX/9w1irqcUgrsUgvsUgocUgscUgqcEgRrUYRLcYxLQYJHufBDV9uyToZZl4ifEVMdmrOMw/fwiU1jExHzP5lODtOiZtj8l/syHEqVaGFNYxuiImu6DRzCtEa2757zRE42av5tcx2QIb5+9Qx1xu7npMyqxp/llpmK+44F696fQ5JrumiSZuyZt1TNoek3+cV4jRFTH5byOoeVEf34+5jrJVUVQV5aqifFVUqIqKVVGpJurC14tLUboqquraSFXXRqq6NlLVtZGqro1UdW3knwtcrTGUt/lp/lVtspkYWxFDFTGuIsZXxITNtYxUrIjZXptJq4oYXRFjKmJsRUz+OphfnZBCWse4ihhfERMqYmJFTNoek5fqhZjSdZCLqbgOTMV1kP+WcSHGVcT4ipiKemAq6oGpqAe2oh7YinpgK64DW3Ed2IrrwFZcB7biOrAVa2or1pQq1pQ2ruk/pz/99+P3zx9/+fLpz1PE41/+9fXXH5+/fX3544///TH9zS/fP3/58vn3n//4/u3XT7/99f3Tz1++/fr4dw/q5V//0pbCB219PGXzuOzWfSD3mNnTX6rkP2it9OP/0M9H0+lo8qc8Trn8Hw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==","debug_symbols":"ndLNCoQgFAXgd7nrFqnd/l4lhrCyEMTCbGCI3n0smqEZ2ujm4hG/6+as0IlmGWqp+3GGslpBjS23ctQurVsEjZFKyaG+XkO8D0KO9/PE9R5ny42FkiUYgdCdOyFzvpdKQJnS7REBod6CeYvEW6CvoLd/FAnGJymSLPsaQvBAGILSEJSFoDwAsdsKFMiKD0LMf9Hm4pMbyRslzor1i24vjbOvSfyVbzJjK7rFiL2Glwa6WZEsotStdavf","brillig_names":["sync_notes"]},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17288131482828810359":{"error_kind":"string","string":"Message not in state"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","field_less_than","decompose_hint","lte_hint","build_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","call_private_function_internal","directive_to_radix","directive_invert","directive_integer_quotient"]},{"name":"get_token","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"11235885384217001395":{"error_kind":"string","string":"Function get_token can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/71VTUvEMBBNPxatVZBVUS8KgvfUVLveKosHLwruL0ibRAqVlbaKx/50u5DYONuu+9HugzBpMn0z85IhBqphSGujvzBQwwJ0anXW1q6ldaQ1tX2rGqH8xpvBc0DcLvlH2Pedhvo6zJ84ktPohx8r/p70xzuSZ1zW/HotKu5uNVw5P1jwT5/5Vuf5q7fVA38F76glf6XBuZzvV+NQzunX+8tHPGX8gbGM57neV1DPRViF01yB8wxyPn+maSISnj1+J3kxx201cKu5iZprg3npfjqa+mWGUFq8GbwBqGEo7ezsLjVNTqAmT/mkoEUSj2marnuA8PJ3WRgChQ1Qe7NCEU41Ea40EY6hCJNimtE3/sopW1aDZS+mi+rHxC5rn66aNxhhrGJaZa2DheZha/u6/4X83gM1qEc0XDNPEVBPECroLWXMj+kQ8CNNN7eH+BH3OBFCEE59cSe2Hv8+4ozfEIoD3xMsIv/F/wGzLjA+6ggAAA==","debug_symbols":"vZTbioMwEIbfJddezEzOfZWlFNumRRAt1i4s4rtvshixrijr2t6ICd/M/5M5NOzsjo/rISsu5Z3tPhqWl6e0zsrCn5o2Yccqy/PsehheMwgfpB/+fkuLcLzXaVWzHSoLCXPF2f9qAJ/hkuWO7RS1yW8YQEYYSPYwcj5BC25MRwtudU9bnIAN8pjaoMQhvE8Y8g28G4qwN/9G72ID7wL7d1dL746SR+8orZj3boliaktKjL3LTb0jPHsPCurlCvrlCubfCkr3CkrLpX4zNraysSjHNbN/dONjCFbE4IoYWhEzOftSGNvFSAl6/nUJje5g3+6D2RdmgtaEqqM18YVaeL8xtQah5mG/gzTvB9nCE75v/ekzrbL0mLtum18exWmw3Ouvmxvt+VtVntz5Ubmw8QfLPhSUZMIhdESoFBcJV17D63wD","brillig_names":["get_token"]},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7043145299448266897":{"error_kind":"string","string":"L1-to-L2 message is already nullified"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13293000217372736598":{"error_kind":"string","string":"Tried to consume nonexistent L1-to-L2 message"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["claim_public"]},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["exit_to_l1_public"]},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","field_less_than","decompose_hint","lte_hint","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","pack_arguments_oracle_wrapper","call_private_function_internal","directive_to_radix","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"7408320001641276198":{"error_kind":"string","string":"Function _assert_token_is_same can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17456365777023668047":{"error_kind":"string","string":"Token address is not the same as seen in storage"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/81VTUvDQBDdNikaqyhV0INeFATBw6aJaY4R8apgf8E2uyOFaiWt4rE/3S7Mku00rZYkxQdhZj/yZt7bfDRYjgZGl4xZwZ4EIy8Hv0IuvtDkOhGrRN1i9DA2rXWnQtEeqVslf8zD0CvQV2H/gYecdfpjOGvg5zvI8zDL+akWjQMc28+QuWd3frVxziP76jjPGv3mxwX9m1pa5wXm+/PrCHPx9fb8kY6lupcyU5OJ7RHtdR024XQ24DyjnE+fo9EQhip7/B5OpkvcRd8LkzfJXHNFX/a8jaLz00gw8nLwW0RDB6M+uyvLk0PqSV+9S5X9p6NjREqLrX49qexTjFr2NebUeo0EIy8HX+s/ofr703EmXtWLEvKvHmziv73eKuBtkDWz95zl3txg3mb5r86dLfaZ4DwvgV7MuenHmeV9OWwZrrVu77/E8Z6l0US3RJ/QEz4EAsSdkDJMRYfwM8u7dg31B8pXAQAESoQQwdbrR1EKIkhFxANQQTfadn3ohn4v7sIgTmMOIfxW/we1XGnYqAoAAA==","debug_symbols":"5ZXbboMwDIbfJddcxHacQ19lmiraphUSgorSSVPVd18yEcQYKmpLd7MbRNBn+8fx4SJ2fnM+rItqX5/E6u0iynqbt0VdhdPlmolNU5RlcVgPPwsZH4Df/OmYV/F4avOmFSvQTmbCV7vwaqQMHvZF6cVK4zX7DUvJCZbIPQxEE7QiaztakTM97WACtkDJtQWGIfyeCaAFtFtMcBD/h9rVAtoV9HnXc3kHpqQd2Knb2h1icu1Qq7F2XlQ7yJ/aYwT98gjm5RHs0xEUM6V6Yw0z9YYylbJFMOM7c8+rWa76Ud6pJtrAAzb4gM3kVGFC3dkwKXU7UwjWdHBopMFUUXaCNgjJtUGayWvQm1wbqfRtOEw3Q/2IcFKPr0H9n1/l2V9lPa4E/YCNudfmGk4feVPkm9J363p/rraD7d1+Hv1okR+beut358bHlT7Y5rGv0GWkYsvHhgldSCbECHG+AA==","brillig_names":["_assert_token_is_same"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::get_token_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"TokenBridge"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000c0c5aaf"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000c0c5aaf"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]}]}},"file_map":{"17":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"50":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"51":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"57":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"62":{"source":"// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract TokenBridge {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view},\n        storage::storage,\n    };\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        token: PublicImmutable<AztecAddress, Context>,\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.initialize(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read(),\n            message_leaf_index,\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_to_public(to, amount).call(&mut context);\n    }\n\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    /// TODO(#8416): Consider creating a truly private claim flow.\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read(),\n            message_leaf_index,\n        );\n\n        // Read the token address from storage\n        let token_address = storage.token.read();\n\n        // At last we mint the tokens\n        Token::at(token_address).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n    }\n\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n    }\n\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read(), content);\n\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n\n    #[public]\n    #[view]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n}\n","path":"/home/josh/Documents/test/token-bridge-tutorial-test/packages/aztec-contracts/token_bridge/src/main.nr"},"85":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"87":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"91":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"93":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        header::get_header_at,\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: Header,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"96":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"98":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"99":{"source":"use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/generators.nr"},"107":{"source":"use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"111":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"114":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"115":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    utils::arr_copy_slice,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"120":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"123":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"124":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"126":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice,\n};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"128":{"source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"130":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"131":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"133":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"148":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"166":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"185":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"203":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\npub mod arrays;\npub mod field;\npub mod reader;\npub mod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"204":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"205":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"218":{"source":"use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"227":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"234":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"276":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"277":{"source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Deserialize, Empty, Serialize, ToField}, utils};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"289":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"292":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"295":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"299":{"source":"use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"302":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"329":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::encode_and_encrypt_note_unconstrained,\n        },\n        keys::getters::get_public_keys,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n        // TODO: constrain encryption below - we are using unconstrained here only because of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from_ovpk_m, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(&mut context, from_ovpk_m, to, from),\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from_ovpk_m,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_ovpk_m = get_public_keys(from).ovpk_m;\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from_ovpk_m, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: Field) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // recipient of the outgoing: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let from_ovpk = get_public_keys(from).ovpk_m;\n        let setup_log = note_setup_payload.encrypt_log(context, from_ovpk, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // TODO(#8271): Type the amount as U128 and nuke the ugly cast\n        let amount = U128::from_integer(amount);\n\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueud call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // recipient of the outgoing: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: Field,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: Field, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U128::from_integer(amount);\n\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Since user is the logical sender of all the notes we get user's ovpk and use that in all of them.\n        let user_ovpk = get_public_keys(user).ovpk_m;\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            user_ovpk,\n            user,\n            user,\n        ));\n\n        // 4. We prepare the partial notes\n        // TODO(#9887): In each `_prepare_private_balance_increase` call we fetch the user's ovpk_m 2 more times. This is\n        // very inefficient.\n        let fee_payer_point_slot =\n            _prepare_private_balance_increase(user, fee_payer, &mut context, storage);\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund(Field,Field,Field)\") },\n            [fee_payer_point_slot, user_point_slot, funded_amount],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 14],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_slot: Field, user_slot: Field, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, fee_payer_slot, tx_fee);\n        let user_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, user_slot, refund_amount);\n\n        // 4. At last we emit the note hashes and the final note logs.\n        fee_payer_finalization_payload.emit();\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"345":{"source":"use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr"},"346":{"source":"// docs:start:mint_to_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_to_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes:[u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"mint_to_public(bytes32,uint256)\".as_bytes(), 31) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_to_public_content_hash_nr\n\n// docs:start:get_mint_to_private_content_hash\n// Computes a content hash of a deposit/mint_to_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_private_content_hash(\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 36];\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"mint_to_private(uint256)\".as_bytes(), 24) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_to_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"withdraw(address,uint256,address)\".as_bytes(), 33) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.66.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}