{"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"TokenBridge","functions":[{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"target","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"function_data","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData","fields":[{"name":"selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_private","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7X3djvTIjeW79LVhKCIYf/Mqi8XCO+NZGBjYg7FngYXhd9+k6pOy2hmV2V+lGDoUeeVut1TnkJEKnowUef7+y7/98X//9//5X3/687//5a+//Mv/+Psv//GXf/3D3/70lz/f/u3vvwRa/7+//ucf/sz/+te//eG//vbLvyy/++WPf/632//+43e//Puf/uOPv/xLzv/43cNlsaT648pYct8vrmlwcaq1/bg4NcrPL+55yT8u7rnQfnEobXh1+XFxWJb7xbH+43/+7peQLx9hmRUhxWW7mGKp8yKsb0SYWlz2ZcnlTrqvf7rJ/en+xp8OodKWkJju6xJCH11NO5GQU3lxdSytb2velv5yZQ5bx7i8k5HY9oykFF/EmPt2cUn3R7F80AgYNCIGjYRBgzBoZAwaBYNGxaDRMGh0CBpp4i5awkaD6j/TCBg05u2iNW21rbbln2nM20X7sl3cP13Lcuzh0pKWPXH3j1GkMiKR2ybuQlnKr67mAOnqAearB1jUB1hC2ANM+SHAevUA29UD7PoDpP2bWCnLPwdIy9UDDFcPMF6gTJR7gOEhQEwl07d9o6b0IsBY+7Kfb6RPK7gqNaKLxzdPx4Sl7bt5oPw8wpy209HPp0iJxlVi+7OtfUrGGl65dnj12uG1a4fXLx1eXq4dXrh2ePHa4aVrh0fXDu/aqiVfW7Xka6uWfG3Vkq+tWsq1VUu5tmop11Yt5dqqpdC1w7u2ainXVi3l2qqlXFu1lGurlnpt1VKvrVrqtVVLvbZqqXTt8K6tWiqoaqlxe4+6pvo5POYMKkWecgbVF23/Lby18Pxj9PyX1AqqMA4LsIFqjOMCBFUZxwUIqjOOCxBUaRwXIF09QFC1cVyAoHrjuABBxclxAV5dybSrK5l+dSXTr65k+tWVTL+6kul09QCvrmT61ZVMv7qS6VdXMv3qSiYsV5cyYbm6lgnL1cVMWK6uZsJCl4/w6nomLFcXNGG5uqK5oV4+wstrmnB5TRMur2nC5TVNuLymeWvco44IL69pwuU1Tbi8pgmX1zTh8pomXl7TxMtrmnh5TRMvr2kmDg49K8LLa5p4eU0TL69p4uU1Tby8pkmX1zTp8pomXV7TpMtrmonDds+K8PKaJl1e06TLa5p0eU2TLq9p6PKahi6vaejymoYur2kmzt09K8LLaxrU4bsHRnh5TYM6gvfACC+vaVAH8R4Y4eU1Deo43gMjvLymQR3Ke2CEl9c0qKN5D4zw8poGdUDvgRFeXtOgjuk9MMLLaxrUYb0HRnh5TYM6svfACC+vaVAH9x4Y4eU1Der43gMjvLymQR3ie2CEl9c0qKN8D4zw8poGdaDvgRFeXtOgjvU9MMLLa5rLjwwOl58ZHKYODY71iwhXJkPtkVrtP25KPZdXfNI24PpGrd8TE9rg6n5P+BI+u/SO/nLqu8sy/crS94N7VMw9KeZOirlnxdyLYu5VMfemmHvXy308kFYJd8V1tSuuq11xXe2K62pXXFe74rraFdfVrriudr11NS5662pc9NbVuOitq3HRW1fjoreuxkVvXY2L3roaF711NS5662pcFNfVoLiuBsV1NSiuq0FxXQ2K62pQXFeD4roaFNfVoLiuBsV1NSquq1FxXY2K62pUXFej4roaFdfVqLiuRsV1NSquq1FxXU0H1NUUPr2LVCZyD4q5R8Xck2LupJh7Vsy9KOZeFXNvirl3vdxJcV0lxXWVFNdVUlxXSXFdJcV1lRTXVVJcV0lxXSXFdTUrrqtZcV3NiutqVlxXs+K6mhXX1ay4rmbFdTUrrqtZcV0tiutqUVxXi+K6WhTX1aK4rhbFdbUorqtFcV0tiutqUVxXq+K6WhXX1aq4rlbFdbUqrqtVcV2tiutqVVxXq+K6Wg+oq6XudEpvr7in7S/3ch9wFEpb6bQFi07AohOx6CQsOsOyQ0vfECjE9pxOTGW7+Hba/QkijejUvD2zrd3Hb9UwYp6X7d2+W07oV9xHV++P7LLcL/4YGhbHo4suGGeZHOftQ7XTafQ50JVOxaLTJtMJedn55Nyffw5CjHs9i+k+bS60ZUQkU9uJ1PC8oCXq2yC7dPu03S9Oo4vjEreL49I+X7wmsXsS307ieDyTJ/Hnkhg8ie8nMXoSf0MS016jU4rhIYnJk/h+EsmT+FuSmMqexByeX3wTYHs+WksvLk5hvzjFx40i+/Kcuzx128cjLcvzi2ve4qud/vn8ohdfyYusZPWVvMhK+lfTc1eSwj50nlJ7ZyX9+/E1VjIt/iX93JW8pyPmVP9JkKbFv/5DL48fLEAvjx9ZQC8P+fKcujwlpe3iUuPzi0Mrezpayw9r6Scn11lLPzvRs5ZxWfa/vMT+zlcBP2gxuex+KmNy2f0IR9Oy7yPg4lLSG8se/LzH5LL7OdLhy96X7S/HHl5sxc9/d07Bz5FOXp6DfuNKwY+crrKS5Ct56koe9htX8LOpq6ykn0ydu5LPD/SDnyBBL4+f9EAvj5/IIC9P9JOTc5fnwF+4oh+HXGct/exEz1oe9/tF9IMWk8tOvuwWl92PcDQt+1E/W0U/7zG57H6OdPyyt70veQntPcXt50jQy+PnSKcuz3GqJ/mR01VW0g+crrKSftx0lZX0E6STV/Ko7wvJD4WuspJ+zvNbVpJ20onCi4sPnI+Ukp/HnLw8R73dmPyI5Sor6acxV1lJP7g5dyUPe0+V/ODmKivpBzfnruTzl/LIT2Ogl8ePWKCXh3x5kJfHD0POXZ4D31IlPzm5zlr62YmetTzu9yLygxaTy+6nMhaXPfsRjqZlP+oHyOznPSaX3c+RDl/2A+cjZT9HOnl5jvqNK5Ov5EVW0k+nzl3Jw37jyn42dZWV9JOpc1fy+YF+9hMk6OXxkx7k5Sl+IgO9PH5ycu7yHPgLV/HjkOuspZ+d6FnL436/KOTLbnHZ/VTG5LL7EY6mZT/qZ6vi5z0ml93PkY5f9uMG8BQ/R0JenurnSKcuz3Gqp/qR01VW0g+crrKSftx0lZUkX8lzV/Ko7wvVD4WuspLzz3n6NjQqlLIoWcnbzrddHJeHt0lr9SS+n8TmSXw/id2T+HYS2+JJ/C3T/5a9YKUYHpIYPInvJzF6Ek81V3/eRdKSL8+5y3NU70EjX8mLrGT2lbzISvpX03NX8rAukubfj6+ykv4l/dyVfP7KfPOv/8jL0/1gAXp5/MgCenn8MOTc5Tmwh6T7ycl11pJ8LdWs5XFvc3Q/aDG57H4qY3LZ/QhH07If9XpQ9/Mek8vu50jH+x8eNr3w9rOKL8+5y3PQb1y0+JHTVVbST6fOXcmjfuOixc+mrrKS5Ct56ko+PdCnxU+QoJfHT3qgl8dPZKCXx09Ozl2e437hui2ar+VV1jL42YmetTzs9wsKftBictn9VMbksvsRjqZlP+hnKwrky25x2f0c6fhlP2w8HgU/R4JeHj9HOnV5DlQ9fuR0lZX0A6eLrGT046arrKSfIJ28kkd9X4h+KHSVlfRznnPN1Z+/pxrJl+fc5Tnq7cboRyxXWUk/jbnKSvrBzbkredh7qtEPbq6ykn5wc+5KPn8pL/lpDPTy+BEL9PL4uQn08vhhyLnLc+Bbqol8LS+zln52omctj/u9KPlBi8ll91MZk8vuRzialv2oHyCTn/dYXHbyc6Tj/Q+Pm49Efo508vIc9RsX+ZHTVVbST6fOXcnDfuMi8pW8yEr6ydS5K/n8QJ/8BAl6efykB3p5/EQGenn85OTc5TnwF67sxyHXWUs/O9Gzlsf9fpH9oMXksvupjMllJ192Rct+1M9W2c97TC67nyMdv+zHDeDJfo4EvTx+jnTq8hyoevzI6SIrWfzA6Sor6cdNV1lJP0E6eSWP+r5Q/FDoKitJs1ey7HGGuvTPK7nyyWB8Chif6V8Fa9gfpvrpR9qNTwPj07H41Ok6tLa2f1cNj3wCGJ/pmqCWeufTHvgkMD7T9+e+y73Qe3jgk8H4FDA+FYzP7P05prhLk5sAeq7UaKeRl3L/w6UPru37tWH5pLz44jXQbiTQtlgJNFwl0LDs72OHJQ4ijWYiTWYipes8pvdA8/IYaL5ioHWwogU50Jy3NqxC+UWgse6RxpY+9WzVj0CrlUDni6PlHmh9FWjavjjlcj+3STQ8NNgraWv/fMTTuoUo+2IiymAiymgiymQiSjIRZTYRZTERZTURpQnt0y1on7xY0D55saB98mJB++TFgvbJC5mI0oL2uZ0emYjSgvbJiwXtkxcT2ieY0D7BhPYJJrRPMKF9ApmI0oT2CSa0TzChfYIJ7RNMaJ9oQvtEE9onmtA+0YT2me5qfE6UJrRPNKF9ogntE01on2hC+yQT2ieZ0D7JhPZJJrTPdF/Cc6I0oX2SCe2TTGifZEL7JBPah0xoHzKhfciE9iET2me67805UZrQPmRC+5AJ7UMmtA9Ba5+6t/h9npKSPqhnaEHznDq0Smlp639sLTz/bD3vlcwZWqccGCe0UjkwTjISJ7RaOTBOaL1yYJzQiuXAOKE1y4FxQquW4+Is0BLnwDiN6KFiRA8VI3po+iDUs+I0ooeKET1UjOihYkQPFSN6qBrRQ9WIHqpG9FA1ooemDx4+K04jeqga0UPViB6qRvRQNaKHmhE91IzooWZEDzUjeuiEec7nxGlEDzUjeqgZ0UPYs5wPjNOIHsKe53xgnEb0EPZM5wPjNKKHsOc6HxinET2EPdv5wDiN6CHs+c4HxmlDDxXsGc8HxmlDDxXsOc8HxmlDD5WFjMRpQw8V7HnPB8ZpQw8V7JnPB8ZpRA9hz30+ME4jegh79vOBcRrRQ9jznw+M04gewp4BfWCcRvQQ9hzoA+M0ooewZ0EfGKcRPYQ9D/rAOI3oIeyZ0AfGaUQPYc+FPjBOI3oIezb0gXEa0UPY86EPjNOIHsKeEX1gnEb0EPac6APjNKKHsGdFHxinET2EPS/6wDiN6CHsmdEHxmlED2HPjT4wTiN6CHt29IFxGtFD2POjD4zTiB7CniF9YJxG9BD2yOkD4zSih4zMpy5G5lMXI/Opi5H51MXIfOpiZD51MTKfuhiZT12MzKcuRuZTFyPzqYuR+dTFyHzqYmQ+dTEyn7oYmU9djMynLkbmUxcj86mLkfnUxch86mJkPnUxMp+6GJlPXYzMpy5G5lMXI/Opi5H51MXIfOpiZD51MTKfuhiZT12MzKcuRuZTFyPzqYuR+dTFyHzqYmQ+dTEyn7oYmU9djMynLkbmUxcj86mLkfnUxch86mJkPnUxMp+6GJlPXY3Mp65G5lNXI/Opq5H51HUhI3Ha0EPVyHzqamQ+dTUyn7oamU9djcynrkbmU1cj86mrkfnU1ch86mpkPnU1Mp+6GplPXY3Mp65G5lNXI/Opq5H51NXIfOpqZD51NTKfuhqZT12NzKeuRuZTVyPzqauR+dTVyHzqamQ+dTUyn7oamU9djcynrkbmU1cj86mrkfnU1ch86mpkPnU1Mp+6GplPXY3Mp65G5lNXI/Opq5H51NXIfOpqZD51NTKfuhqZT12NzKeuRuZTVyPzqev8+dSR+hdxrnzofT6Z9ohziS/41JJ+XFx7uWcn18G1PW3Ue+kvrq257X+X7tfSR5TZRJRDzZJ6KXuU6UWUIaS65SSEEvP989IHl+def1xc4p1OXwaXUos/Ls3p019No4Tk/dHsudz/bihtePUWXlgWenje6uyclP15ayE/z0nIYftMhUzpRVbaTmIJ6fPaD/7wLcDtYkrp4YPSPCmPSemelIekjMdeW09K8KQ8JiV6Uh6Tkjwpj0khT8pjUrIn5TEpxZPymBRXtIOkuKIdJMUV7WNSqivaQVJc0Q6S4op2kBRXtIOkkCflMSmuaAdJcUU7SIor2kFSXNEOkuKK9jEpzRXtICmuaAdJcUU7SIor2kFSyJPymBRXtIOkuKIdJMUV7SAprmgHSXFF+5iU7op2kBRXtIOkuKIdJMUV7SAp5El5TIor2kFSXNEOkuKKdpAUV7SDpLiifUhKW1zRDpLiinaQFFe0g6S4oh0khTwpj0lxRTtICrairfekfGpqE08KtqI9KSnYivakpGAr2nOSErAV7UlJwVa0JyUFW9GelBRsRXtSUsiT8pgUbEV7UlJc0Q6S4op2kBRXtIOkuKJ9TEp0RTtIiivaQVJc0Q6S4op2kBTypDwmxRXtICmuaAdJcUU7SIor2kFSXNE+JiW5oh0kxRXtICmuaAdJcUU7SAp5Uh6T4op2kBRXtIOkuKIdJMUV7SAprmgfk0KuaAdJcUU7SIor2kFSXNEOkkKelMekuKIdJMUV7SAprmgHSXFFO0iKK9rHpGRXtIOkuKIdJMUV7SAprmgHSSFPymNSoBVtiZs9Vii5zUsKtKI9KynQivaspEAr2rOSAq1oT0oKtmfYWUmBVrRnJQVa0Z6VFGhFe1ZSyJPymBRXtIOkuKIdJMUV7SAprmgHSXFF+5gUbM+ws5LiinaQFFe0g6S4oh0khTwpj0lxRTtIiivaQVJc0Q6S4op2kBRXtI9JwfYMOysprmgHSXFFO0iKK9pBUsiT8pgUV7SDpLiiHSTFFe0gKa5oB0lxRfuYFGzPsLOS4op2kBRXtIOkuKIdJIU8KY9JcUU7SIor2kFSXNEOkuKKdpAUV7QPSenYnmFnJcUV7SAprmgHSXFFO0gKQSel0faH61LnJQVb0Z6UFGxFe1JSsBXtSUnBVrQnJQVb0Z6TFGzPsLOSgq1oT0oKtqI9KSnYivakpJAn5TEprmgHSXFFO0iKK9pBUlzRDpLiivYxKdieYWclxRXtICmuaAdJcUU7SAp5Uh6T4op2kBRXtIOkuKIdJMUV7SAprmgfk4LtGXZWUlzRDpLiinaQFFe0g6SQJ+UxKa5oB0lxRTtIiivaQVJc0Q6S4or2MSnYnmFnJcUV7SAprmgHSXFFO0gKeVIek+KKdpAUV7SDpLiiHSTFFe0gKa5oH5OC7Rl2VlJc0Q6S4op2kBRoRVtT2pOSy7ykkCflMSnQivaspEAr2rOSAq1oz0oKtKI9KynQivakpGB7hp2VFGhFe1ZSoBXtWUlxRTtICnlSHpPiinaQFFe0g6S4oh0kxRXtICmuaB+Tgu0ZdlZSXNEOkuKKdpAUV7SDpJAn5TEprmgHSXFFO0iKK9pBUlzRDpLiivYxKdieYWclxRXtICmuaAdJcUU7SAp5Uh6T4op2kBRXtIOkuKIdJMUV7SAprmgfk4LtGXZWUlzRDpLiinaQFFe0g6SQJ+UxKa5oB0lxRTtIiivaQVJc0Q6S4or2ISlhwTYNOy0rrmlHWXFRO8qKq9pRVsizMsiK69pRVlzYjrLiynaUFZe2o6y4th1kBds+7LSsuLYdZcW17Sgrrm1HWSHPyiArrm1HWXFtO8oKtrZtO/n2KVL5rGBr27Oygq1tT8oKtpHYaVnB1rZnZQVb256VFWxte1ZWyLMyyAq2tj0rK9ja9qysuLYdZcW17Sgrrm0HWcG2FDstK65tR1lxbTvKimvbUVbIszLIimvbUVZc246y4tp2lBXXtqOsuLYdZAXbXOy0rLi2HWXFte0oK65tR1khz8ogK65tR1lxbTvKimvbUVZc246y4tp2kBVsm7HTsuLadpQV17ajrLi2HWWFPCuDrLi2HWXFte0oK65tR1lxbTvKimvbQVbADcfOyopr21FWXNuOsuLadpQV8qwMsuLadpQVZG0bw95LFkNZXmQlbX+3f7o0lPYj0OlytVHeCPHS3AP94DNdKIbQ23Z1zPV56nPars3lTj4NP2JlJ9Ha4wes24hzvtfWSXEGI3FGI3EmI3GSkTizkTiLkTirkTiN6KFqRA81I3qoGdFDzYgeakb00HzXo5PiNKKHmhE91IzooWZEDzUjeqgb0UPdiB7qRvRQx9ZDLS0/rm0tPI8z1r5dG2+33SOtPyIlM5Fia6IjI8VWRUdGiq2LjowUWxkdGSm2Njou0rBgq6MjI8XWR0dGiq2QjozUikYKC5mJ1IpGCosVjRQWKxopLFY0UljMaKRgRiMFMxopmNFIwYxGmm/lcVqkZjRSMKORghmNFMxopGBGI0UzGima0UjRjEaKZjTSfEuI0yI1o5GiGY0UzWikaEYjRTMaKZnRSMmMRkpmNFIyo5HmWwucFqkZjZTMaKRkRiMlMxopmdFIZEYjkRmNRGY0EpnRSPNH1J8WqRmNRGY0EpnRSGRGI5EZjZTNaKRsRiNlMxopm9FI80ednxapGY2UzWikbEYjZTMaKZvRSMWMRipmNFIxo5GKGY00f2T2aZGa0UjFjEYqZjQS+NTsIyM1o5HAJ2cfGakZjQQ+PfvISM1oJPAJ2kdGakYjgU/RPjJSMxoJfJL2kZGa0Ujg07SPjNSMRgKfqH1kpGY0EvhU7SMjNaORwCdrHxmpGY0EPl37yEjNaCTwCdtHRmpGI4FP2T4yUjMaycyc7WBmznYwM2c7mJmzHczM2Q5m5mxHM3O2o5k529HMnO1oZs52XMhMpFY0UjQzZzuambMdzczZjmbmbEczc7ajmTnb0cyc7WhmznY0M2c7mpmzHc3M2Y5m5mxHM3O2o5k529HMnO1oZs52NDNnO5qZsx3NzNmOZuZsRzNztqOZOdvRzJztaGbOdjQzZzuambMdzczZjmbmbEczc7ajmTnb0cyc7WhmznY8Yc52rMseaQ+fI/1gNF/LpJi2q1OLz3MfKWwLFfPnv5wGF/e85B8X91xovziUNrx6CzEsCz0s1Qnjs5UkJnhiwjAx0RMzTkzyxIwTQ56YcWKOUHk1xj0xNb9ITO7Llsbc4/L84piJaM8McT7ul38EULQHMNRklHrdAsixPA+g1z3aXtv94ja6ONW6fdZSo6mftTY3UorL/pdjqTMj7e9H2sIeaaPwOdIVYjxQ+ychlvQUIhwAkeM9UZ+erOGCxUBtY3T7zTssDw/LeOS0KKWa4p1Se/G4p9tnbnu4qNwf9rCMPkW1blvD589yDPFHsMlSsGQp2Gwp2GIp2Gop2GYp2G4o2LJYCjaAB5vLpopSWeqLYFvYLm7U79fygerDtaHUvtG+fQe6pyYv30gjujZTkkZ01ackjeRpPCKN6EpVSRrRNbCSNKKrayVpRNftStKI/o1ARxor+ncNJWm0+y2mZtrTWPOv0viRGrvfTF6mxu63jZepIU/NV6mx+63gZWrsKv2XqbGr3l+mxq4if5kauyr7VWqaXeXc9rc1QvsU4z01dtXwy9TYVcMvU2NXDb9MDXlqvkqNXTX8MjV21fDL1NhVwy9TY1cNv0yNXTX8KjUdXQ0X2l+8LiW/SE0q20vmqf46NR/BouvbQ4NFV6yHBouuQQ8NliwFi64TDw0WXfkdGiy6ljs0WHR1dmiw6HrrwGDTcoKCurfxx2UJz4ONqee9Pyj1nj9f/hFBAI+All3y3v65xMcIInwE+3sIkUIerEFCj+D2iO0RxECPERB6BCn1PQL69DVrjyCjR0Ax3yNo/TGCAh5BDnv35O2f2/IYQUWPIIb9U5RTGDzJ0yt9XO4f7LiUwQe7w1EK06tmDGGXCLf964VECH3vlYlLuH8oYhi9Zfa8szmFYCbYtPx+PCc0hrTvXaHft67et9vK926r37utfe+2/q3bxoMKX98WvnfbUA3dnsP9ttsu9vm2xzUuYftoltqfXxr6PhrhxubT54HKxieB8SEwPhmMTwHjU8H4NDA+HYvPeDbZiXwCGB+w/ZnA9mcC258JbH8msP2ZwPZnAtufCWx/zmD7cwbbnzPY/pzB9ucMtj9nsP05g+3PGWx/LlOf91y3S/OnE9NQt2/LJUKxmfpZLst27lOWMmJToNhUKDYNik1HYlMFFcYPhCCO8P6+UMN2bY00QEjiCCSOkMURijhCFUdo4gjvP/91f02gLS9rfLzX+FQHNb4tYHwCGJ8IxieB8SEwPnkun7y/tt3LSEO3AsangvFpYHw6Fp++gPEJYHwm78+fvjO30f7TExgfAuOTwfgUMD4VjE8D49NP4zM8IwvLgkYooBF6f4tucXtLrdf6zUs3NgmKDUGxyVBsChSbCsWmQbHpSGzCAsUmQLGB2osD1F4coPbiALUXB6i9OEDtxQFqLw5Qe3GE2osj1F4cofbiCLUXR6i9OELtxXHqfvPqRYgQOxSdNPWpevUDe0gJiw5h0clYdAoWHUGZs0E0cYgcofaHnLDoEBadjEWnYNGZ+r2j7MMUSkxDOg2LToeiUxYsOgGLzmSZ1Hc6NKSTsOgQFp2MRadg0alYdBqUiCwdik5dsOgELDpYX14r1pfXSlh0sL68Vqwvr7Vi0cHalSvWrtywduWGtSs3rF25Ye3KDWtXbli7csPalRvWrtywduWGtSt3rF25Y+3KHWtX7li7csfalTvWrtyxduWOtSt3rF25Q+3KcYHaleMCtSvHBWpXjgvUrhwXqF05LlC7clygduW4TB3V8OrHxxgWLDpQw2FigJoOE0PCokMz6bz68TGGjEWnYNGpWHQaFp3JA3Se/9oX44JFJ2DRiVh0EhYdwqIDNdIsRqiZZjFCDTWLEWqqWYxQY81iWrDoBCw6EYtOwqJDWHSwduWEtSsnrF05Ye3KCWtXJqxdmbB2ZcLalQlrVyasXZmwdmXC2pUJa1cmrF2ZsHbljLUrZ6xdOWPtyhlrV85Yu3LG2pUz1q6csXbljLMrx1a+sDWsYZtuVuun4+hQ9tvq925r37utf+u28XHI69vC926L37ttuLW1sPkxtzi+jb53W/7ebeV7t9Xv3da+d1v/1m3jr2et7bMAexzeFr53W/zebel7t9H3bsvfu61877bhp6Qvm619D8vwtva92/q3bhvLxde3he/dFr93W/rebcNPSY/bg9PT8MEZy47Xt5Xv3Va/d1v73m39W7eNm69f3xZe3EbDdRs3M7++LX3vtvGnZJ+Z2svw6R438b6+rXzvtvq929r3buvfum3cDPr6tvGnpG0KLyy5/eq+3/3MxRtInAGSZoDQDJA8A6TMAKkzQNoMkD4BZNw6eDTIjCe+zXji24wnvs144tuMJ77NeOLbjCe+zXji24wnvs944vuMJ77PeOL7jCe+z3ji+/vPydM3lVeMJo/xhUXCT4G8PE/8wvbgaJA0A4RmgOQZID9bTvYb6zdvjGnC5znSDJA8A6TMAKkzQN7fyJ6+C/8B0ieApGUGSJgBEmeAHLElP3lV+wOEZoDkGSBlBkidAdJmgPQJZZKWGSAzRBjNEGE0Q4TRDBFGM0QYlRkgdQZImwEy44nPM574POOJzzOe+Dzjic8znvg844nPM574POOJzzOe+DzjiS8znvgy44kvM574MuOJLzOe+DLjiS8znvgy44kvM574MuOJrzOe+Drjia8znvg644mvM574OuOJrzOe+Cr9xPf4+yHETSftNse53jH4DOjh4lZGL/oNLw2hle3vxk8HSrdv/z/oNCw6HYvOeCjSiXwCGJ8IxieB8SEwPhmMTwHjA7Y7B7DtOYDtzxFsf45g+3ME258j2P4cwfbnCLY/R8H9eYOo8hDv76I9xB/XdgpvZ7Vj8UkLGJ8AxieC8UlgfAiMTwbjU8D4VDA+YPtzAtufCWx/JrD9mcD2ZwLbnwlsfyaw/ZnA9mcS3J83iCYP0cUh8iIPEeQhojxEkocgeYgsD1HkIeSf7vL+hzYs+zyPsHzepe4gcQbI+0seYq77fltH5wOlT4ikLjNAZix8pQNAPv2m2usIJM8AKTNA6gyQNgPkiOekxjtIG4C0ZQZImAESZ4CkGSA0AyTPACkzQOoMkDYD5IAn/lZ/t4tDHqmVvswACTNA4gyQNAOEZoDkGSBlBkidAXLAEx/2IXEh9D4C6RNAwrJMQUkTvjx80b5+OEqeglKmoPQZKAe8u/dbUMIUlDgFRf55ofH7r3W/q7YXx6e0bGwo5ueXtl3e9OXe7sqdr3//2UNZGr8oq4B3V8p7/PhqIB60Eo9aiSetxEkr8ayVeNFKXGvdDFoLZ9BaOaPWyhm1Vs6otXJGrZUzaq2cUWvljGKVcwOo0gBvV6J9cjhlGgF0YYC0SAMEaYAoDfD2jta2h4ZaGgGQNECWBijSAO8+yXnZxx8ubQTQpAG6MAAt0gBBGuDdj2mOW8XJcQhQpAHeXeSS9nF6eXTUmRdpAOkU5befZNo/RbmOAJo0QBcGKIs0QJAGiNIASRqApAGyNECRBjjwSS5lBNCkAd5/kvfNro4A6ttP8r5dfwEQpAGiNMC7T3JZ9vnGSx8BkDRAlgYo0gBVGuDtJ7lvb7KUT0Z4nwC6MEBbpAGCNECUBkjSACQNkKUBijRAPRBg9CS3Jg3w/pO8NRuUOALobz/J+7nmFwBBGiBKA7xdk198y+wkDZClAYo0QJUGaNIA0ochX7zzeRBCWr54sywU2l+rLb/+XjH4FYTC/isIxRHGFy8V/hxI7jtIe3HxYdN8VvJBM/momXzSTJ40k8+ayRfN5Ktm8k0z+a6YfNRcYaPmChs1V9ioucJGzRU2aq6wUXOFjZorbNRcYSNKhf3BJ6EUzY3P5Dp42PitlXzUTD5pJk+ayWfN5Itm8lUz+aaZfFdMnhbN5DVXWNJcYUlzhSXNFZY0V1jSXGFJc4UlzRWWNFfYjFJhNz4oRXPjg1IHNz4opW3jg1KtNj4oBWjjg1JTNj4oZWLjg7Lzb3xQNvMffArY/lwmP+/PZx2vjDIco8mf6ecTvdb3rgJajmqEY5TgGJXZjJ6Nl14ZVThGDY5RR2PUFjhG0/ejZ2OUV0YRjlGCY0RwjDIcowLHqMIxanCMOhqjvsAxmr1nP522vTKKcIwSHCOCY5ThGBU4RhWOUYNj1NEYfTUzX5DSswH7H5QCHqWIRymjndh8Nef/VEoVjxLcUVuY3cL3WyhFPEoJjxLhUcLal0JQ6Q3BvDWOuGbeGidcM2+V3hArcY0TrlfiGidcr8Q1TrheiZNW4honXK/ENXpDrMS11k2V3hArca2VU6U3xEpca+VU6Q2xEtdaOVV6Q6zEtVZOUW+IFaBKA0h6Q6wAXRhA1BtiBQjSAFEaQNIbYgUgaYAsDVCkASS9IVaAJg3QhQFEvSFWgCANIOkNsQIUaQDJcYgMIOoNsQJIp0jUG2IFaNIAXRhA1BtiBQjSAFEaIEkDkDRAlgYo0gCS3hArQJMGkPSGWH+ZkvSGWAGCNECUBpD0hlgBSBogSwMUaYAqDSDpDbECdGEAUW+IFSBIA0RpgCQNQNIAWRqgSANIekOsAE0aQNIbYn17QdIbYgUI0gBRGkDSG2IFIGmALA1QpAGqNECTBpA+DBH2hoiLvDfEDUOvNwSTVzu5msmrnVzN5NVOrmbypJm82snVTF7t5Gomr3ZyNZNXO7mayav1hriR1+sNweQ1V1i93hBMXnOF1esNweQ1V1i93hBMXnOF1esNweSRvCFufKC8IZiP2snVTF7t5Gomr3ZyNZMnzeTVTq5m8monVzN5tZOrmbzaydVMXu3k6ht5vd4QTF5zhdXrDcHkNVdYvd4QTF5zhdXrDcHkNVdYvd4QTF5zhYXyhmA+SN4QzAfJG4L5IHlDMB+UarXxQfKGYD5I3hDMB8kbgvkgeUMwHyRviBsfKG8I5jP5eX8xQZ8ZYXlDMCOsgXX83hWWNwQzwvKGYEZY3hDMCMsbghlheUMwIyxvCGaE5Q1xYwTmDcGMsLwhmBGWNwQzwvKGYEYExwjLG4IZYXlDMCMsbwhmhOUNwYywvCFujMC8IZgRljcEM8LyhmBGWN4QzIjgGGF5QzAjLG8IZoTlDcGMsLwhmBGWN8TaeYTlDbFSwvKGWClheUOslLBmsK+UsLwhVkpY3hArJbijNjRviJUSljfESgnLG2KlRHiUwPalOqGDt2ru4K2aO3ir5g7eqrmDt2ru4K2aO3ir5g7eqrmDt2ru4K2aO3ir5g7eqrmDt2ru4K2aO3ir5g7eqrmDt2ru4K2aO3ir5g7eCtbBW8E6eKvmDt6quYO3au7grZo7eKvmDt6quYO3au7grZo7eKvmDt6quYO3au7grZo7eKvmDt6quYO3au7grZo7eKvmDt6quYO3au7grWAdvBWsg7eCdfBWsA7eCtbBW8E6eCtYB28F6+CtYB28FayDt4J18Fa4Dt4K18Fb4Tp4K1wHb4Xr4K1wHbwVroO3wnXwVrgO3grXwVvhOngrXAdvhevgrXAdvBWug7fCdfBWuA7eCtfBW+E6eCtcB2+F6+CtcB28Fa6Dt8J18Fa4Dt4K18Fb4Tp4K1wHb4Xr4K1wHbwVr4O34nXwVrwO3orXwVvxOngrXgdvxevgrXgdvBWvg7fidfBWvA7eCtfBm/Lv3/VBpqX9uJRifn5p27+R9IXul9LP/859492U8u5KeYdFK/GglXjUSjxpJU5aiWetxItW4lrrZtBaOIPWyhm1Vs6otXJGrZUzaq2cUWvljForZxSrnBtAlQZ4uxLl7RiQMo0AujBAWqQBgjRAlAZ4e0dr20NDLY0ASBogSwMUaYB3n+S8bJfmpY0AmjRAFwagRRogSAO8+zHNcas4OQ4BijTAu4tc0nYwWvLoqDMv0gDSKcpvP8m0f4pyHQE0aYAuDFAWaYAgDRClAZI0AEkDZGmAIg1w4JP861+MNoAmDfD+k7xvdnUEUN9+kvft+guAIA0QpQHefZLLssn3svQRAEkDZGmAIg1QpQHefpL79utyCcsIoAsDtEUaIEgDRGmAJA1A0gBZGqBIA9QDAUZPcmvSAO8/yVsLW4kjgP72k7yfa34BEKQBojTA2zX5xbfMTtIAWRqgSANUaYAmDSB9GPLFu81HIVCW94agrNgbgrJibwjKir0hKCv2hqCs2BuCsmJvCMqKvSEoK/aGoKzYG4KyYm8Iyoq9ISgr9oagrNgbgrJibwjKir0hKCv2hqCs2BuCsmJvCMqKvSEoY3lDUMbyhqCs2BuCsmJvCMqKvSEoK/aGoKzYG4KyYm8Iyoq9ISgr9oagrNgbgrJibwjKir0hmLzmCqvXG4LJa66wer0hKCv2hmDymiusXm8Iyoq9IShjeUMwHyRvCOaD5A3BfJC8IZgPSrXa+CB5Q1DG8oagjOUNQRnLG4IyljcEZSxvCMpo3hCU0bwhKKN5Q1BG84agjOYNQRnNG4IymjcEZTRvCMpo3hCU0bwhKKN5Q1BG84agjOYNQRnNG4IymjcEZTRvCMpo3hCU0bwhKKN5Q1BG84agjOYNQRnNG4IymjcEZTRvCMpo3hCU0bwhKKN5Q1BG84agjOYNQRnNG4IynDfESgnLG2KlhOUNsVLCmsG+UsLyhlgpYXlDrJTgjtrQvCFWSljeECslLG+IlRLhUcLal3LU6Q1x461yxPWNt8oJ1zfeOr0hmLjKCddMXOWEayaucsI1EyetxFVOuGbiKr0hmLjWuqnTG4KJa62cOr0hmLjWyqnTG4KJa62cOr0hmLjWyinrDcEAVRpA1BuCAbowgKw3BAMEaYAoDSDqDcEAJA2QpQGKNICoNwQDNGmALgwg6w3BAEEaQNQbggGKNIDoOMQbgKw3BANIp0jWG4IBmjRAFwaQ9YZggCANEKUBkjQASQNkaYAiDSDqDcEATRpA1BuCf5kS9YZggCANEKUBRL0hGICkAbI0QJEGqNIAot4QDNCFAWS9IRggSANEaYAkDUDSAFkaoEgDiHpDMECTBhD1huC3F0S9IRggSANEaQBRbwgGIGmALA1QpAGqNECTBpA+DBH2hihB3hvihqHXG4LJq51czeTVTq5m8monVzN50kxe7eRqJq92cjWTVzu5msmrnVzN5NV6Q9zI6/WGYPKaK6xebwgmr7nC6vWGYPKaK6xebwgmr7nC6vWGYPJI3hA3PlDeEMxH7eRqJq92cjWTVzu5msmTZvJqJ1czebWTq5m82snVTF7t5Gomr3Zy9Y28Xm8IJq+5wur1hmDymiusXm8IJq+5wur1hmDymiusXm8IJq+5wkJ5QzAfJG8I5oPkDcF8kLwhmA9Ktdr4IHlDMB8kbwjmg+QNwXyQvCGYD5I3xI0PlDcE85n8vL+YoM+MsLwhmBHWwDp+7wrLG4IZYXlDMCMsbwhmhOUNwYywvCGYEZY3BDPC8oa4MQLzhmBGWN4QzAjLG4IZYXlDMCOCY4TlDcGMsLwhmBGWNwQzwvKGYEZY3hA3RmDeEMwIyxuCGWF5QzAjLG8IZkRwjLC8IZgRljcEM8LyhmBGWN4QzAjLG2LtPMLyhlgpYXlDrJSwvCFWSlgz2FdKWN4QKyUsb4iVEtxRG5o3xEoJyxtipYTlDbFSIjxKYPtSm9DB2zR38DbNHbxNcwdv09zB2zR38DbNHbxNcwdv09zB2zR38DbNHbxNcwdv09zB2zR38DbNHbxNcwdv09zB2zR38DbNHbxNcwdvA+vgbWAdvE1zB2/T3MHbNHfwNs0dvE1zB2/T3MHbNHfwNs0dvE1zB2/T3MHbNHfwNs0dvE1zB2/T3MHbNHfwNs0dvE1zB2/T3MHbNHfwNrAO3gbWwdvAOngbWAdvA+vgbWAdvA2sg7eBdfA2sA7eBtbB28A6eBtcB2+D6+BtcB28Da6Dt8F18Da4Dt4G18Hb4Dp4G1wHb4Pr4G1wHbwNroO3wXXwNrgO3gbXwdvgOngbXAdvg+vgbXAdvA2ug7fBdfA2uA7eBtfB2+A6eBtcB2+D6+BtcB28Da6Dt8F18Da4Dt6G18Hb8Dp4G14Hb8Pr4G14HbwNr4O34XXwNrwO3obXwdvwOngbXgdvg+vgbcsXHbw5t+22XNtzjOPe8r7RaVh0OhadL1qhz+MTwPhEMD4JjA+B8clgfAoYH7DdOYBtzwFsf45g+3ME258j2P4cwfbnCLY/R7D9OQruzxtElYd4fxc97pVR5tOx+KQFjE8A4xPB+CQwPgTGJ4PxKWB8KhgfsP05ge3PBLY/E9j+TGD7M4HtzwS2PxPY/kxg+zMJ7s8bRJOH6OIQeZGHCPIQUR4iyUOQPESWhyjyEPJPd3n/Q/vi5XoGiTNA3l/y1z/JlT4hkrrMAJmx8JUOAHn6gjuD5BkgZQZInQHSZoAc8Zw8fUuWf5BeZoCEGSBxBkiaAUIzQPIMkDIDpM4AaTNADnjin7/1ye98LDNAwgyQOAMkzQChGSB5BkiZAVJngBzwxD9/k5dB+gSQr97zPholTfjyEBaagpKnoJQpKH0GygHv7v0WlDAFJU5BkX9e4vj917rfVduL41NaNjYU8/NL2y5v+kL/+HTO+vOHsnH8oqwC3l0p7/Hjq4F40Eo8aiWetBInrcSzVuJFK3GtdTNoLZxBa+WMWitn1Fo5o9bKGbVWzqi1ckatlTOKVc4NoEoDvF2J8nbiRJlGAF0YIC3SAEEaIEoDvL2jte2hoZZGACQNkKUBijTAu09yXrZL89JGAE0aoAsD0CINEKQB3v2Y5rhVnByHAEUa4N1FLmkbDFDy6KgzL9IA0inKbz/JtH+Kch0BNGmALgxQFmmAIA0QpQGSNABJA2RpgCINcOCT/OuJKRtAkwZ4/0neN7s6AqhvP8n7dv0FQJAGiNIA7z7JZdnke1n6CICkAbI0QJEGqNIAbz/JfXuTpYRlBNCFAdoiDRCkAaI0QJIGIGmALA1QpAHqgQCjJ7k1aYD3n+St2aDEEUB/+0nezzW/AAjSAFEa4O2a/OJbZidpgCwNUKQBqjRAkwaQPgz54p3PoxD6F2+W/eSox7D/CkJxhBFQTOh/+iec/tWbSVrIR83kk2bypJl81ky+aCZfNZNvmsl3xeSj5gobNVfYqLnCRs0VNmqusFFzhY2aK2zUXGGj5gobUSrsDz4JpWhufFBM6L+zuAnFsf5b5FHs7b9FnjSTz5rJF83kq2byTTP5rpg8LZrJa66wpLnCkuYKS5orLGmusKS5wpLmCkuaKyxprrAZpcJufFCK5sYHpQ5ufFBK28YHpVptfFAK0MYHpaZsfFDKxMYHZeff+KBs5j/4FLD9uUx+3l/MOu5fNX6cygjLsLl/1dZwZo5qhGOU4BjNtkd/Pl66f9XYcCqjBseoozFqCxyj6fvR0zHK/atujlMZJThGBMcowzEqcIwqHKMGx6ijMeoLHKPZe/bzadv9q76dUxklOEYExyjDMSpwjCocowbHqKMx+mpmviClpwP2V0oBj1LEo5TRTmy+mvN/KqWKRwnuqC3MbuH7LZQiHqWER4nwKIHtS12nN8SNt8oR1zfeKidc33jr9IZg4ionXDNxlROumbjKCddMnLQSVznhmomr9IZg4lrrpk5vCCautXLq9IZg4lorp05vCCautXLq9IZg4lorp6w3BANUaQBRbwgG6MIAst4QDBCkAaI0gKg3BAOQNECWBijSAKLeEAzQpAG6MICsNwQDBGkAUW8IBijSAKLjEG8Ast4QDCCdIllvCAZo0gBdGEDWG4IBgjRAlAZI0gAkDZClAYo0gKg3BAM0aQBRbwj+ZUrUG4IBgjRAlAYQ9YZgAJIGyNIARRqgSgOIekMwQBcGkPWGYIAgDRClAZI0AEkDZGmAIg0g6g3BAE0aQNQbgt9eEPWGYIAgDRClAUS9IRiApAGyNECRBqjSAE0aQPowRNYb4nb2L+4NwRhqvSFW8lonV6/ktU6uXslrnVy9kifN5LVOrl7Ja51cvZLXOrl6Ja91cvVKXqs3BJNX6w2xktdcYdV6Q6zkNVdYtd4QK3nNFVatN8RKXnOFVesNsZIH8oZgPkjeECsfrZOrV/JaJ1ev5LVOrl7Jk2byWidXr+S1Tq5eyWudXL2S1zq5eiWvdXI1k1frDbGS11xh1XpDrOQ1V1i13hArec0VVq03xEpec4VV6w2xktdcYZG8IVY+QN4QKx8gb4iVD5A3xMoHpVptfIC8IVY+QN4QKx8gb4iVD5A3xMoHyBuC+SB5Q6x8Jj/vzyfor4ygvCFWRlAD69b3rqC8IVZGUN4QKyMob4iVEZQ3xMoIyhtiZQTlDbEygvKGYEZY3hArIyhviJURlDfEygjKG2JlRHCMoLwhVkZQ3hArIyhviJURlDfEygjKG4IZYXlDrIygvCFWRlDeECsjKG+IlRHBMYLyhlgZQXlDrIygvCFWRlDeECsjKG+Ij84jKG+ID0pQ3hAflKC8IT4oQc1g/6AE5Q3xQQnKG+KDEtxRG5g3xAclKG+ID0pQ3hAflAiPEta+FLJ8B+8NQ28HL5NX21/E5NX2FzF5tf1FTJ40k1fbX8Tk1fYXMXm1/UVMXm1/EZNX28F7I6+3g5fJa66wejt4mbzmCqu3g5fJa66wejt4mbzmCqu3g5fJI3Xw3vhAdfAyH7X9RUxebX8Rk1fbX8TkSTN5tf1FTF5tfxGTV9tfxOTV9hcxebX9RTfyejt4mbzmCqu3g5fJa66wejt4mbzmCqu3g5fJa66wejt4mbzmCgvVwct8kDp4mQ9SBy/zQergZT4o1Wrjg9TBy3yQOniZD1IHL/NB6uBlPkgdvDc+UB28zGfy8/6iz5EZYXXwMiOs1wr5vSusDl5mhNXBy4ywOniZEVYHLzPC6uBlRlgdvMwIq4P3xgisg5cZYXXwMiOsDl5mhNXBy4wIjhFWBy8zwurgZUZYHbzMCKuDlxlhdfDeGIF18DIjrA5eZoTVwcuMsDp4mRHBMcLq4GVGWB28zAirg5cZYXXwMiOsDt618wirg3elhNXBu1LC6uBdKcF1yqF18K6UsDp4V0pwR21oHbwrJawO3pUSVgfvSonwKGHtSzH9/l0fZFraj0sp5ueXtv0bSV/ofin9/O/cN95NKe+ulHdYtBIPWolHrcSTVuKklXjWSrxoJa61bgathTNorZxRa+WMWitn1Fo5o9bKGbVWzqi1ckaxyrkBVGmAtytR3o4BKdMIoAsDpEUaIEgDRGmAt3e0tj001NIIgKQBsjRAkQZ490nOy3ZpXtoIoEkDdGEAWqQBgjTAux/THLeKk+MQoEgDvLvIJW0HoyWPjjrzIg0gnaL89pNM+6co1xFAkwbowgBlkQYI0gBRGiBJA5A0QJYGKNIABz7Jv/7FaANo0gDvP8n7ZldHAPXtJ3nfrr8ACNIAURrg3Se5LJt8L0sfAZA0QJYGKNIAVRrg7Se5b78ul7CMALowQFukAYI0QJQGSNIAJA2QpQGKNEA9EGD0JLcmDfD+k7y1sJU4AuhvP8n7ueYXAEEaIEoDvF2TX3zL7CQNkKUBijRAlQZo0gDShyFfvNt8FEJK8t4QKSn2hkhJsTdESoq9IVJS7A2RkmJviJQUe0OkpNgbIiXF3hApKfaGSEmxN0RKir0hUlLsDZGSYm+IlBR7Q6Sk2BsiJcXeECkp9oZISbE3REqKvSFSwvKGSAnLGyIlxd4QKSn2hkhJsTdESoq9IVJS7A2RkmJviJQUe0OkpNgbIiXF3hApKfaGSEmxNwST11xh9XpDMHnNFVavN0RKir0hmLzmCqvXGyIlxd4QKWF5QzAfJG8I5oPkDcF8kLwhmA9Ktdr4IHlDpITlDZESljdESljeEClheUOkhOUNkRKaN0RKaN4QKaF5Q6SE5g2REpo3REpo3hApoXlDpITmDZESmjdESmjeECmheUOkhOYNkRKaN0RKaN4QKaF5Q6SE5g2REpo3REpo3hApoXlDpITmDZESmjdESmjeECmheUOkhOYNkRKaN0RKaN4QKaF5Q6SE5g2REpo3REpo3hApwXlDrJSwvCFWSljeECslrBnsKyUsb4iVEpY3xEoJ7qgNzRtipYTlDbFSwvKGWCkRHiWsfYkWnd4QN94qR1zfeKuccH3jrdMbgomrnHDNxFVOuGbiKidcM3HSSlzlhGsmrtIbgolrrZs6vSGYuNbKqdMbgolrrZw6vSGYuNbKqdMbgolrrZyy3hAMUKUBRL0hGKALA8h6QzBAkAaI0gCi3hAMQNIAWRqgSAOIekMwQJMG6MIAst4QDBCkAUS9IRigSAOIjkO8Ach6QzCAdIpkvSEYoEkDdGEAWW8IBgjSAFEaIEkDkDRAlgYo0gCi3hAM0KQBRL0h+JcpUW8IBgjSAFEaQNQbggFIGiBLAxRpgCoNIOoNwQBdGEDWG4IBgjRAlAZI0gAkDZClAYo0gKg3BAM0aQBRbwh+e0HUG4IBgjRAlAYQ9YZgAJIGyNIARRqgSgM0aQDpwxBhbwjq8t4QNwy93hBMXu3kaiavdnI1k1c7uZrJk2byaidXM3m1k6uZvNrJ1Uxe7eRqJq/WG+JGXq83BJPXXGH1ekMwec0VVq83BJPXXGH1ekMwec0VVq83BJNH8oa48YHyhmA+aidXM3m1k6uZvNrJ1UyeNJNXO7mayaudXM3k1U6uZvJqJ1czebWTq2/k9XpDMHnNFVavNwST11xh9XpDMHnNFVavNwST11xh9XpDMHnNFRbKG4L5IHlDMB8kbwjmg+QNwXxQqtXGB8kbgvkgeUMwHyRvCOaD5A3BfJC8IW58oLwhmM/k5/3FBH1mhOUNwYywBtbxe1dY3hDMCMsbghlheUMwIyxvCGaE5Q3BjLC8IZgRljfEjRGYNwQzwvKGYEZY3hDMCMsbghkRHCMsbwhmhOUNwYywvCGYEZY3BDPC8oa4MQLzhmBGWN4QzAjLG4IZYXlDMCOCY4TlDcGMsLwhmBGWNwQzwvKGYEZY3hBr5xGWN8RKCcsbYqWE5Q2xUgKbwd7hvCFWSljeECsluKM2NG+IlRKWN8RKCcsbYqVEeJSw9qVc5Dt4bxh6O3iZvNr+Iiavtr+IyavtL2LypJm82v4iJq+2v4jJq+0vYvJq+4uYvNoO3ht5vR28TF5zhdXbwcvkNVdYvR28TF5zhdXbwcvkNVdYvR28TB6pg/fGB6qDl/mo7S9i8mr7i5i82v4iJk+ayavtL2LyavuLmLza/iImr7a/iMmr7S+6kdfbwcvkNVdYvR28TF5zhdXbwcvkNVdYvR28TF5zhdXbwcvkNVdYqA5e5oPUwct8kDp4mQ9SBy/zQalWGx+kDl7mg9TBy3yQOniZD1IHL/NB6uC98YHq4GU+k5/3F32OzAirg5cZYb1WyO9dYXXwMiOsDl5mhNXBy4ywOniZEVYHLzPC6uBlRlgdvDdGYB28zAirg5cZYXXwMiOsDl5mRHCMsDp4mRFWBy8zwurgZUZYHbzMCKuD98YIrIOXGWF18DIjrA5eZoTVwcuMCI4RVgcvM8Lq4GVGWB28zAirg5cZYXXwrp1HWB28KyWsDt6VElYH70oJrlMOrYN3pYTVwbtSgjtqQ+vgXSlhdfCulLA6eFdKhEcJal+67Un1i/6ZstfGutyPMm8fvPt98Zv3pW/eR9+8L//8ffFrB9ibJthrT6yf7vzIaMzhq9fsa9gXuS+f7lza/c7+3Tu/eBv9t9wZvn1n/Ok7b//2f//wX3/6w//+jz/+9XYP/8f//vO//u1Pf/nzj3/92//7z4//crv2/wM="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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DWLFixaGVrFcNEfEirSLQpF2USjSLgrFQFGgSLsoFGkXhSLtolCkXRSKtItA8aKnmasVaReFIu2iUKRdFIqBokCRdlEo0i4KRdpFoUi7KBRpl2PFcS3bmiNX/op+vOj52GpF2uUTikvcFXNNMVA8VJxj+9CV23+ONUXmRYUi86JCkXlRoci8+AnFsq0iLWmoKTIvChQvesqtWpF5UaHIXvcnFO8dvaRau1z0CM5vUyzzfc1lrinyGn2omNOwfaZfTilqirxGCxQvej6gWpHXaIUir9EKRd6PVigGigJF5kWFIvuLCkX2FxWKtItCkXYRKF70xDm1Iu2iUKRdFIq0i0IxUBQo0i4KRdpFoUi7KBRpF4Ui7SJQvOihcWpF2kWhSLsoFGkXhWKgKFCkXRSKtItCkXZRKNIun1CcYlecppoi7SJQvOoRoGJF2kWhSLsoFGkXhWKgKFCkXRSKtItCkXZRKNIuCkXaRaB41UNcxYq0i0IxUGz/m9SrngwqVmReVCgyL37i76PTcl9zba/7qgeUihWZFwWKVz36VKzIvKhQZK9bochet0IxUBQo0i4KRdpFoUi7KBRpF4Ui7SJQ5JxUiSLtolCkXRSKtItCMVAUKNIuCkXaRaFIuygUaReFIu0iUOScVIki7aJQpF0UirSLQjFQFCjSLgpF2kVwGgTnpEoUaReFIu3SrhickypRpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXQSKnNkrUaRdFIq0i0KRefFYcdr/Vv/2pKaD7xz7ExxjHGvkDJd2ciZROzljq52cGddNzgHZfnKmZzs5o7adnPcU7OQBuZuc+rSTU592curTTk59usk541hMXtL09tiS1ho4I6IZnP0VLfha8rbi6psTHIPpBueWogVPw350VxpqR3cFRxr6yalOOznVaSenOu3kVKednJncTc4Bj35y3vO0k7OdZSenPu3kAbmbnPpUk8/7g1OqvTXBcZd+curTTk592smpTzc5R3T6yalPOzn1aSenPu3kAbmbnPq0k1OfdnLq005OfdrJqU83OQf++smpTzs59Wknpz7t5AG5m5z6tJNTn2LynPYH5zTVyKlPOzn1aSenPt3kHNnsJ6c+7eTUp52c+rSTB+RucurTTk592smpTzs59Wknpz7d5By67SenPu3k1KednPq0kwfkbnLq005OfdrJqU87OfVpJ6c+zeQTx6b7yalPOzlDopo87uRRauQMiXZyXj7V5PNul5dcIefkXj85L592cjZv7eRs3trJA3I3OXO5nZy53E7O5q2dnM1bOzn16SbnmGw/OfVpJ6c+7eTUZwv5phgoHiuW7RmmeaheizSiQpHsUyhScgpF4kyhSG8JFEcSSqFIFSkUCR2FIu2iUAwUBYq0i0KRdlEo0i4KRdpFoUi7CBSDdlEo0i4KRdpFoUi7KBQDRYEi7aJQpF0UirSLQpF2USjSLgLFiXZRKNIuCkXaRaFIuygUA8VDxTnyrhhjTZF2USjSLgpF2kWhSLsoFGkXgeJMuygUaReFIu2iUKRdFIqBokCRdlEo0i4KRabuQ8Wc9r8DvP1n7e8AZ6ZugeLC1K1QZOpWKDJ1KxSZuhWKgaJAkalbocjUrVDkHQOFIu2iUKRdBIqcMC9RpF0UirSLQpF2USgGigJF2kWhSLsoFGkXhSLtolCkXQSKnE8uUaRdFIpM3b9R3GACmDoMs/EDGMbdBzBMsFWYmaNi3Sc6zhwV6ydne9ROzlRnJw/I3eRMonZyZlw7OdOznZzNYjs5O8tuck5al5Mv005equTUp52c+rSTU5928oDcTU592smpT/O5pTMnrfvJqU87OfXpJuekdT859Wknpz7t5NSnnTwgd5NTn3Zy6tNOTn3ayalPOzn16SbnkHo/OfVpJ6c+7eTUp508IHeTU592curTTk592smpTzs59ekmD+rTTk592smpTzs59WknD8jd5NSnnZz6tJNTn3Zy6tNOTn26ySfq005OfdrJqU87OfVpJw/I3eTM5VrytWxnpq5lroEzlZvBmcm94DMTuRmcedwMzjRuBmcWN4MH4F5w3gUyg/MekBmc0jSDU5pmcErTC75QmmZwStMMTmmawSlNM3gArn3PZxjSbpeiRk5r2smpTTs5vWknpzjt5DSnm7xQnXZyutNOTnnayWlPO3lA7ianPtXkqex2Y6qRU592curTTk592smpTzf5Sn3ayanP7zgk1smpT/dcvlKfdvKA3E1OfdrJqU87OfVpJ6c+7eTUp5l8GahPOzn1aSenPu3k1KedPCB3k1OfdnLq005OfdrJqU87OfXpJk/Up52c+rSTU592curTTh6Qu8mpTzs59Wknpz7t5NSnnZz6dJNn6tNOTn3ayalPOzn1aScPyN3k1KednPq0k1OfdnLq005OfbrJR+rTTk592smpTzs59WknD8jd5NSnnZz6tJNTn27yYC7Xkpc0vT22pLUGzlQuBt9XXKalBs5MbgZnIjeDM6mYwZlTzODskZvB2SH3gk/M4WZw5nAzOHO4GZw53AwegHvB2RU3g1OaZnBK0wxOaYrB90WUUtsPnyhNL/hMaZrBKU0zOKVpBqc0zeABuBec0jSDU5pmcErTDE5pmsEpTS/4QmmawSlNMzilaQanNM3gAbgXnNI0g1OaZnBK0wxOaZrBKU0veKE0zeCUphmc0jSDU5pm8ADcC05pmsEpTTM4pWkGpzTN4JSmF3ylNM3glKYZnNI0g1OaZvAA3AtOaZrBKU0zOKVpBqc0zeCUphW8DISPGZzwMYMTPmbwANwLTviYwdvHwsjbR2ZHzEfg07IJTu/Wc5uW9gWtnS0oDb0tKPW2oNzbgkbvguZhu+XMOaoLit4WNPW2oLm3BS29Laj0tqDVvaDtNXIe5tqC8tDbglJvC8q9LWjsbUHR24Km3hY097agpbcFld4W1NudeuztTj32dqcee7tTj73dqcfe7tRjb3fqsbc79djbnXrs7U499nanjt7u1NHbnTp6u1NHb3fq6O1OHb3dqaO3O3X0dqeO3u7U0dudeurtTj31dqeeertTT73dqafe7tRTb3fqqbc79dTbnbr+cenz/ZTXYVSup2zvheZ3yxmHaV9O6ms5ua/ljH0tJ/paztTXcua+lrP0tZzS13LWrpaz9HVXXvq6Ky993ZWXvu7KS1935aWvu/LS11156euuvPR1V176uiuXvu7Kpa+7cvH+oh/+s7Iyd7Ye78V8WH7r0Nl6UmfryZ2tZ+xsPdG8nuHdeuJgPWnab0BpHnLtDrRO3a1o7m5FS3crKt2taO1sReswdLei5F3RnNd9RbFUV5S7W9HY3YqiuxVN3a1o7m5FS3cr+p737O1nrN//Z6TB8DOS4Wdkw88YDT8jDD9jMvyM2fAzFsPPMPyeJ8PveTb8nmfD73k2/J5nw+95NvyeZ8PveW7/PV+G/Wes5e9NW3BrXvpaTulrOWtXyxmHvpaT+lpO851uytuGbEzTfLCcpWy/6uXwUwgeLv3jQ9dp2Ba8Tu9vIdWPILg9ZJu7h+H+4LzfbsYRlI8oAcpHlAmUjygzKB9RFlA+ohRQPqKsoHxAiQGUjygJlI8oTLQVFCbaCkqA8hGFibaCwkRbQWGiraB4J9qSt72g9x9k+OBfzu3brPMvEr/7WLXKispHlWlApaKSUKmoZFQqKiMqFZVApaIyoVJRmVGpqCyoVFSYbWsqzLYVlZnZtqbCbFtTYbatqTDb1lSiWaVsj415WQ5Wn6Zh/8iY6TfbTtuKpu5WVLwrmse8rWguw9Gj17RdPLeVLofXg/bqWZGpy7R/EsbLyiRkHshkZB7IjMg8kAlkHshMyDyQmZF5ILMg80CGGfiRDDPwA5nCDPxIhhn4kQwz8CMZZuBHMs2vTffzWWNZjv4ELA/zJpPTOpif63qd59r+SV9P9FzThZ5rvtBzHS/0XONCz3W60HOdL/Rclws91wvNTetl5qY8DJeZm27P9TJz0+25XmZuuj3Xy8xNt+fafG8q0/bJd7Ee/jFPLvvqc4n7gup/z5OnYftXL3kaX+GPivLQ/vF5gH8beALcC54B94KPgHvBA3Av+AS4F3wG3Au+AO4FL4B7wSlNL3imNM3glKYZnNI0g1OaZvAA3Av+OqX5FH8FehN/ndR8FvHXac1nEX+d2HwW8depzScRH18nN59F/HV681nEXyc4n0X8dYrzWcQDcbM4zekWpznd4jSnW5zmdIvTnGbxoDnd4j0355hiEx/zGAff+/DT927Ptufe0z/bnufQb3y2z/IJAjf1nmfR11XveR59XfWeZ9LXVe95Ln1Z9ann2fR11V9oPn0i9Reak59Ivef3Rl5XPVD/AnXa9CvUadOvUKdNv0KdNv0Kddr0C9Rn2vQr1LueYXJsf3Qxjikdfe+v/Myiueup5Ikcu54znsix68nhiRy7ngWex3Hp+tX9iRy73kt+Iseud4efyLHr/d4ncgwcJY70jMaRntE40jMaR3pG40jPSBwLPaNxdM+Py/ZP2vNaDj/HZR63Xd91LtPBcx2X/QPW030Xd8y1h87rRj4uafj9B983k+dxfP/QjTAgbCWcIGwlnCFsJVwgbCUsELYSrhA2Eq4DhK2ECcJWwgxhKyF10kwYELYSUieHhPP2fecSNULqpJmQOmkmpE6aCamTRsI0UCfNhNRJMyF10kxInTQTBoSthNRJMyF10kxInTQTUifNhNRJK2GiTpoJqZNmQuqkmZA6aSYMCFsJqZNmQuqkmZA6aSakTpoJqZNWwkydNBNSJ82E1EkzIXXSTBgQthJSJ82E1EkzIXXSTEidNBNSJ62EI3XSTEidNBNSJ82E1EkzYUDYSkidNBNSJ82E1EkzIXXSTEidtBIGddJMSJ00E1InzYTUSTNhQNhKSJ00E1InzYTUSTMhddJMSJ38mvDNZSI56i50RN2FOKi7MPHXXQKXqguzed2FgbvuwhRdd2E0rrsw71ZdZubdugvzbt2Febfuwrxbdwlcqi7Mu3UX5t26C/Nu3YV5t+7CvFt1WZh36y7Mu3UX5t26yzXnl2W8u8RYc7nm/HLscsnXo7g98e2x+dcnNXzTg98QyyVfvNSIl3ylUyNe8mVRjXjJPSM1YoDYjnjJaU6NeMnRT414yX0uNeIlN8XUiBRLO+I1zzVVI1IsAkSKRYBIsQgQA8R2RIpFgEixCBApFgEixSJApFiaEfM1zzpVI1IsAkSKRYBIsQgQA8R2RIrlCDHnsv0zkjwOuYZIsQgQKZZjxDndEWu/ztc8dfLbEKdctjVPea0hMicKEJkTBYjMiQLEALEdkTlRgMicKEBkThQgsrMtQGRnux3xmidRqhEpFgEixSJApFgEiAzbAkSGbQEiw3Y74jWPs/s2xLLsbw+U9eDBYwzbKsaovqt1zdPvvlSc4cktzqTlFg/EzeIMwm5xpma3OCO2W5zNb7c4O+Vm8WseUvil4jSnW5zmdIvTnG5xpkOpeLnLpdpe7TUPcfs672uePPT9vNf9n9n/6undvdlR8XpzP5F6p2HY/gQiDSlq4rSmWfyap/V8qTit6RanNd3itKZbPBA3izONu8V5f9Mtzg6WW5zmdIvTnGbxa56Y9T3F59jEU6q9E3HNs7i+VJzmdIvTnG7xQNwsTnO6xWlOtzjN6RanOd3iNKdZnIMu7eI0p1uc5nSL05xu8UDcLE5zusVpTrc4zekWpznd4jSnWZyjSu3iNKdWPKddPKepJk5zusVpTrd4IG4Wpznd4jSnW5zmdIvTnG5xmtMrPnLYrF2c5nSL05xucZrTLR6Im8VpTrc4zekWpznd4jSnW5zmNItzcLVdnOZ0i9OcbnGa0y0eiJvFaU63OM1pFueQYLV43MWj1MSZDt3ivHKKxedxF19yTZxXTrc4r5xucXZr3eLs1rrF2a01i3OitV2cedwtzm6tW5zdWrd4IG4Wpznd4jSnW5zmdIvTnG5xmtMszonWdnGa0y1Oc7rFac4G8Q0xQGxHpAwFiMSeAJF+EyCSZAJEKqsdcSKcBIi0kACRvBEgUiwCxACxHZFiESBSLAJEikWASLG0I86MOIeI67Tsa55TDZERR4DIC8sxYrmvuf7rzAuLAJEXFgEiW2HtiJwar0BkK0yAyJwoQGROFCAGiO2IbIUJECkWASLFcoS4bJ/EsEw1QGqlEZBSaQPknPFWQAqlEZA6aQSkTBoBA8A2QIqkEZAaaQSkRBoBKZFGQEqkDZCzkFsBGaQbARmkGwEDwDZABulGQAbpI8Dx/gnYY85LDZFhWoDIQC1AZKhuRgyO2FUgUicCRApFgMiIc4wY6444jTVERpx2RM7RO0Ychx1xzHMNkRcWASIvLAJEtr8EiAFiOyLbYAJE5kQBInOiAJGtMAEiW2HtiJztqECkWASIFMsx4v6Nx9sbezVEikWAGCC2I1IsAkSKRYBIsRwi3t5D2RBjrO1sc66mApFiaUfk9EsFIsUiQKRYBIgUiwAxQGxHpFgEiBSLAJFiESBSLAJEiqUdkbMTFYgUiwCRYhEgUiwCxACxHZFiESBSLAJEikWASLEIECmWdkQOLVQgUiwCRIpFgEixCBADxHZEikWASLEIECkWASLFIkCkWNoRZ4pFgEixCBApFgEixSJADBDbESkWASLFIkCkWASIFIsAkWJpR+Q0XAUixSJApFiaEachQDxCPPr8xGlg2D5GXNKOuA41REYcASIjTjsiH4eqQGTEESAy4ggQ2ZQVIAaI7YjMiQJENmUFiGzKChApFgEixdKOyMehfuID1/K25tt/TjVEikWASLEIECkWAWKA2I5IsQgQKRYBIsUiQKRYBIgUSzsiH4f6GcT72QORa4gUiwCRYhEgUiwCxACxHZFiESBSLMeIBycDTXwcqgKRYhEgUiztiHwcqgKRYhEgUiwCRIpFgBggtiNSLAJEikWASLEIECkWASLF0o7Ix6EqECkWASLFIkCkWASIAWI7IsUiQKRYBIgUiwCRYhEgUiztiHwcqgKRYhEgUiwCRIpFgBggtiNSLAJEikWASLEIECkWASLF0o7Ix6EqECkWASLFIkCkWASIAWI7IsUiQKRYBIgM2wJEhu12xMKwLUBMILYjMmwLEBlxjhDzOi37mudUQ2TEESCyKStAZE4UIDIntiOuzIkCROZEASJzogCRTVkBYoDYjkixCBApFgEixXKMuO6HHw6p1BApFgEixdKMOA8UiwCRYhEgUiwCRIrlGLHc17yONcQAsR2RYhEgUiwCRIpFgEixCBAplnZEDslWIFIsAkSKRYBIsQgQA8R2RIpFgEixCBApFgEixSJApFjaETkkW4FIsQgQKRYBIsUiQAwQ2xEpFgEixSJApFgEiBSLAJFiaUfkkGwFIsUiQKRYBIgUiwAxQGxHpFgEiBSLAJFiESBSLAJEiqUdkUOyFYgUiwCRYhEgUiwCxACxHZFiESBSLAJEikWASLG0I3I08TFiWfK25rIePDjliLcH3/6z9ne9nGNsF2cCdYsH4mZxZlu3OIOwW5yp2S3OiO0W5x0EszjnRdvFaU6x+DLt4qUqTnO6xWlOt3ggbhanOd3iNKdbnOYUi8/jLr7kmjjN6RanOc3inPhtF6c53eI0p1uc5nSLB+JmcZrTLU5zusVpTrc4zekWpznN4hx8bxenOd3iNKdbnOZ0iwfiZnGa0y1Oc7rFaU63OM3pFqc5zeIrzekWpznd4jSnW5zmdIsH4mZxmtMtTnO6xWlOtzjN6RanOb3iy0BzusVpTrc4zekWpznd4oG4WZzmdIszj0vF17I99ldP7+7NNG71TsziXm8mca83c7jXmync6x14W72ZwL3evOfj9eYdH683fen1pi+t3pm+9HrTl15v+tLrTV96vQNvqzd9qX2HZxjS24PTkKImTmG6xWlMtziV6RanM83iI6XpFqc13eLUpluc3nSLB+JmcZrTLU5zisVT2cXHVBOnOd3iNKdbnOY0iwfN6RanOd3iNOf3mw7r4jSneR6PQNwsTnO6xWlOtzjN6RanOd3iNKdZfKI53eI0p1uc5nSL05xu8UDcLE5zusVpTrc4zekWpznd4jSnWXymOd3iNKdbnOZ0i9OcbvFA3CxOc7rFaU63OM3pFqc53eI0p1l8oTnd4jSnW5zmdIvTnG7xQNwsTnO6xWlOtzjN6RanOd3iNKdZvNCcbnGa0y1Oc7rFaU63eCBuFqc53eI0p1uc5nSL05xm8ZV5XCpe7nJprXkzjWu99xWXaal5M4t7vQNvqzczitebCcXrzZ6407sM7Ih7vZm/vd7M315v5m+vd+Bt9WYf3OvNLrjXm770etOXXm/6Uuu9L6KUyv53SfSl15u+9HrTl15v+tLrHXhbvelLrzd96fWmL73e9KXXm760emf60utNX3q96UuvN33p9Q68rd70pdebvvR605deb/rS601fWr1H+tLrTV96velLrzd96fUOvK3e9KXXm770etOXXm/60utNX1q9g770etOXXm/60utNX3q9A2+rN33p9aYvvd70pdebvvR605dW74m+9HrTO15vesfrHXhbvekdrze94/W+5Dx4e+j2Od3jsqSKy3zJue0TLpd8vR/LEJtLSbnmcsnX5U+4XPL18xMul3yd+4TLJfffPuFyyX2yT7hcc345dFmuOb8cu1zy3x98wuWS+2afcGHerbsELlUX5t26C/Nu3YV5t+7CvFt3Yd6tulzzZPFPuDDv1l2Yd+su15x3l3W4uxy8pZLyPL49OOWlihggtiNec5IWI15z7BYjXnNGFyNec6AXI1703Xop4nrRt/a1iNfsCjHiNSNEjEixCBADxHZEikWASLEIECkWASLFIkCkWJoR12seEq9GpFgEiBSLAJFiESAGiO2IFIsAkWIRIFIsAkSKRYBIsbQjXvPYcTUixXKIOK5lQ4ycaogUiwCRYjlGXOKOWP11Zk48RJxj+2iD23+ONUTmRAEic6IAkTmxHfGaxwd/I2LZVpGWNNQQmRMFiMyJAkTmRAFigHiIeG/nJdWK5ZrnkH4bYpm3b5zK+zXviNc8fPGbEHMatk/MyilFDZFXZwEir84CRF6dBYi8OgsQed9ZgMh+ogCROVGAyH6iAJH9xHbEax7np0akWASIFIsAkWIRIAaI7YgUiwCRYhEgUiwCRIpFgEixtCNe84A4NSLFIkCkWASIFIsAMUBsR6RYBIgUiwCRYhEgUiwCRIqlHfGqRyN+E+IUO+I01RApFgEixSJApFgEiAFiOyLFIkCkWASIFIsAkWIRIFIs7YgXPQxVjEixCBApFgEixSJAZE5s/yvTi57eKUZkThQgMice/71z2v/yvkRtZ/uih4iKEZkTBYjMiQJE5kQBYoDYjsjOtgCRYhEgUiwCRIpFgEixtCNylqkCkWIRIFIsAkSKRYAYILYjUiwCRIpFgEixCBApFgEixdKKOA6cZapApFgEiBSLAJFiESAGiO2IFIsAkWIRIFIsAkSK5Rjx9w9wuCFSLO2InGWqQKRYBIgUiwCRYhEgBojtiBSLAJFiESBSLAJEikWASLG0I3KqrgKRYhEgUiwCRIpFgBggtiMyJx4iTvtf3t+e1HTwnWPYVjHGONbEGSrd4kygZnGOmbaLM9u6xRmE3eJMzW7xQNwszjsIbnHebnCL05xucZrTLU5zmsU5KNwuHogrxctdLq01b2ZDqzdnUGq915K3FVffi+C4SrM39xOpdxr2g7bSkGp/AsHhg3ZxWtMtTmu6xWlNszgHJtrFmcXd4kzjbnHe33SLB+JmcZrTLU5zusVpTrH4vD84pdo7ERxMaRenOc3iHHlpF6c53eI0p1uc5nSLB+JmcZrTLU5zusVpTrc4zekWpznN4hyfaxenOd3iNKdbnOZ0iwfiZnGa0y1Oc7rFaU63OM2pFc9pf3BOU02c5jSLcwCyXZzmdIvTnG5xmtMtHoibxWlOtzjN6RanOd3iNKdbnOb0iieOsLaL05xucZrTLU5zusUDcbM4zekWpznd4jSnW5zmdIvTnGZxDiG3i9OcbnGa0y1Oc7rFmQ7F4nEXj1ITZzo0i3Nyrlp8HnfxJdfEeeV0i/PK6RYPxM3i7Na6xdmtdYszj7vFmcfd4uzWmsU50douTnO6xWlOtzjN6RYPxM3iNGeD+IZIRh4jlu0ZpnmoXomUoQCR2BMg0m/tiBz4rECksgSIhJMAkRYSIAaI7YgUiwCRYhEgUiwCRIpFgEixtCNOFIsAkWIRIFIsAkSKRYAYILYjUiwCRIpFgEixCBApFgEixdKOOFMsAkSKRYBIsQgQKRYBYoDYjkixCBAplkPEOfKOGGMNkWIRIFIsAkSKpR1xoVgEiBSLAJFiESBSLALEALEdkWIRIFIsAkSKRYBIsbQjFobtI8Sc9r/tu/3nVENk2BYgMmwLEBm2BYgBYjsiw7YAkWFbgMiwLUBk2BYg8vZAOyKnyysQKRYBIsUiQKRYBIgBYjsixSJApFgEiBSLAJFiESBSLM2ImbPJFYgUiwCRYhEgUiwCRIbtNNZcmJ/rLozEdRem3LoLg2vVhfNczScvZs5ztYsH4mZxpjm3OHOiW5wJ1C3ObOsWZ2o2i2f2ht3ibCS7xWlOsfgy7eKlKk5zusUDcbM4zekWpznd4jSnW5zmFIsfnC6aOQndLc5J6HZxmtMtTnO6xWlOt3ggbhanOd3iNKdbnOZ0i9OcbnGa0yzOUe92cZrTLU5zusVpTrd4IG4Wpznd4jSnW5zmdIvTnG5xmtMsPtGcbnGa0y1Oc7rFaU63eCBuFqc53eI0p1uc5nSL05xucZrTLD7TnG5xmtMtTnO6xWlOt3ggbhanOd3iNKdbnHlcKr6W7XjTXz293XthGvd6M4t7vZnEvd7M4V7vwNvqzQzu9WYC93rzno/Xm3d8vN70pdW70Jdeb/rS601fer3pS6934G31pi+93vSl9h2eYUjbg4cUNXEK0y1OY7rFqUyz+EpnusUpTbc4rekWpzbd4oG4WZzidIvTnG5xmlMsnsouPqaaOM3pFqc5veLjQHO6xWlOtzjN6RanOb/fdFgXD8St8/jtmSJuFqc53eI0p1uc5nSL05xm8URzusVpTrc4zekWpznd4oG4WZzmdIvTnG5xmtMtTnO6xWlOs3imOd3iNKdbnOZ0i9OcbvFA3CxOc7rFaU63OM3pFqc53eI0p1l8pDnd4jSnW5zmdIvTnG7xQNwsTnO6xWlOtzjN6RanOd3iNKdZPGhOtzjN6RanOd3iNKdbPBA3i9OcbnGa0y1Oc7rFaU63OM1pFp+Yx6Xi5S6X1po307jWe19xmZaad+Bt9WYS93ozo3i9mVCs3jN74l5vdsS93szfXm/mb6934G31Zv72erMP7vVmF9zrTV96velLq/dCX2q990WUUtv/XuhLrzd96fWmL73egbfVm770etOXXm/60utNX3q96Uurd6Evvd70pdebvvR605de78Db6k1fer3pS683fen1pi+93vSl1XulL73e9KXXm770etOXXu/A2+pNX3q96UuvN33p9aYvvd70pdM7BvrS601fer3pS683fen1Dryt3vSl15u+9HrTl15v+tLrTV9avRN96fWmL73e9I7XO/C2etM7Xm96x+tN71i9c/M8GHn7yOuI+ch7WjbA6d1y0rLu60mdrSd3tp6xs/VEZ+uZrOuZh+1mM+eormfubD1LZ+spna1n7Ws949DZepJ5Pdvr4jzM1fXkztYzdrae6Gw9U2frmTtbz9LZekpn61n7Wk8Mna2ns/tzdHZ/js7uz9HZ/Tk6uz9HZ/fn6Oz+HJ3dn6Oz+/PU2f156uz+PHV2f546uz9Pnd2fp87uz1Nn9+eps/vz1Nn9eers/jx3dn+eO7s/z53dn+fO7s9zZ/fnubP789zZ/Xnu7P48d3Z/nru5P9/+p///x//48Y///Oc//fX2Fb/8H//zp3/5+ce//PT2P/78X//+j//L7bH/DQ=="},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"target","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"function_data","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData","fields":[{"name":"selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_private","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1dB3gV1fK/2ZuQQCChgyIYQURE4J7UGxUFG4qCCApiAVJuEKUJAcWKvfde3lOfvXd99t57r+iz994r/5lkjxmWk4S9dybu+He/b767Odlz9jdzZn6n7NmzWbHGo2dOLDYmu/E8CyTu/3ogRYE0+0vPsx1p7Rx5OzrSChxpnR1pXR1pPUFGBtL6Oa5b3ZFW5Ehbw5E20E+jh+f/jvR/E5kdZiApqyRRXlqaqihOmRJTlSiurE6WJUrLqsuTJmnKkmW1xcmSklSyNFlRWV1Zkag0pSUpU1dWWVLnF/ZOFh8uagcs19qmPbGBrfc/Aue5IO/CHzm+L3ixFY8sZjv24Csr4YCbadnGnlBbvOcb4f1gAOE/3gykvZ+1ojPGBY2YpjMW+85o3svic+z3s2QqlzuYOXX+wFFWdaKmtsxUl9dWmFRVWbKmprLEmOKq8qry6uJkXaq6zCTLklBmTVVxEm5XXFVjUomq8hQGYm6sKejowR2IHzDWFcX7YZYgYCycu9yPGJ1BSu+PiIWZynVi5SAAxMoVsLZczjr6mNnxLfFjuWvEGltTPNqiNZUiXG6c7zLizCE4P/GBfur/fub/fu7zRHf/ui/gjy9BvgL5GuQbkG9BvgP5HuQHkB9BfgL5GeQXkF9BfgP5HeQPkGV+dzvLiy3f4n+e1Xr3M1OnZTSg+ZS5MtqqxeJ0IorX8wQBY+Hc5ca9aLdYqHec0B9TuW3qbJ8JOVu2Jwg4W8DZciLubKh3jnJn+1zI2dp5goDbCThbbsSdDfXOFXA2CazIwDkefx8/z+N1VpypihM/xdbDzlR9Rs4/98/xaO81Xc+pG9ZtnoDNOvDZzATHFdx+8wkjGdn+dz6A7gjSCaQApBCkM0gXkK4g3UC6g/QA6QnSC6Q3yCogq4L0AVkNpC9IP6+xe0274PneirPbHR1pnRxpBY60QkdaZ0daF0daV0daN0dad0daD0daT0daL0dab0faKo60VR1pfRxpqznS+jrS+nkrNpLZgj6ZaSzmM7QxqbrGoyNje3VyXGYsH6yLDHWu7cRnv8oCvrJMIWNdnKKiLlKmM5v9akwXtrKSpitjXZyqoi4SphuX/VIJ052rrBp4WMRYF6dpqItkwvTksh+0Pb2YykpBWb0Z6+J0BXVRAzqvwmS/JJS1KlNZoLLpw1gXZ0S/LlKo82o89qvBsvrylJXEsvox1sWZbVQXicwOw9jfM4z9FUPb20zr4iwldcHYrhlGXjZnMNbF2UJ1wb24hTF+DaP/GSn7eQH7RWF8a8tanXHeCsvgnqvCecAOAvN1RR5vXXPrjc+z8wX0vigebb3RH4sE9L64jbgxU5xrMMYjY12biyPuNxgvqwv4zWUR1ztfKF4uVxIv/RnjhbGuDaf97DM024/Av5En7HOz/l7Tc7MBXtM1nH6Ga6s6CvjZVcLxlSk+1HmAgN5XKxk3DWDsa67JGKuMfmO01MWXjM/IBnoyMRyluHDx5pqENwcS3lxLiDdxPWonAf64LuK8iTqvJaD39UpidS3G+BrEyJuMfmO01MVXjLy5ticTw1GKCxdvDiK8uTbhzcFCvIlr+AsE+OOmiPMm6jxYQO+blcTqYMb4WoeRNxn9xmipi68ZeXOIJxPDUYoLF2+uQ3hzCOHNdYV4E997KhTgj1sjzpuo87oCet+mJFbXZYyvoYy8yeg3RktdfMPIm8M8mRiOUly4eHMo4c1hhDeHC/EmvivaWYA/7ow4b6LOwwX0vktJrA5njK8EI28y+o3RUhffMvKm8WRiOEpx4eLNBOFNQ3izWIg38f36LgL8cW/EeRN1LhbQ+z4lsVrMGF8ljLzJ6DdGS118x8ibpZ5MDEcpLly8WUJ4s5TwZpkQb+KeJF0F+OPBiPMm6lwmoPdDSmK1jDG+yhl5k9FvjJa6+J6RNys8mRiOUly4eLOc8GYF4c2kEG/iPk7dBPjj0YjzJuqcFND7MSWxmmSMr0pG3mT0G6OlLn5g5M31PJkYjlJcuHizkvDmeoQ31xfiTdz7rrsAfzwZcd5EndcX0PspJbG6PmN8bcDIm4x+Y7TUxY+MvDnCk4nhKMWFizc3ILw5gvDmhkK8ifuF9hDgj2cjzpuo84YCej+nJFY3ZIyvjRh5k9FvjJa6+ImRN0d6MjEcpbhw8eZGhDdHEt4cJcSbuMdyTwH+eDHivIk6jxLQ+yUlsTqKMb42ZuRNRr8xWuriZ0be3MSTieEoxYWLNzcmvLkJ4c1NhXgT96XvJcAfr0acN1HnTQX0fk1JrG7KGF+bMfImo98YLXXxCyNvbu7JxHCU4sLFm5sR3tyc8OZoId7Eb3n0FuCPpRHnTdR5tIDebyqJ1dGM8bUFI28y+o3RUhe/MvLmlp5MDEcpLly8uQXhzS0Jb44R4k38/tEqAvzxdsR5E3UeI6D3O0pidQxjfG3FyJuMfmO01MVvjLy5tScTw1GKCxdvbkV4c2vCm2OFeBO/GbeqAH+8H3HeRJ3HCuj9gZJYHcsYX+MYeZPRb4yWuvidkTe38WRiOEpx4eLNcYQ3tyG8OV6IN/E7m30E+OPjiPMm6jxeQO9PlMTqeMb42paRNxn9xmipiz8YeXOCJxPDUYoLF29uS3hzAuHNiUK8id8mXk2APz6POG+izhMF9P5CSaxOZIyv7Rh5k9FvjJa6WMbIm9t7MjEcpbhw8eZ2hDe3J7w5SYg38eZ9Bfjj64jzJuo8SUDvb5TE6iTG+JrMyJuMfmO01EWMsS528GRiOEpx4eLNyYQ3dyC8OUWIN7O85b/7ymWn7yPOm6jzFAG9f1ASq1MY42tHRt5k9BujpS6yGOtiJ08mhqMUFy7e3JHw5k6EN3f2YssdHnPdFcb4bLSzJ+Ov3By3Cx/OYlddoti63MWvy14gU+E8x08PVKtTz0Rmh3k/q23qI5HZYaYy+k07gnOab+Tp/m+V/1vt/9b47efa/vW18HcKpA5kBsiuIDNBdgPZHWQWyGyQOSBzQeaB7AEyH2QBSD3IQpBFIHuC7AWyGGRvkH1A9gXZD2R/kANAloAcCHIQyMEgh4AcCnIYyOEgR4AcCXIUyNGeb/i4/4vgi2LLH9wfLWKsGDOdkdiPYXQYDMhc4tSSjs6Jm+I91hMEfKzHX+5xjM4gpfdxhKKZym1wNi/WNuzPyaqSOKcLBcXxxG/ZuxDHMTIjZXULOoekSTsKZwVQxz7B/+NE1EmiAo4XYKbjmaNGSm9PUO9MMZ4kbMNEZodBxzzJ46+bk5mZzBIAlrvEL5fbFicK2eIUIVucImiL6UK2+Dnic4lS8fDLX6t3TSv4xHz/V6F5u+DwLpHZYRj90jDWteG0H3akcL7T1eOOhbRna/5Ey5Ros7hsQjuVp7bUS05kdpiThBoBCjokZtPafRDzqQKksCwik/lhOm+Z6nyaF02CWRaX8cvTSOck3fppzeac9XM6KcuUlEBs1FaYutq6krKKyuJqU15SXl5XWldRniytrSsrraqtSJnSqpLiylRFos4kU6mKspKaivK6ytqa8jpK2qa2pKS0trK6xpQVl1dVJ5K1JVWJutKKkuJEVW1JRW1tSbK8vKqkpLY8WZesTBYXV9WVJBNlFRWVifLikspiqfo53a+fthxdc07D0EbsDP+PM7UQuBS+MwTI+iyhhusswdEL2uJMAVucLWSLswVtMVWoZ5+VHe2RnFQ8eH+t3q2O5KR8P54t02njHskx+qVhrGvDab+/y0juDKGR3DkaR3LnCI/kzhEghVwhUojySO5fXjQJhrMuqF/+S9lI7t+MIzlK2pmO5KTq599kJNdcoxDlKThJnFINzLkaG5hzhRuYcwUamPZt1MBwPueN0LOi5RqYTHF1aKMRQKY4z2NsoBn9z3QQagDOW4kGOlObnu/xNYTLTY9GqIFuL1Q/5/+Nplr/4/9xgedYyJTI7DDNLejhXKGWaVmMi6KMRMVbG3KTqpQNMy3rwojXBwbMhQIdo4uEOokXeXJT0RcI2eJiIVtcLDwtL2GLThGflpeKh4KIT8tL+X6hkml5Rr80jHVtCv+Zlg8eDW0Wl01oZ/cSyVmTC4UagUsEZ00Q8yUCpNBNybT8hYwdwUu9aBJMN6FR5aWe/LQ8Z/1cxjgtX8g46peqn8v+glH/dKFR/+X+H1doIXApfJcLkPWVQg3XlYKjF7TFFQK2uErIFld5sq/KSPTse0R8JCcVDz0jPpKT8v1eSkZyjH5pGOva9PpnJBc8zOVCI7mrNY7krhYeyV0tQAp9/h+O5K7xokkwfYRGCtcoG8ldyziS68U4kpOqn2u9tl9gxTkFJ4lTqoG5TmMDc51wA3OdQAPTV8kCK04CKxDqwWa8kamSBVbXMzbQjP5n+gk1ANd78gusbvD4GsLlpkcj1ED3FaqfGxz1wz3qncrIP9WMZd3I2Ja15f5/nLgp3ps8QcA3efzl3szoDFJ63+w1GZip3Dbd/69aSW96qlBQ3NJSbzpTp7uZsTdAWd2C/jssm/2v/8etXox//z+sgFsEmOkW5qiR0tsT1DtTjLcJ2zCR2WHQMW8TGFbeLjTEvt2Te5B3q5At7hCyxR2e7PJUCVusEfGHmlLx0D/iDzWlfH+AkoeajH5pGOvaDPjnoWbwaGizuGxCO5V3eoJzzrcJNQJ3Cs45I+Y7BUhhkJKHmrcxdgTv8qJJMIOE5uTu8uQfanLWz90e35zpAMY5U6n6udtr++WpnNMwtBG7x//jXi0ELoXvHgGyvk+o4bpPcPSCtrhXwBb3C9nifkFbVAv17AdHfCQnFQ/rRHwkJ+X7Q5SM5Bj90jDWtRnyz0gueJh7hEZyD2gcyT0gPJJ7QIAUhv8/HMk96EWTYIYLjRQeVDaSe4hxJDeEcSQnVT8PeW2/PJVzCk4Sp1QD87DGBuZh4QbmYYEGxihZnspJYP2FerCZ4ipWsjz1EcYGmtH/TLFQA/CIJ7889VGPryEckB3NBtoI1c+jf6Op1sf8Px73Yvz7/zW3oIdzhVqmZTEuihLZb87akJtUpWyYaVlPRLw+MGCeEOgYPSnUSXzSk5uKflzIFk8J2eIp4Wl5CVuURXxaXioeyiM+LS/l+xVKpuUZ/dIw1rWp+GdaPng0tFlcNqGd3aclZ02eEGoEnhacNUHMTwuQwvpKpuWfYOwIPuNFk2DWFxpVPuPJT8tz1s+zjNPyFYyjfqn6efYvGPVLvb70nP/H81oIXArfcwJk/YJQw/WC4OgFbfG8gC1eFLLFi57sqzISPfsRER/JScXDhhEfyUn5/kZKRnKMfmkY69ps9M9ILniY54RGci9pHMm9JDySe0mAFDb5fziSe9mLJsFsIjRSeFnZSO4VxpHcRowjOan6ecVr+wVWnFNwkjilGphXNTYwrwo3MK8KNDCbKVlgxUlg5UI92Exxba5kgdVrjA00o/+ZzYUagNc8+QVWr3t8DWFFdjQb6M2E6ud10kC31f51NUIN3xueIOA3PP5ylzISs5TeS0mXjancNt0ssVrI2d70BAG/KeBsb0Xc2VDvtwSczYWVY0Uf9qo8Zhtw9tT+58naMJHZ0UB+bwn0yt/2ou07+DXoCwV8h3OX73cibkP0baxn7vl5xpgxbzPWx7sRrw/0l3cFYvk9xvqQ0BufX74noPeW2dHm7ulCeo8RGsVzcy1j/ZgxzM/e2qpjPV2oY/2+Jwj4fYGO9QcR71ij3h94TQZmKrdNna1KyNk+9AQBfyjgbB9F3NlQ74/aaBSXyOxoCNyPBFqxjyM+8sJR18cCen/CHKTtY01zxfg3Etkf/nkVOa8h59X+OR6fek15OfXEkesnAvb7jLG3S0LQaYNEZoeZxljXa/vlfA5lfgHyJchXIF+DfAPyLch3IN+D/ADyI8hPID+D/ALyK8hvIL9j3YMsQ+VhaJgF4oHEQbJBckDageSC5IG0B+kAkg/SEaQTSAFIIUhnkC4gXUG6gXSPN/Yi6dz5574P0LQvHGlfOtK+cqR97Uj7xpH2rSPtO0fa9460HxxpPzrSfnKk/exI+8WR9qsj7TdH2u+OtD8cacscaQ31G0jLcqR5jrS4Iy3bkZbjSGvnSMt1pOU50to70jo40vIdaR0daZ0caQWOtEJHWmdHWhdHWldHWjdHWvd4E8fYI+xCnDCckynXfs5QVqqu8fiCEdfYiK8p8HWu/ZLPfpVf8ZVlvmasi3Eq6iJlvmGzX435lq2spPmOsS62UVEXCfM9l/1SCfMDV1k1CfMjY12M11AXyYT5ict+0Pb8zFRWCsr6hbEutlVQFzWg869M9ktCWb8xlQUqm98Z62JC9OsihTr/wWO/GixrGU9ZSSwLO5NcdTEx+nWBRZusOEdZqYayPJayahrKijPWxXaRr4tkg87ZLPZrgGlyOMpKNZbVjrEuto96XdQ06pzLYb9kY1l5HGU1qmzaM9bFpIjXRa2vcwcGnav9svIZyqrwy+rIWBeTo10XxfaNx06Z62xsWQUZl5Wss2UVMtbFDpGui2S11blz5vb7803WLhmXVfFnWV0Z62JKpOui7E+du2Wss/mzrO5xvjnLsYzvuOwYkRdaWzkM47yZYZz3MeMZ62InJXXBOD9gGMe3ZiJjXeyspC4Yx0GGsR9vJjHWxS5K6oKxv2cY+ytmCmNdTFVSF4ztmmHkZbMzY11MU7JDDWP8Gkb/M1L28wL2i8JzZVtWD8Z+KJbBvQYI11d95vGvg+oZ561rbr1rvaa1P5x6L4j4qn/0x55xfr3rlby734sxHhnr2tRH3G8wXnoI+M2eEdcbOUIiXvZSEi+9GeOFsa4Np/0a1vXFmvoR+DfyhF2P3DvetB55lXjTNZx+lvKa1p1y1t8+Ed9FE3VeRSC+9lUyblqFcZ53VcZYZfQbo6UuUoz9/j5xmRiOUly4eHNVwpt9CG+uJsSbdV7T2nxabqZ2OiDivIk6rybAm0uUxOpqjPHVl5E3Gf3GaKmLOkbe7BeXieEoxYWLN/sS3uxHeHN1Id6c4TW9v0TLzdROB0ecN1Hn1QV48xAlsbo6Y3wVMfImo98YLXUxg5E314jLxHCU4sLFm0WEN9cgvNlfiDd39Zre8aTlZmqnwyPOm6hzfwHePEJJrPZnjK8BjLzJ6DdGS13sysiba8ZlYjhKceHizQGEN9ckvDlQiDdnek3vwdNyM7XT0RHnTdR5oABvHqMkVgcyxtdajLzJ6DdGS13MZOTNQXGZGI5SXLh4cy3Cm4MIb64txJu7eU17hdByM7XT8RHnTdR5bQHePEFJrK7NGF+DGXmT0W+MlrrYjZE314nLxHCU4sLFm4MJb65DeHOIEG/u7jXtp0TLzdROJ0ecN1HnIQK8eYqSWB3CGF/rMvImo98YLXWxOyNvDo3LxHCU4sLFm+sS3hxKeHOYEG/O8pr2nKPlZmqn0yPOm6jzMAHePENJrA5jjK/hjLzJ6DdGS13MYuTNRFwmhqMUFy7eHE54M0F40wjx5myvaV9OWm6mdjo74ryJOhsB3jxHSawaxvgqZuRNRr8xWupiNiNvlsRlYjhKceHizWLCmyWEN0uFeHOO17R3MS03UzudG3HeRJ1LBXjzPCWxWsoYX2WMvMnoN0ZLXcxh5M3yuEwMRykuXLxZRniznPBmhRBvzvWa9nen5WZqpwsizpuoc4UAb16oJFYrGOMrycibjH5jtNTFXEberIzLxHCU4sLFm0nCm5WEN9cT4s15XtM3MGi5mdrpkojzJuq8ngBvXqokVtdjjK/1GXmT0W+MlrqYx8ibG8RlYjhKceHizfUJb25AeHOEEG/u4TV9J4iWm6mdrog4b6LOIwR480olsTqCMb42ZORNRr8xWupiD0be3CguE8NRigsXb25IeHMjwpsjhXhzvtf0LTVabqZ2uibivNnwrRAB3rxWSayOZIyvUYy8yeg3RktdzGfkzY3jMjEcpbhw8eYowpsbE97cRIg3F3hN35uk5WZqpxsizpuo8yYCvHmjkljdhDG+NmXkTUa/MVrqYgEjb24Wl4nhKMWFizc3Jby5GeHNzYV4s95r+iYvLTdTO90Scd5EnTcX4M3/KonVzRnjazQjbzL6jdFSF/WMvLlFXCaGoxQXLt4cTXhzC8KbWwrx5kKv6bvltNxM7XR7xHkTdd5SgDfvUBKrWzLG1xhG3mT0G6OlLhYy8uZWcZkYjlJcuHhzDOHNrQhvbi3Em4vg5ssEePPuiPMm6ry1AG/eoyRWt2aMr7GMvMnoN0ZLXSxi5M1xcZkYjlJcuHhzLOHNcYQ3txHizT3x5gL8cX/EeRN13kZA7weUxOo2jPE1npE3Gf3GaKmLPRl5c9u4TAxHKS5cvDme8Oa2hDcnCPHmXtjXFOCPhyPOm6jzBAG9H1ESqxMY42siI28y+o3RUhd7MfLmdnGZGI5SXLh4cyLhze0Ib24vxJuL4eaeAH88HnHeRJ23F9D7CSWxuj1jfE1i5E1GvzFa6mIxI29OjsvEcJTiwsWbkwhvTia8uYMQb+4NN48L8MfTEedN1HkHAb2fURKrOzDG1xRG3mT0G6OlLvZm5M0d4zIxHKW4cPHmFMKbOxLe3EmIN/eBm2cL8MfzEedN1HknAb1fUBKrOzHG186MvMnoN0ZLXezDyJu7xGViOEpx4eLNnQlv7kJ4c6oQb+4LN88R4I+XI86bqPNUAb1fURKrUxnjaxojbzL6jdFSF/sy8ub0uEwMRykuXLw5jfDmdMKbVUK8uR/cvJ0Af7wecd5EnasE9H5DSaxWMcZXNSNvMvqN0VIX+zHyZk1cJoajFBcu3qwmvFlDeLNWiDf3h5vnCvDHWxHnTdS5VkDv/ymJ1VrG+Eox8iaj3xgtdbE/I2/WxWViOEpx4eLNFOHNOsKbM4R48wC4eZ4Af7wbcd5EnWcI6P2eklidwRhfuzLyJqPfGC11cQAjb86My8RwlOLCxZu7Et6cSXhzNyHeXAI3by/AHx9GnDdR590E9P5ISazuxhhfuzPyJqPfGC11sYSRN2fFZWI4SnHh4s3dCW/OIrw5W4g3D4SbdxDgj08jzpuo82wBvT9TEquzGeNrDiNvMvqN0VIXBzLy5ty4TAxHKS5cvDmH8OZcwpvzhHjzILh5vgB/fBlx3kSd5wno/ZWSWJ3HGF97MPImo98YLXVxECNvzo/LxHCU4sLFm3sQ3pxPeHOBEG8eDDfvKMAf30acN1HnBQJ6f6dlz0fG+Kpn5E1GvzFa6uJgRt5cGJeJ4SjFhYs36wlvLiS8uUiINw+Bm3cS4I8fI86bqPMiAb1/0rIHD2N87cnIm4x+Y7TUxSGMvLlXXCaGoxQXLt7ck/DmXoQ3Fwvx5qFw8wIB/vg14ryJOi8W0Ps3Le9EM8bX3oy8yeg3RktdHMrIm/vEZWI4SnHh4s29CW/uQ3hzXyHePAxuXijAH8sizpuo874CesdydMTqvozxtR8jbzL6jdFSF4cx8ub+cZkYjlJcuHhzP8Kb+xPePECINw+Hm3cW4I94TrR5E3U+QEDvbCWxegBjfC1h5E1GvzFa6uJwRt48MC4Tw1GKCxdvLiG8eSDhzYOEePMIuHkXAf7IjThvos4HCeidpyRWD2KMr4MZeZPRb4yWujiCkTcPicvEcJTiwsWbBxPePITw5qFCvHkk3LyrAH/kR5w3UedDBfTuqCRWD2WMr8MYeZPRb4yWujiSkTcPj8vEcJTiwsWbhxHePJzw5hFCvHkU3LybAH8URpw3UecjBPTurKWPwxhfRzLyJqPfGC11cRQjbx4Vl4nhKMWFizePJLx5FOHNo4V482i4eXcB/ugWcd5EnY8W0Lu7klg9mjG+jmHkTUa/MWrqgpE3j43LxHCU4sLFm8cQ3jyW8OZx8dhyh8dcd11ifDY6Li7LmYnMDlMFxnvP4+fM4+O8vhH3dcdyz4PfHF+8WPMH0/1NFrF7jPgn5z2Oj8vwWrOAM63gE+L8wd+ZYD2eBP8Jys7XBTnR74gE9TpRuV4ntUK+GS82iPEF1VoxmaDi1jmLUedBSnT2GHVeW4nOcUadByvROZtR53WEdOZuzIe0Ud0kMjvMuoz1fFJcR90MjenAOUwJzuFKcCaU4DRKcBYrwVmiBGepEpxlSnCWK8FZoQRnUgnOSiU411OCc30lODdQgnOEEpwbKsG5kRKcI5XgHKUE58ZKcG6iBOemSnBupgTn5kpwjlaCcwslOLdUgnOMEpxbKcG5tRKcY5XgHKcE5zZKcI5XgnNbJTgnKME5UQnO7ZTg3F4JzklKcE5WgnMHJTinKMG5oxKcOynBubMSnLsowTlVCc5pSnBOV4KzSgnOaiU4a5TgrFWCM6UEZ50SnDOU4NxVCc6ZSnDupgTn7kpwzlKCc7YSnHOU4JyrBOc8JTj3UIJzvhKcC5TgrFeCc6ESnIuU4NxTCc69lOBcrATn3kpw7qME575KcO6nBOf+SnAeoATnEiU4D1SC8yAlOA9WgvMQJTgPVYLzMCU4D1eC8wglOI9UgvMoJTiPVoLzGCU4j1WC8zglOI9XgvMEJThPVILzJCU4T1aC8xQlOE9VgvM0JThPV4LzDCU4z1SC8ywlOM9WgvMcJTj/pQTnv5XgPFcJzvOU4DxfCc7/KMF5gRKcFyrBeZESnBcrwXmJEpyXKsF5mRKclyvBeYUSnFcqwXmVEpxXK8F5jRKc1yrBeZ0SnNcrwXmDEpw3KsF5kxKcNyvBeYsSnP9VgvNWJThvU4LzdiU471CC804lOO9SgvNuJTjvUYLzXiU471OC834lOB9QgvNBJTgfUoLzYSU4H1GC81ElOB9TgvNxJTifUILzSSU4n1KC82klOJ9RgvNZJTifU4LzeSU4X1CC80UlOF9SgvNlJThfUYLzVSU4X1OC83UlON9QgnOpEpxvKsH5lhKc/1OC820lON9RgvNdJTjfU4LzfSU4P1CC80MlOD9SgvNjJTg/UYLzUyU4P1OC83MlOL9QgvNLJTi/UoLzayU4v1GC81slOL9TgvN7JTh/UILzRyU4f1KC82clOH9RgvNXJTh/U4LzdyU4/1CCc5kSnFigBpxZSnB6SnDGleDMVoIzRwnOdkpw5irBmacEZ3slODsowZmvBGdHJTg7KcFZoARnoRKcnZXg7KIEZ1clOLspwdldCc4eSnD2VIKzlxKcvZXgXEUJzlWV4OyjBOdqSnD2VYKznxKcqyvBWaQE5xpKcPZXgnOAEpxrKsE5UAnOtZTgHKQE59pKcA5WgnMdJTiHKMG5rhKcQ5XgHKYE53AlOBNKcBolOIuV4CxRgrNUCc4yJTjLleCsUIIzqQRnpRKc6ynBub4SnBsowTlCCc4NleDcSAnOkUpwjlKCc2MlODdRgnNTJTg3U4JzcyU4RyvBuYUSnFsqwTlGCc6tlODcWgnOsUpwjlOCcxslOMcrwbmtEpwTlOCcqATndkpwbq8E5yQlOCcrwbmDEpxTlODcUQnOnZTg3FkJzl2U4JyqBOc0JTinK8FZpQRntRKcNUI4vQDOkkR5aWmqojhlSkxVoriyOlmWKC2rLk+apClLltUWJ0tKUsnSZEVldWVFotKUlqRMXVllSZ1f9kBGnWvbSOdEZodJZfHZ7x0l/linBOcMJTh3VYJzphKcuynBubsSnLOU4JytBOccJTjnKsE5TwnOPZTgnK8E5wIlOOuV4FyoBOciJTj3VIJzLyU4FyvBubcSnPsowbmvEpz7KcG5vxKcByjBuUQJzgOV4DxICc6DleA8RAnOQ5XgPEwJzsOV4DxCCc4jleA8SgnOo5XgPEYJzmOV4DxOCc7jleA8QQnOE5XgPEkJzpOV4DxFCc5TleA8TQnO05XgPEMJzjOV4DxLCc6zleA8RwnOfynB+W8lOM9VgvM8JTjPV4LzP0pwXqAE54VKcF6kBOfFSnBeogTnpUpwXqYE5+VKcF6hBOeVSnBepQTn1UpwXqME57VKcF6nBOf1SnDeoATnjUpw3qQE581KcN6iBOd/leC8VQnO25TgvF0JzjuU4LxTCc67lOC8WwnOe5TgvFcIpxfAmel70DmMOt+nROd2jDrfr0TnXEadH1Cicx6jzg8q0bk9o84PKdG5A6PODyvROZ9R50eU6NyRUedHlejciVHnx5ToXMCo8+NKdC5k1PkJJTp3ZtT5SSU6d2HU+SklOndl1PlpJTp3Y9T5GSU6d2fU+VklOvdg1Pk5JTr3ZNT5eSU692LU+QUlOvdm1PlFJTqvwqjzS0p0XpVR55eV6NyHUedXlOi8GqPOryrRuS+jzq8p0bkfo86vK9F5dUad31CicxGjzkuV6LwGo85vKtG5P6PObynReQCjzv9TovOajDq/zagzPhvP9stai+if5dsg7v8fnyXjs1V81ojP3vBZFD6bwWcVOHePc9k4t4tznTj3h3NhODeEcyU4d4BjaRxb4lgLxx7YF8e+KfbVsO+CbTm2bcj1RSDIBRgb6Ctou4EE2x1ZTXgHgawNMhhkHZAhIOuCDAUZBjIcbQRiQIqxHkFKQcpAykEqQJIglSDrgawPsgHICJANQTby620UyMYgm4BsCrIZyOYgo0G2ANkSZAzIViBbg4wFGQeyDch4kG1BJoBMBNkOZHuQSSCTQXYAmQKyI8hOIDuD7AIyFWQayHSQKpBqkBqQWpAUSB3IDJBdQWaC7AayO8gskNkgc0DmgswD2QNkPsgCkHqQhSCLQPYE2QtkMcjeIPuA7AuyH8j+IAeALAE5EOQgkINBDgE5FOQwkMNBjgA5EuQokKNBjgE5FuQ4kONBTgA5EeQkkJNBTgE5FeQ0kNNBzgA5E+QskLNBzgH5F8i/Qc4FOQ/kfJD/gFwAciHIRSAXg1wCcinIZSCXg1wBciXIVSBXg1wDci3IdSDXg9wAciPITSA3g9wC8l+QW0FuA7kd5A6QO0HuArkb5B6Qe0HuA7kf5AGQB0EeAnkY5BGQR0EeA3kc5AmQJ0GeAnka5BmQZ0GeA3ke5AWQF0FeAnkZ5BWQV0FeA3kd5A2QpSBvgrwF8j+Qt0HeAXkX5D2Q90E+APkQ5COQj0E+AfkU5DOQz0G+APkS5CuQr0G+AfkW5DuQ70F+APkR5CeQn0F+AfkV5DeQ30H+AFkGgmSQBeKBxEGyQXJA2oHkguSBtAfpAJIP0hGkE0gBSCFIZ5AuIF1BuoF0B+kB0hOkF0hvkFVAVgXpA7IaSF+QfiCrgxSBrAHSH2QAyJogA0HWAhkEsjbIYJB1QIaArAsyFGQYyHAQJDkDUgxSAlIKUgZSDoLfvMfvyeO32vE76PiNcfx+N34bG7873fBNZxD8FjF+5xe/oYvfp8Vvv+J3VfGbpfg9UPzWJn7HEr8Rid9fxG8b4ncD8Zt8+L07/JYcfqcNv4GG3xfDb3fhd7Hwm1P4PSf8VhJ+hwi/8YPfz8Fv0+B3X/CbKtNB8Fsg+J0N/IYFftMBv5eA3w/Avflx33vcUx73a8e90HGfcdzDG/fHxr2ncV9n3DMZ9yPGvX5xH13coxb3f8W9VXHfUtwTFPfbxL0scZ9I3IMR9zfEvQOXgOCed7ifHO7Vhvug4R5juH8X7o2F+07hnk64XxLuRYT7/OAeOrg/De79gvuq4J4luB8I7rWB+1jgHhG4/wLubYD7BuA7+fi+O75Lju9p4zvQ+H4xvruL78XiO6f4Pie+K4nvIeI7fvj+HL6bhu994TtV+L4SvguE79ngOyz4fgi+e4HvNeA7A7geH9e64zpyXKON659xbTGu28U1sbjeFNdyYvuCaxBxfR+uncN1abjmC9dA4ZogXCODa0ZwDQWuKcBn7PjMGZ/B4jNJfEaHz6zwGQ4+08A5fpzzxjlgnBPFOUKcM8M5JJxTwTkGHHPjGBTHZDhGwT479mGxT4d9HGzzkWfsUUjOV/N/q+rrU7Pn1RfVzy2qqq0t2nNm/a5Fcxel5tfNmos039DG2mOw/ztu4axZM+tmpuYX1c5NLSiaM7e+aHZVfc2uRYuqZi1MFc2cg8XMSS3AdqOBRO3R3/8dP3/uoplzZhTN+bOgmXNqZi1cMHPunKK6qpmzUthaNdCoPfr4vzVVs2Y1YF2wIDW/ftrsqr2mVc+sn7Zg5t7YuDUwbsgsj4XP8kT4LE+Hz/Js+Cyvhc/yRvgs74TP8l74LB+Fz/JJ+Czfhs/yffgsP4XP8kv4LNjMhsySEz5LfvgsncJn6RU+yyrhs/QPn2XN8FkGhc8yOHyW4vBZSsNnWS98lg3CZxkZPsvG4bNsFT7L2PBZxofPMiF8lp3CZ9klfJaa8FlS4bPsQbLY6YXxC6tnzawpqq2qrypaMAs6HNjzmDPIdjxIf2N+RrkXZJT7cK8p90Cb2+/rzGssxXaRVuzuHOmFslQWuWzrppwNkyR4jJo/v2ox3Kg2tVfR3IX1RXPriqrnLpxTu4BmnJBuxinpZpyebsbzScaV6bzSvBele9Mr0s34aAZoX8sg75vpAn4vbMYb/YsGpptx3XQzlqSbcb10M26absZDSMaVrUqb94h0b3pcuhmvTAPtbf5140jeNVbMu2Bhdf38qpr65guYSAro5v9u6cZrs0wKq6jNuHP4e01L9157xMIb9Q7/uhErj9NmGRkWp804NgOc24bHuV26OGvTwPmQf914kjeUk9oCtl95RW2WHcIqajNODX+vqnTvtSAW3qhP+teFcFKbZWRYnDZjOk5q84ZwUpsltJPajOk46Uv+dWk7qS0ghJPaLKGd1GYM4aQ2S2gntRnTcdKlmRp1aXijLk3XqEvDG3VpukZdmoFR3/evCxH5NsvIsDhtxnQi3+YNEfk2S+jItxnTifwv/evSdlJbQAgntVlCO6nNGMJJbZbQTmozpuOkP/jXhXBSm2VkWJw2YzpOavOGcFKbJbST2ozpOOky/7q0ndQWEMJJbZbQTmozhnBSmyW0k9qM6Thpu6wMjWoLCGFUmyW0UW3GEEa1WUIb1WZMx6hd/bxpD0ltASGGpDZL6CGpzRhiSGqzhB6S2ozpDEm7+3lD0KnNMjIsTpsxHTq1eUPQqc0Smk5txnTotF+mkd8vfOT3Szfy+4WP/H7pRn6/DCJ/YHgnHZiukw7MwEkHhnfSgek66cAMnHRYpk46LLyTDkvXSYeFd9Jh6TrpsAyctCxTo5aFN2pZukYtC2/UsnSNWpaBUUeEj/wR6Ub+iAwif0T4yB+RbuSPyCDyR2fqpKPDO+nodJ10dHgnHZ2uk47OwEnHhXfScek66bgMnHRceCcdl66TjsvASSdn6qSTwzvp5HSddHJ4J52crpNOzsBJp2Zq1KnhjTo1XaNODW/UqekadWq6Rs3zL7KL7fJIAZiEr8qM9P9OZHIkTVU7cgOynqTpb3vzvOXvn0+v9/+HaXGL00/LJdZqyBO4V0MePy1O0rL9tGySluOn5ZDb5onYJVFuXz9iLzthSvN8ffjLThgsu6NM2Q2vcXWKNdVBNrlXe1InBeT+WYy60fvbsu29bHo2Oe9NrrXX2Wva+ecdSf4O/nlBC/nyAvkKyDUdSL6OgXz2b1vvOSQfvsZm48JiFvS/ZH6sKYZi5B6xAGZ70LptJ4IpYdB29tWBGan6P98YGJuaXZ2av2DXmfMmNy6byyIArBK9A0pkxVZUyF5DSY6exx1pVskYMUBcyABZxLix2PJOGif392TuX0zJm+ofC2AK2g4xdZDBVLJcI7MSmDoQTDLB00iwQvomaMMQi/ESd5CQvIDNCmIrkpRgY9Lg7x0CmOzf9J7/4G473IgpyIP55Lp4hHDaNNo4ScVlfqyJZ+w9sO0ZQe6dK3PvkixSF7bTZbHkEhvZa54l147yzzuR/9NOdl4gTZI3s2LLD2RoZ6o9wZlLsNhfyTY3N4Ap12ETkUFGopHvpTp5NI5ymrE3jS0779M5tuLhikk6CMOjE7FZG7TDDXGRvxL62WsmtqJffkA/2r+x+lm98uX1kxzIlbgGclaPjsQG9podW7Fdp2ZsR+M6n5xb2wnpVxwchHLbrjBgO9ouWRvYa6pasV1hM7ajA1NrM3utR67rFNAT03PJdTFybq8NtlXS4wrKsfYesYDeFGcstuJEAucETNhxRQHBVCiCqTHe6WQDU7kNbUxnITti2V0E7dFVpuyG8ZCd9bUxbO/VmdR1d3J/7omsboGy7b1sejY5X0yutdfZa6wfW/wF5BoaP10D+ezfXYgd9iD5ghyST2xD+2hS9Z8VW54zs8nfXQhOm1ZIcGYTfFa3JSRNamKXjvuCfXXaJ7HXnEGuPcQ/70T+n0t0ygukSU7GtdRXb0dw0rGX/RUaBzVgah/A1L4FO9FxTnCCFtOov9jfzkQ3m2Z9jY7Vbey0J2nB/iKdTysgadYf6P1tX7ozSbN27kLSrJ70/mH8RaiNb9FfaD/F5S9CmEpdmLIDmOgEf7vANXkkn73mP/6vqy8n1zdoHMvZewbHOoUEp73m4hZwunjVNZYrCJQhqF9DXXUJ6Jft0M9ec2UAGz3k2qTG/o5U/4+20Vb/9g4b2GuuI/a6wT+ncU/bofsc/48RPehB+71diE27C+mNZfeQKbuhn9eT2CGb3Ivq1ovcn7uf1zNQtr1XT2Jve34vudZeZ6+x9WnxY4za/mGvFvLlBfIVkGtoH7RHIJ/929Y72u8Wcm59Sm58sXw/OahPNtGnGzm3mCTnp4P9EIuF3rO5doX2A+01dksxF5/RvjjtW9i8bdUXDz4Ipw+vLc5gm5Hv0Jv2xbXPS7clpqAd6ZxsS30Xe83r/m9zbabMgpTGvktwTET92OK017zVAk5als3n6rsEnxflxVacJxvJol/jfGBBQL9sgsXitNe834J+kvOWgjYwdB7T6p/rsIG95hNir8/8c7vHMx70edevjv/HiB70oH0X2hb83eaoqG5RmaP6hVzb2hwV+oT1/+4t5OsYyEfntmifY2Xmtr4i59an5HjPPX9Fn61Yfew1dF2AbffonIPrGbzkXEtzz+BzCc7g87Dm5t7sc/IbA/9jx54srmuLBa2rEn05F7Q2zPv4ae0IFJF+RjJRIbdmojgp2QcXbMsSrvbc3os+16bzANy8G1xAa+9Fny/a81XItcFnicE2mD6HLWwhX/tAvoLYivOlrue+9m/a37P56CLXoX6aXB+6uDaqi1ztOtQZqfrGfSI3raqv2m5+KtXC+tahAfxZsRV1sdf8s77VfUj6Gm0vLWcE10DQNtRuFBp2rQ2dS2/DtTZGrp/UaLvg+JA+V7E2sNcMbcV2zY0PKae5xodC/cBiubaq0XbBtiq4zoa2FaWt2K6gGdvRMoNrXSTH1nLz7Y22Cz5TCa6zoc9U1m/Fds09U6Ftb3B+zIut2LZbPb3Yis+2bZ5gOTaP4PMJwbUejXVhx2y2Lmi/wdrUXrNZQH96uMaDOQE70vGnvVZwnqA4P4DJ3iMWwBkL6Cz33KU4SZ9trwym7gRTNxFMje0MnQNgKjch94ypcZzTU9AevWTKbhjn2L6ojTl7rx6krun4gnuc0ztQtr2XTc8m5zuSa+119hrrxxZ/AbmGxk/w2VjwWRzaYQIpIziPlE9sQ3lDqv5bei7Xk+C0ad0IThu7dC61imAWaleTYZ/l70OuTfnnncj/uxKdOgXSpOfvmhvf0v4QbVMsJqE54eXm2S2mQoed7HncYTs6Z2f1oPOMtp9Mn+EFn69imo0rV2zQuQLPgc/iovak82L2N9h3p+uiqK/beY7uJC343NuuldLsV0KYylyYgvVBn3sHnzfSsYa95lD/t7nnXDLv1DT2Ja0/BPv19LmovebIFnDSsmw+V78+uA5RUL8Gfm3ufTCqn73m+Bb0k5tvaewXydhg+WdTVv9Chw3sNacQe53mn9O4p+3VRY7/x4ge9KD9Y7r+U2g9kxHsayRo/8j6VU+HbsE+G5du9P62bHuvXsTe9vxCcq29zl5j69Pix3q0bUPvFvJ1CuQrINfQfmTPQD77t613tN9Z5Nz6lPQzu+7N6EOfN9pr6Hy35LqhYH/FYqH3bK5dof1Fe81V/m9za6XoM2Y8aJ+Gtu+Sa6GbW6fuEZyutetBvWmfvZ5gj0lgTyZKWnp2Gub5KNUp+HyUPgfKIsXlSOiUKE7IxVxj2VJtHO3rxmLL28setP2xOqLv9CD2xky2nCJi77/bBkS07xWVDYhWJdeuzAZElhPstViHwX0ObP9vZcrMZHMi2p/6K98bEeyjSj4TTEjGGF0PFCP3iAVsaQ/6HgFyQ5xksuUUEXsLrUE0gs8nEq7nOYUB/YN9HW5u6Bwo296rM6kTez6cXEvn4elzYjoHYGPUXuvFVlxvQbmhtTILyDWU05qbX6LPGdf0z6XXC+QHsNi/6XoBqTWtYffD6tQMJkYfS9C1gfR+UvGa7ppburdRG+Bcbn8e6qcjxO9d7OyTBLHQPsFm5NpRxEau9yBcezEFr7PzmkEu+KvWqLnWHYwhOs8m+IT2d6gL9tMolmySbjEHx52ufTy28X9b28cjOOdI309oi7YnO4CHPj+312zXii7NrYvIdZQ1eSXLsvno++P2tzBQRksYaF+Qvi9J87jWDOwSuEcQZ9dm7tfeUdb0lSzL5rNtL9U5uP6A+qydvw3aJfjsnduHugbK7hbATW0ww/9Fe80i+Sj/unSgbRhdQyQ1ZqNtUYEDc9twkvu5T5BvWuIk13s08wO2pUe+Iy9tE2cQnWMSOgfmk7Ic+ILzScG5oyzH2novsLa+i+O6vNjyPM89rmsnWLbU/HDY9dBWR9d8ki2niNhbaO9FwbWny++LGlw/Sd+/EOrPG3p/W3awH0fnZ+h8UpBLXGs16TuReGAdBvfgoGPG1sosiK3YLrY0TqNrottqPqm5/RwpN0itkw67r1h7B6YYH56G8aLnuJdUrIbdX4K+85bnwBmV+bN8B6ZYjLeP4tpbUmoenY4tKf8NFbe9SdDnY5Zz4wHd6TOzJLnW+Of0fXz6TgSNcVuePaf9inaBvK3t32Svt2Pt4PM8yoFBnejajLZoR7IDeGi/0V6zof/b2jsUQV3aOcoatZJl2Xy2TaHzWMF1aF5sxWcSwWtp/Ba0ko9iCD5joRxJ56zoPIr9Fdo3brl3DmOx5W3uamfbBa6h8xX2mnH+b2v73do6bml+pCWfstdMaOV+hc3cr52jrO1Xsiybz/oUfRYXfM+RvjexMj7VWj5aXx0DeWh7RjEFn8XROTo8Rvq/iUwOk0hQTBQ/xed6B0py7BvkgaDvtuTflNvsNSn/t7mxb0vt275E55iEzn/hWgqrq/0NzhfTeFlErqM+KTO+NYLrJUxCul8fZg9jq6Nr7GzLoXN6f7f35GmbGZX35PuSa1fmPfng81Ksw2A7QcfOrZWZyTv0UVm3Jnf/xvjtIFi2VIzR9yhi5B6xgC3tQf0quBbDliO/52YjNwjt25eg6w8sNwT3uQm+J8PNDcFnbcF3ubLJeTG5NvjsJlgn9FmrvZb2sSjfeitZJl23Sjmtuf2vaV96kH8uvRajuTVjdC2G5DqEMGsx2uC5UqK551hS8Rr2fQTaFtI2SBhngj5noH46UvzextknCWKhfYLR5NpN/fPm1mJY23okz2KSJxj/QX7l5rdgv4pyidXTXrM1wTyX4BPygbpg34xioeu8LWY73nPVlb1mW/93ZdcsBOcX2qq9Ca5FoGsU7DWTWtGlSzO65DnKmrKSZdl8dP82POhahC4rgYH2/+g7WDQP1dleM60VnN2auV8HR1nVK1mWzUefX+FB3wOl6ylo7HixFe1C9yeQ8KHm9lsscNhgpv+L9ppD8tE4c+lA2y36TE5qnEbbn0IH5jbiJOcexkG+aYmTaB3Ya+w7Oc3NQQXzBttB2l/jtDltr+Lk3osJtuDziebWFga5x+JlnCsr5tyzUawfnGwcM8msK2ksO0eobPrMy7W+lLaRUvphu0PXsHuBB8UdYk08Pa+qZvcJqfqF8+csoF1cOi1JD89x7sVWdHF6nVXPc5TXntyrXTP3CaZlB8oOnnux5ZvO4P9dafmO+3RxpOU6sAZ1olM3eIz0fxMZHlgGpZggNtfjw7wAvpE8WAwpsuGeQRt0cdjn/wDoCk6N3y0EAA==","debug_symbols":"7Z3djiy5ca3fZa4FgQwGf0KvcmAcyLZ8IEAYGdb4AIYw7+4K9s7sntnZ1TNVGawVSV4ZY2Xu9THZZEQxM2L984d//8u//vf/+79//fE//v6PH/70f/75w9/+/m9//umvf//x9l///CFy///94z///KP+5z9++vN//fTDn8IffvjLj/9++78//+GH//jr3/7yw59y/vkP312WGm1XppbLfnGVn//lDz/EbPdPlyf+6Rgrf7syUpL94hjl6GreQWJO5YurqTT5djW18OHfLu3gaskhf7tacuEvry4bSAjvF1PtT6Q+80So7U8kJfpijFm2i0vK+7XlDaNhYAgEBgUMjIiBQRgYCQODMTAyBkbBwBi4i5a4YXD9NUbDwBi3i9a0xbbawq8w0rhdVMJ2sXy49obx/aUlhf3Bvf8ZEZcjiNzqBlFC+cXVOsB49QHS1QeY3A+wxLgPMOXvBshXH2C++gCL/wHy/kuslPDdAOvVB9iuPkC5QJgo7wOMvx4gY2Yysu0bNaUvBkhVwn6+kT7MYM/UGDOROW984/KYGNq+m0fO90eYU/t27cdTpMTHUWL7Z1v78DD68NK1h8fXHl6+9vDKtYdXrz28du3hyaWHl8O1hxevPbxrZy352llL5msP79pZS7521pKvnbXka2ct+dpZS7l21lKunbWUa2ct5dpZS+FrD+/aWUu5dtZSrp21lGtnLeXaWUu9dtZSr5211GtnLRU0a6m0fUddU/04PGVmh8yg+UXb34W3Fu//Gd1/k1pBM4zzBgiaY5w3QNAs47wBguYZpw2wgWYa5w0QNNc4b4Cg2cZ5AwTNN84bIF99gFfPZNrVM5l29UymXT2TaVfPZOTqmYxcPZORq2cycvVMRvjqA7x6JiNXz2Tk6pmMXD2TkatnMjFcPZWJ4eq5TAxXT2ZiuHo2EwNffoRXz2diuHpCE8PVM5qb6uVHePmcJl4+p4mXz2ni5XOaePmc5qlejz5GePmcJl4+p4mXz2ni5XOaePmchi6f09Dlcxq6fE5Dl89pBrZRfdUIL5/T0OVzGrp8TkOXz2no8jlNunxOky6f06TL5zTp8jnNwGa7rxrh5XOadPmcJl0+p0mXz2nS5XMavnxOw5fPaVDb7p44wsvnNKjNd08c4eVzGtQWvCeO8PI5DWoj3hNHePmcBrUd74kjvHxOg9qU98QRXj6nQW3Ne+IIL5/ToDboPXGEl89pUNv0njjCy+c0qM16Txzh5XMa1Ja9J47w8jkNauPeE0d4+ZwGtX3viSO8fE6D2sT3xBFePqdBbeV74ggvn9OgNvQ9cYSXz2lQOwCfOMLL5zSXbxgch3YMpvrJCDvJYe4RE+/exqml+zyU9i7ilOkd/nbnwdU18/4Q39lrPLhUctjaZsvHVua3hOnw6h05BP7uicsc4zxu9Gs4Tilhx2n8caAdJ2Lh0GCc2/u7nSdnuf93EIn2hU3pfaneJvUIJHPbQepH//GDixPLtguk21/b+8Xp6GIKtF1MoX28uD/EtB7i8w+R10N8/iHm9RCff4hlPcTf8BDTHqNvOVf87iHW9RCff4htPcTf8hBT2R9ijvcvplb359E+PLzji1PcL070/UYha3peOz1128eJQ7h/cc3b+Krwx+HpTEpYM3mRmYxrJi8yk+un6WtnkuN+YsepPTOT6/fxVWaS10y+dCbfHwflD8aJ3xJSWT//oadnHSxAT886soCennUY8trpKSltF5dK9y++HaLuj6O1/N1crpOTq8wlhXV24mcub7O1/8uB5PGfAhTWQcuU075OZaac9nWE42naU96nvaRnpp3XtM847esc6fRpl7D9yyTxi634/ntnCusc6cXTc9I7LgrryOkqM7lOp147k2e946KwzqYuMpNxnUy9dibvHuhTXCdI0NOzTnqgp2edyEBPD6/peen0nPiGK67jkOvM5To78TOX572/iOugZcppX6cyU077OsLxNO1nvbaidd4z5bSvc6Tzp73tdckhtqcyblrnSNDTs86RXjo952U9tI6crjKT68DpKjO5jpuuMpPrBOnFM3na74V1KHSVmVznPL9lJnmHThy/uPjE/kiU1nnMi6fnrK8b0zpiucpMrtOYq8zkOrh57Uye9p1q4jWTF5nJdXDz2pm8/1FeWqcx0NOzjligp2edm0BPzzoMee30nPiVKq+Tk+vM5To78TOX570v4nXQMuW0r1OZKaed17Q7mvazXkDyOu+ZctrXOdLp035ifyRe50gvnp6z3nHxOnK6ykyu06nXzuRp77jyOpu6ykyuk6nXzuT9A/28TpCgp2ed9EBPD6/pQZ6edXLy2uk58Q1XXsch15nLdXbiZy7Pe3+R10HLlNO+TmVmnPayjnA8TftZr63KOu+ZctrXOdL5035eA56y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"},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"target","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"function_data","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_data::FunctionData","fields":[{"name":"selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_private","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VY3W7aMBhNGLS0QIDyUwq94BGSrvu7oxe73aTtAVAKyYREmynAxCZtD7BJe+bVwR898ZzWCFtpLSE7jn3O8fGXL8G2tSmFu5/N2yXoEwuNGfHa3a94GrFckzptjTpt0FkgsUXsEBaB7QKMwfs/oX3G66s49r8PZ7fTYD2MVsthFA6vo9XtdIETf0N7wOuJP58Pl9HQXyyCeDm+8dfj69lyvJj9CLakf3ldFkQWdTn11n15AARiNCYRy+9ta/6r4Hh+j/W9sNLjD+9vb+YIXE3oo3Uf3/0avO1/u/n4dRJNg6vpNA4WKV+LVnpeVlHFK+2A1xPxPqzm81k4C+L369limcI9kOCyNgYarge1yDIEK2UrvX42bsSv3f1K8iSWQFMB1lAE/iPg1xaTrhuyODkU1ivuCXp1BJrKZjR5BtfrMuxjI3t5GdCzir4dCr45MOYYvKwY8tIGbtJE15UMfn2evA4ZXlXBk6pEUzUHT6oZ/Po8eXPJ8GoKntQkmmo5eFLL4NfnyUXyFeEoeOJINDk5eOJk8Gt8dt4xvLqCJ3WJpnoOntQz+DV6kuTYhoInDYmmRg6eIOcuup1nqrv6THU/Fb9Ffo3PTsLfVPCkKdHUzMGTZga/Rk8mDO9EwZMTiaaTHDxBzl10O09Et8iv8bvKZ3gtBU9aEk2tHDxpZfBrjO9XDK+t4ElboqmdgyftDH6NniTf3x0FTzoSTZ0cPOlAH50VxMY1eW5F0EQclqDTEnRWoI3nBV3AKGnT6bq4V13gOzXiy2avxPih61Pz/CHDPjO0NobdN4Od/MejM9kSx+5LfDsHfo0n1R7yEzZxDWAvqR3BWBpHYyhfkH72f5TOKc8fmNcR5jkwpgfz+sI8uqZ9Z/4FvG0y1lRinX0nyr5jD2DeSI+ei7J1nwM14iZx3zPjocfyYddKl4fyaA88NPW+YWeP9F7bnqt/Xkax/yX4FPhTG3i7gmas7Yx14Vk6xoHKWbuh3OYazG2eLLfROogTc8svXjf+t8BCLJpHe0CYmG8G4CnFS89Ke4p4oz3XHPKCfu6CGz5S8B2wh15P7BC9ojZyPXZfNrYPc7qScXjN3hvit0oR7v/htSwuMI/0oK8g4LFc/A+PR1T2Ch8AAA==","debug_symbols":"7dvdaiJBEIbhe5ljWfqnqqs7t7Isi0nMIoiGaBYWyb2vbpwxMoMehDczs3oUJinLrwse6EDNtnqc3b/++jlfPq3W1d33bbVYPUw389Vy97St3Lf875fr5+ly/7zeTF821Z2bVLPl4+7n26R6mi9m1Z3q26RVVlQPhcWsKfW+dNRKDOlQLDFqU73/YKs4iZZDcRI7Kf4x2YUunwjtXQyHSu9UvjK2d58ZdvHH2Hohtg9O6uqQ3PnYloodis3EtWN7JvZ780A2j2RzIZsr2TyRzY1snsnmBWweHNmcFBpIoYEUGkihgRQaSKGBFBpIoYEUGkmhkRQaSaGRFBpJoZEUGkmhkRQaSaGRFCqkUCGFCilUSKFCChVSqJBChRQqpFAhhSopVEmhSgpVUqiSQpUUqqRQJYUqKVRJoYkUmkihiRSaSKGJFJpIoYkUmkihiRSaSKFGCjVSqJFCjRRqpFAjhRop1EihRgo1UmgmhWZSaCaFZlJoJoVmUmgmhWZSaCaFZlJoIYUWUmghhRZSaCGFFlJoIYUWUmghhRZSqHcO7Y7uLDh0acGhWwtO0O7o3oJDFxccurng0NUFh1r1qFV2v4hdMGI3jLpXjLxY8zl1dv47vPmm2D5+Scwd1aq5XgXTFEJT3bk3phKbYknxfHE2rRfpcnb+Y/HhrHpFZ01XdFa7orPmKzpruZ6zdi/v/adn9V9+VgvHs16Ib7lOb+XYOGiTPow6fRx1ehl1eh11+jTq9Dbq9HnQ6VNs0qeT9B3/kMT6/ZWSyoVa09z0Pb5FE6QeSrkNpTWU6G5DaQ9l2BeOnoYy7HtMT0MZ9vWop6HIbSjtoQz7MtfTUIZ9R+xpKMO+evY0lNuN9mQou4ff05f59H4x2782v//b6/Khfot+97j58/z+l13tXw=="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2c20/bMBjFk9JyS5q2tGUt1wCDvaaUy/YGD3tl0vYyaU+FphMao1MLE/vvh9N8cGo5lSNsEktEQnUS+zs/H1/qmKi2NTkKj392nC7BNf6gPGfxZ/Cyo6MwVqCT01bIaQNngWCLeIGrBKaxofB+CCft+PN8NOr9869v++GDP7y/84cD/3J4f9sfP5X8FScWOaWiqup+DLrzIMB3qag28b2nz/jPwfzxPXZtzprOv/B8e1KG06rBNar38uNfNU73/v7+8udq2A/P+/1ROB6jq0VrulzSIRuvlCJei493cX9zcz24DkefH67Hd1Nx5wVxWbpgTXteFLCIhjk7Fq3p+rN8Z/F58LIjGk4lYCpAHYqgvwT6yvpkEAxYP1ng6su3CXq1BEyLepg6GusbsNjLWtryKKSxir4tcL55kGcZvHQ0eWmDNjHRuZOgr86TkwGL50p44gqY3Aw8cRP01XlyesTilSU8KQuYyhl4Uk7QV+fJYbQU8CQ88QRMXgaeeAn6CsfOJxavIuFJRcBUycCTSoK+Qk+iObYq4UlVwFTNwBPUTMPtGcrtGsqdF795fYVjJ9KvSXhSEzDVMvCklqCv0JMrFm9FwpMVAdNKBp6gZhpuLyfcvL7CdVWPxatLeFIXMNUz8KSeoK+wfx+zeA0JTxoCpkYGnjQS9BV6Eq2/mxKeNAVMzQw8acI12isYaWfqBA7HRBoWx2lxnA6kcb9gFWKUlHEGAbbVKui90+LLpK34/kPn7/TrD1jstqa6sdhremJHz3jrcaxSHHtN4NsG6Cvcbu6gPsUmrXVoS0oPIS/lozw0XxA/ex6lfcqNGeWaXDkP8rSg3BpXjs6p3Zl/YZzW2ddk+jpbJ4rWsbjHq7odcY+Unc+BL6SvZw+xG82Lq9b0Ibtnquv7Q/eeKfYvhXumJyxei/NtlfPNgzw4T7Q0eTnru7iVoK9wHRut2doSnrQFTLq+F2Z5gpppuCs54eb1Fa41u6K5XOTJmoBJ0/fwTE9QMw23ayi3Zyi3Yyh3xVDuck64eX2Fc9Upro9nebIuYFrPwBPUTMNdN5TbzQk3r6+uDx4PRM9MIk82BEwbGXgy61lvFrdrKLeTE25eX+E8eMnibUp4silg2szAE9RMw103lLtiKHfZUO62odxVQ7nf+vfrcjuGcpvaT2o54eb1Fe7hRe9ubUl4siVg2srAE9RMw13OCTevr3A9eMjibUt4si1g2s7AE9RMw103lLtsKHfbUO6qody1N+5X5TZ1PmkYyp2XeZDXV7iuiv6f5kt44guY/Aw8QU0/BbdrKHfVUG5T/fYM5W4bym1q/669cb8q92ZOuNk1elfuh62bqdtJ+86wH386kF4C73Yghup3hklvB/R2tfgyaSuf84DOd7Xrd6N3+N5rqhuLva8ndvTO8EEci94Z3hf49gH0bcXtdsDFJq0DaEtKf7ef81I+ykPzBfGz9fpenEZ+vpzPlfMgzx6U2+fK0Tm1O/PvAuYAXX1Npq/jO8Md65lpDsqdKeGZ9E9d45rNW/PW9DFrvsM+u6OJif2uAD3DPv1mxre74aj3M/wa9vo26PK/l4GfdkK9CnBtTpAuWOKD1XlPT521zm84tmgOonqQJo63QWxUVeCBaJxSG1BMNi9QP6G8rJ9Rf9mFa+Q13WNj6j9N8uWZy0gAAA==","debug_symbols":"5ZzdaltHFEbfRdemzHx79vz4VUopTuIUg5FD7BSKybtXbiQ5xSJhEb6A4itz7NnDHC/WzWI4j5t3128+/fXnzfb93f3m8vfHze3d26uHm7vt7ulxU36b//3y/sPV9un5/uHq48Pmslxsrrfvdj8/X2ze39xeby4zP1+8WLYy9wvXGMelta4Ta1uo7xe3iDyufhp8sbi3XPvFvY3/Lf7jYnfo9QOHriW0X1lLtp957Fp+5J+96vOx8zvHrirtsFq9fPvYo6+xXzxGKy+PXT3H/rK5nJuHc/Pm3Dydm3fn5sO5+XRuvoybqzg3dxoqp6FyGiqnoXIaKqehchoqp6FyGhpOQ8NpaDgNDaeh4TQ0nIaG09BwGhpOQ8NpaHMa2pyGNqehzWlocxranIY2p6HNaWhzGtqchqbT0HQamk5D02loOg1Np6HpNDSdhqbT0HQa2p2Gdqeh3WlodxranYZ2p6HdaWh3GtqdhnanocNp6HAaOpyGDqehw2nocBo6nIYOp6HDaehwGjqdhk6nodNp6HQaOp2GTqeh02nodBo6nYZOp6HLaehyGrqchi6noctp6HIaupyGLqehy2nochpaS7Hubr2zUKyXFor11kJp1t2t9xaK9eJCsd5cKNarC8XqarW66r1f5L1g5L1hBK4Y7QeSDnQ6MOjApAMLDoCrNfuBSgdEB4IOUNKipEVJi5IWJS1KOijpoKSDkg5KOijpoKSDkg5KOijpoKQbJd0o6UZJN0q6UdKNkm6UdKOkGyXdKOmkpJOSTko6KemkpJOSTko6KemkpJOS7pR0p6Q7Jd0p6U5Jd0q6U9Kdku6UdKekByU9KOlBSQ9KelDSg5IelPSgpAclPSjpSUlPSnpS0pOSnpT0pKQnJT0p6UlJT0p6UdKLkl6U9KKkFyW9KOlFSS9KelHSC5JWKXSg0gHRgaADjQ4kHeh0YNCBSQco6UpJV0q6UtKVkqaNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRxupHlmnM/00uZX4+d+ERlLYevTtaa9bi4Rj2xOnMeVmeXjqtPftAyWxwXtx7fXjxHHr7wOWepXy/ev+t8Re+6Xs+7no6qv+i71lf0rnpF7xo//V2Hnt/1O8evtT9vPfpx8a7UH87fzvz8eebn72d+/nHm559nfv51tuffPf199fHm6s3t9dOn8J/++Gn79vBl/N3jwz8fvvxlt/Zf"},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5dzhah5HFoThe9Fvs8yc03W627eyLIuSOIvAyCFWFoLJvUdOPskOFjFvOSeg+JeRPT3M56oC8TDSu6vvXn3z0//+e3P7/Zu3Vy///e7q9Ztvr+9u3tzef/Xu6vjX+u0v3/5wffv+67d31z/eXb08Xly9uv3u/s9fXlx9f/P61dVL6ZcXn1y2pcuFe87HS89zP3HtyKjLxSNTj1e/P/jJxTW0LxfXmH+4+D8v7h96f8FDn0fG5crz0Pg7H/s8vuQ/e58fHlufeewzjvFwddTx5489a8/LxXOO49PHPnse+/ebR+fNs/Pmo/Pm6rx5dd58dt58dd58N948js6bdy40OhcanQuNzoVG50Kjc6HRudDoXGh0LjQ7F5qdC83OhWbnQrNzodm50OxcaHYuNDsXmp0LHZ0LHZ0LHZ0LHZ0LHZ0LHZ0LHZ0LHZ0LHZ0LHZ0LVedC1blQdS5UnQtV50LVuVB1LlSdC1XnQtW50OpcaHUutDoXWp0Lrc6FVudCq3Oh1bnQ6lxodS50di50di50di50di50di50di50di50di50di50di50dS50dS50dS50dS50dS50dS50dS50dS50dS50dS50dy50dy50dy50dy50dy50dy50dy50dy50dy50dy70PI7Wu7e+s3C0vrRwtL61cIzWu7e+t3C0vrhwtL65cLS+unC0bvVs3Wrv+0W9Lxj1vmH0Ra8YjbEe3kYbY394P+/pV9fqfLhtVejjiy+P8iXD/mvfogOvL10OTHpg0QMbHgCvA10OnPRA0ANJDwx6QPQATTpo0kGTDpp00qSTJp006aRJJ006adJJk06adNKkkyY9aNKDJj1o0oMmPWjSgyY9aNKDJj1o0oMmLZq0aNKiSYsmLZq0aNKiSYsmLZq0aNJFky6adNGkiyZdNOmiSRdNumjSRZMumvSkSU+a9KRJT5r0pElPmvSkSU+a9KRJT5r0okkvmvSiSS+a9KJJL5r0okkvmvSiSS+a9KZJb5r0pklvmvSmSW+a9KZJb5r0pklvmHQcBz1w0gNBDyQ9MOgB0QNFD0x6YNEDNOmTJn3SpE+a9EmTPmnSJ02aGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmRJTWypEaW1MiSGllSI0tqZEmNLKmR5dNGVvN8+LXyNT/6YTE99ZNl53k8/O7y89T5ePGZ5xNXS+vhalXE49VP/hyaRj5ePCr//OI19fATbmsd58cXXz7r+oo+6/5qPut4GlX/oZ/1/Io+a3xFnzX/9s8648Nn/czjn2d9uPWsx4tD9fD845k/v57589czf/75zJ9/PfPn38/7+c/Pfw8w9Mm3v+M8vWPhHUvv2PCOyTtW3rHpHVvesW0dC68l4bUkvJaE15LwWhJeS8JrSXgtCa8l4bUkvZak15L0WpJeS9JrSXotSa8l6bUkvZak15LhtWR4LRleS4bXkuG1ZHgtGV5LhteS4bVkeC2R1xJ5LZHXEnktkdcSeS2R1xJ5LZHXEnktKa8l5bWkvJaU15LyWlJeS8prSXktKa8l5bVkei2ZXkum15LptWR6LZleS6bXkum1ZHotmV5LlteS5bVkeS1ZXkuW15LltWR5LVleS5bXkuW1ZHst2V5LtteS7bVkey3ZXku215LttWR7LdlWS3Qc3rHTOxbesfSODe+YvGPlHZveseUd81ri2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8e5Vnr/LsVZ69yrNXefYqz17l2as8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LW4vd5/8f/rH2+uv3n96u39kff/9tPtt3c3b24vX979/MPv/3J/7a8="},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"7Z3vjhzVFcTfxZ9RdM89f+65vEoURU6AyBIyCEykCPHuaeOdnrXcuNdy39o6mE+J4dJVM+uq6t39zcyvL7759l+//Oefr15/98PPL77++68vvv/h3y/fvPrh9fanX1+0v4n8/k9//vHl67f/4Oc3L3968+Lr9tWLb19/s/3vb1+9+O7V99+++Nr9t3989fZ8/8Tz+onn7RPP+yeej088Pz7xfH7i+fnk8199cGy6PxycY+xHRebBWdMeD4dN1ffTb//DDw6H+Xw4HDbeO/y7694+w7U07Q8npblBfcvnPNtT7rb9xLb0ZrfTPdrHbY+Y4+HwGNY+tN3X2H53cV15cVt5cV958Vh58bHy4rny4nPhxbWtvLisvPjKhOrKhOrKhOrKhOrKhOrKhOrKhOrKhNrKhNrKhNrKhNrKhNrKhNrKhNrKhNrKhNrKhNrKhPrKhPrKhPrKhPrKhPrKhPrKhPrKhPrKhPrKhPrKhMbKhMbKhMbKhMbKhMbKhMbKhMbKhMbKhMbKhMbKhI6VCR0rEzpWJnSsTOhYmdCxMqFjZULHyoSOlQkdKxOaKxOaKxOaKxOaKxOaKxOaKxOaKxOaKxOaKxOaKxM6VyZ0rkzoXJnQuTKhc2VC58qEzpUJnSsTOlcmdK5MqLS29Oqy9Op96dV16dVt6dV96dVj6dXH0qvn0qsvzaoszaoszaoszaoszaoszaoszaoszaoszaoszaoszWpfmtW+NKtLUSNZyhrJUthIjmmjnvMGs/XpJxpdxk1k+799P6ySN5FAiAyESH6+SG839K93e1/k4AuY9y+g6H642xGdp/N2ZTF97/CD+1nZ/TFHVca9lHbfS7vX0u6ttHsv7T5Kux+l3ZfeWi29tVZ6a6301lrprbXSW2ult9ZKb62V3lorvbVWemut9NZ66a310lvrpbfWS2+tl95aL721XnprvfTWeumt9dJbG6W3NkpvbZTe2ii9tVF6a6P01kbprY3SWxultzbWbu07kdEQIlcsV4xdJCfy6zB6afda2r2Vdu+l3Udp96O0+yztflZ2n620+9Jbm6W3NktvbZbe2iy9tVl6a7P01mbprc3SWztLb+0svbWz9NbO0ls7S2/tLL21s/TWztJbO0tv7ay8tb1V3treKm9tb5W3trfKW9tb5a3trfLW9lZ5a3urvLW9Vd7a3kpvrZTeWim9tbJ2ax9EFCFywXJpv71ZQFfHfh28tPso7X6Udp+l3c/K7nsr7V5Ku++l3Wtp96W3tpfe2l56a3vpre2lt7aX3lotvbVaemu19NZq6a294j2NntF96a3V0lurpbdWS2+tlt5aK721VnprrfTWWumtveI9jZ7RfemttdJba6W31kpvrZXeWi+9tV56a7301nrprb3iPY2e0f3arX0QCYTIBcvlorfD3uNIJBEiEyByxdvinIsIQqQjRBQhYggRR4gEQgSR+EAkPhCJH4jED0TiByLxA5H4gUj8QCR+IBI/EIkfiMQPROITkfhEJD4RiU9E4hOR+EQkPhGJT0TiE5H4RCR+IhI/EYmfiMRPROInIvETkfiJSPxEJH4iEj8BidfWECKCEOkIEUWIGELEESKBEBkIkUSIIBIviMQLIvGCSLwgEi+IxAsi8YJIvCASL4jECyLxHZH4jkh8RyS+IxLfEYnviMR3ROI7IvEdkfiOSLwiEq+IxCsi8YpIvCISr4jEKyLxiki8IhKviMQbIvGGSLwhEm+IxBsi8YZIvCESb4jEGyLxhki8IxLviMQ7IvGOSLwjEu+IxDsi8QjmThHMnSKYO0Uwd4pg7hTB3CmCuVMEc6cI5k4RzJ0imDtFMHeKYO4UwdwpgrlTBHOnCOZOEcydIpg7RTB3imDuFMHcKYK5UwRzpwjmThHMnSKYO0Uwd4pg7hTB3CmCuVMEc6cI5k4RzJ0imDtFMHeKYO4UwdwpgrlTBHOnCOZOEcydIpg7QzB3hmDuDMHcGYK5s2YIEUeIBEJkIEQSIYJIPIK5MwRzZwjmzhDMnSGYO0Mwd4Zg7gzB3BmCuTMEc2cI5s4QzJ0hmDtDMHeGYO4MwdwZgrkzBHNnCObOEMydIZg7QzB3hmDuDMHcGYK5MwRzZwjmzhDMnSGYO0Mwd4Zg7gzB3BmCuTMEc2cI5s4QzJ0hmDtDMHeGYO4MwdwZgrkzBHNnCObOEMydIZg7QzB3hmDuDMHcGYK5MwRzZwjmzhDMnSGYO0Mwd4Zg7gzB3BmCuTMEc2cI5s4QzJ0hmDtDMHeGYO4MwdwZgrkzBHNnCObOEMydIZg7QzB3hmDuDMHcGYK5MwRzZwjmzhDMnSGYO0Mwd4Zg7gzB3BmCuTMEc2cI5s4QzJ0hmDtDMHeGYO4MwdwZgrkzBHPnCObOEcydI5g7RzB33gwh4giRQIgMhEgiRBCJRzB3jmDuHMHcOYK5cwRz5wjmzhHMnSOYO0cwd45g7hzB3DmCuXMEc+cI5s4RzJ0jmDtHMHeOYO4cwdw5grlzBHPnCObOEcydI5g7RzB3jmDuHMHcOYK5cwRz5wjmzhHMnSOYO0cwd45g7hzB3DmCuXMEc+cI5s4RzJ0jmDtHMHeOYO4cwdw5grlzBHPnCObOEcydI5g7RzB3jmDuHMHcOYK5cwRz5wjmzhHMnSOYO0cwd45g7hzB3DmCuXMEc+cI5s4RzJ0jmDtHMHeOYO4cwdw5grlzBHPnCObOEcydI5g7RzB3jmDuHMHcOYK5cwRz5wjmzhHMnSOYO0cwd45g7hzB3DmCuXMEc+cI5s4RzJ0jmDtHMHeOYO4CwdwFgrkLBHMXCOYumiFEHCESCJGBEEmECCLxCOYuEMxdIJi7QDB3gWDuAsHcBYK5CwRzFwjmLhDMXSCYu0Awd4Fg7gLB3AWCuQsEcxcI5i4QzF0gmLtAMHeBYO4CwdwFgrkLBHMXCOYuEMxdIJi7QDB3gWDuAsHcBYK5CwRzFwjmLhDMXSCYu0Awd4Fg7gLB3AWCuQsEcxcI5i4QzF0gmLtAMHeBYO4CwdwFgrkLBHMXCOYuEMxdIJi7QDB3gWDuAsHcBYK5CwRzFwjmLhDMXSCYu0Awd4Fg7uISiMz3w+52JOIIkQu+8FuV3w7HGEciEyByBXp1LiIIkY4QuaDqh+6Hh8/3RD48PfXmaMb9whK7IWMz5GyGgs3QYDOUbIYmmaErcLVrDQnaUObDYWk933P04eFot8PR7heWbDf3vbR7Le3eSrv30u6D2r22m3trR+5HafdZ2v0s7H60Vto999bG7n4cuufe2jP33Ft75p57a8/cczdm3u6Qt5vhI/fcjXniXqhTm+N2eIofuadO7YzblefQI/fUqT11T32HfOqe+g751D31HfKpe+q+P3VP3fdn7jv1HfIj99mP3FPfIZ+6p97aGbK7H0fuubfW/ePuubf2zD331p65597aM/fUWyuttf10yyP/3Gs77cT+8dzOvDEA2mR+3L4MuVWbDH/0fYQeOXLP8XDao997/O2vaT88bLofttCPH87h8XA4s8njw+8e6x+8yOHP+VjlC3qs/Qt6rPoFPVb7gh6rf0GPNeCPdfT7Yz2xP/Lmfsz7hbvv7kdp91na/azs3lpp91LafS/tXqndh+7u4z33B9+QPAKi5snZ4blf907vdrs9KfbXk/Lhk+J/PSkfPincNxzP9KRw38c805PCfXv0TE8K913X8zwpzn0z90xPCvc94jM9Kdy3ns/0pPx1R3vwpNjxk7IDXtr6yZPStd1+39LVTn6sk7K/Tip7e+85eTB0eDepbdy/SlNPvkrSbj86EvFHjJQK10+ljl/A/id9rOMLeqz5BT3W+eU81uM3N1j6WD9hQUTifunxeEPi5l+K++/F/Wtx/1bcvxf3f3y/cLek0sfH/Zvt+LjZHB93FCE75x/dDwrxD0Z9v5dVsdMn1Pz+qMfRo06EyASIjIYQEYRIR4goQsQQIo4QCYQIIvEDkfiBSHwiEp+IxCci8YlIfCISn4jEJyLxeUHitzuvXWWb2ke8aTu6bZq5n26tHXlKQk+Tz9NshJ6E0FMn9KSEnozQkxN6CkJPhD0+CXt88vV4Nr4ez8bX49n4ejwbvp/Ec38Jkef95zY2b56C0BM+dxL3H+bFo5+c7Z6kEXoSQk+d0JMSejJCT07oKQg9DUJPSehpdY+/k+kNIyMYmY6RUYyMYWQcIxMYmYGRSYwMpgUU0wJ6RQsM6bvMsM/+vkI7oScl9GSEnpzQUxB6GoSektDT5PNkjdATYY8bYY8bYY8bYY8bYY8bYY87vgtOf97oQugJ/3f89Pt5d0JPQehpEHpKQk+Tz1M0Qk9C6KkTelJCT6t7/EHGMTKBkRkYmcTITIjMaBgZwch0jIxiZDAtMDAtMC5pgXgkM/Nzv68Yg9BTEnqafJ6yEXoSQk+d0JMSejJCT07oibDHk7DHk7DHk7DHJ2GPT8Ien/guOP154wxCT/i/42ffz8/WCD0JoadO6EkJPRmhJyf0FISeBqGnJPS0usffyUjDyAhG5ooCzf09j2TMLkcyipExjIxjZAIjMzAyiZGZEJlLaPAnyAhGBtMCHdMCHdMCT6DBo39cZuvF/fP++qO3a8qjwz367Z01+4h7mR+/tZyO/W0v7dEbat7eSWk+ATJndj9Ku8/S7mdl908A+JndS2n3vbR7Le3eSrsvvbVaemu19NZq6a3V0ltrpbfWSm+tld5aK721T3jlCLP70ltrpbfWSm+tld5aK721XnprHb21uX8aZc+ZB4Y6myFlM2RshpzNULAZGmyGks3QJDMUjc0QW1MHW1MHW1MHW1MHW1MHW1MHW1MHW1MHW1MPtqYebE092Jp6sDX1YGvqwdbUg62pB1tTD7amHmxNnWxNnWxNnWxNnWxNnWxNnWxNnWxNnWxNnWxNnWxNPdmaerI19WRr6snW1JOtqSdbU0+2pp5sTT3ZmnqSNfXblyDTOSLr6s0RWVlvjsjaenNEVtebI7K+3hyRFfbmiKyxN0dklb05outsoetsoetsoetsoetsoetsoetsoetsoetsoetsoevsTtfZna6zO11nd7rO7nSd3ek6u9N1dqfr7E7X2Z2us5Wus5Wus5Wus5Wus5Wus5Wus5Wus5Wus5Wus5Wus42us42us42us42us42us42us42us42us42us42us52us9le17g5outstlc2bo7oOpvttY2bI7rOZnt14+aIrrPZXt8oje0Fjpsjus5me4nj5oius9le5Lg5outstpc5bo7oOpvthY6bI7rOZnup4+boGT4H4uRzRTZTymjKGE3xfVTNZorvs2o2U4PRVDKamoSmnuEzCJ9gShhNMTZ6MjZ6MjZ6MjZ68n26z2aK7+N9NlN8n++zmeL7oDZpk++T2jZTfB/Vtpni+6y2zRTfh7VtpozRFN/HtW2mGBt9Mjb6ZGx0wo/eFCH87M3NFGGjC+Gnb26mCBt9+2U5oynCRhfCT+DcTBE2uhB+BudmirHRhbHRhbHRhbHRhbHRhbHRhbHRhbHRhbHRhbHRhbHRO2OjX/K5o0MembJ5ZursZ57SndFUMJoajKaS0dQkNKWN0ZQwmuqMppTRFGOjK2OjK2OjK2Oj6zM0+umti05CU9YYTQmjqc5oShlNGaMpZzQVjKYGoynGRjfGRnfGRnfGRnfGRnfGRnfGRnfGRnfGRnfGRnfGRnfGRg/GRg/GRg/GRg/GRg/GRg/GRg/GRg/GRg/GRg/GRh+MjT4YG30wNvolr1oL991UzM//meclr1q73FQympqEpi551drlpoTRVGc0pYymjNGUM5pibPRkbPRkbPRkbPT5DI1+eusyhdFUZzSljKaM0ZQzmgpGU4PRVDKamnymeiNs9N4IG703wkbvjbDReyNs9N4IG703wkbvjbDReyNs9N4YG10YG10YG10YG10YG10YG10YG10YG10YG10YG10YG70zNnpnbPTO2OidsdE7Y6Mfv2qt57z9rrNPbx831cf+BrF9+CNLkgenZ+bNUev3V3Juv/Y/OBw5Hw7HlPvZbLv9yWx/pD0cHtOP7B+/Eq6Ofaltv9e2r7XtG7X9Ebv9OLTvte1Hbfujtn3q1T23z726Z/aNe3V3+9kOi9O4V/fUPvfqjtv9dUo7tM+9ujFP7HOv7ql97tU9tU+9utlvt2yph99tGfXqntunXt1z+9Sre2rfqVc3583+bIfRderVPbdPvbrn9qlX99w+9eqe26de3ftHTs123Dzcq3tqn3t1T+1zr+6pfe7VPbMf3Kt7ap97de/2j+/3g3t103f7h9+qB/fqjjyxz726p/a5V/fUPvfqntrnXt1T+9yre2qfe3XP7I8Let99P+xu79m/qShExSAqDlEJiMoF1eH7j9G3G2g5VEmIykSoZIOoCETliuzvd2bbDbweqihExSAqDlEJiMqAqCREZSJUZoOoCETliuyH3xumH6ooRMUgKg5RCYjKgKgkRGUCVLQ1iIpAVDpERSEqBlFxiEpAVAZEJSEqkOwLJPsCyb5Asi+Q7Ask+wLJvkCyL5DsCyT7Asl+h2S/X5D92LGW7bch7VClQ1QUomIQFYeoXJD90LuKzUOVAVFJiMpEqFzxmqcnqAhEpUNUFKJiEJUrsi96z74cqgREZUBUEqIyESpXvPLiCSoCUekQFYWoGEQFkn2DZN8g2TdI9g2SfYdk3yHZd0j2HZJ9h2TfIdl3SPYdkn2HZN8h2Q9I9gOS/YBkPyDZv4KQjNF2lRGHKg5RCYjKgKgkROWK7O/vX91HO/w7NhpERSAqHaKiEBWDqDhEJSAqA6JyRfZ93rM/DlUmQuUKru8JKgJR6RAVhagYRMUhKgFRGRAVSPYTkv0Jyf6EZH9Csj8h2Z+Q7E9I9ick+xOS/QnJ/kRk31qDqAhEpUNUFKJiEBWHqAREZUBUEqICyb5Asi+Q7Ask+wLJvkCyL5Dsy+Lsb3/678ufXr381/ff/rz9N2//5S+v//3m1Q+vH/745n8/vvs329n/Aw=="},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]}]}},"file_map":{"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"34":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"43":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"49":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"52":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"55":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n","path":"/home/josh/Documents/test/aztec-token-bridge/packages/aztec-contracts/token_bridge/src/main.nr"},"67":{"source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"71":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"73":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"77":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"79":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"83":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"85":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"90":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"96":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point { x: x_coordinate, y: y_coordinate, is_infinite: false }\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/keys/getters.nr"},"97":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"99":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"101":{"source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"104":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"108":{"source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"112":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"113":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"115":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"116":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"119":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"131":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"138":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once. \n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"157":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\npub fn compute_inner_note_hash<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"164":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr"},"168":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"169":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"179":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"180":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"181":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"195":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"200":{"source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr"},"202":{"source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr"},"204":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"205":{"source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr"},"209":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr"},"210":{"source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr"},"212":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"214":{"source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr"},"215":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr"},"219":{"source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr"},"223":{"source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr"},"225":{"source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr"},"227":{"source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr"},"228":{"source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr"},"233":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr"},"246":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"248":{"source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr"},"250":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr"},"251":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr"},"252":{"source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> Self {\n        // Hide the counter when exposing to public.\n        Self {\n            log_hash: LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length },\n            contract_address: self.contract_address\n        }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr"},"253":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr"},"256":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"257":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"270":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"271":{"source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr"},"276":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"285":{"source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr"},"286":{"source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr"},"288":{"source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/header.nr"},"290":{"source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr"},"301":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk, from));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"304":{"source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr"},"305":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr"},"318":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}