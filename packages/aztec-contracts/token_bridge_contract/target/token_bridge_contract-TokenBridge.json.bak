{"noir_version":"1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-x8664","name":"TokenBridge","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+VdzY8kyVXP6q7qma7+qJrp3ZmemZ6Znp21fUCGzPquW6+MsVaWpZUPNsJIKOtrWbMy2LsrYVlIjbhwM2gFlvCFqw/IFziAxAEhJN8Qhosl/wEcQQhZgCxcuZuv6te/+lV0ZndETY8d0kxVZ0S8r3jvxYsXkVGV6OOyP/9Xyb9X88+daLVYm7P8M75eSTzCikPSWXlJ6Nx6SejcfknorHqkM6OtGl0svumtBZCrbxp3XgIab70ENN72rJtGo+no7vxfff5vL/p4flipRMYyx7Od12dKmA1yJsTb0G4tYBLQk52LOLag3qPjSHYJr0/4g7gbo4wC0N/ezWHeCgN/aPBvh4EfG92fOV/CR14M73b++bnzpSw/B32ycpB/ryybLOBa3RbU/SrVbUPdZ6kOnfavUV0tWqXJ5LYDvPjTq84g8Lh0jLdbwJvJ1XDvhsHdrRC+KFqODdYZ/noU1AaSCuEzelg+plsH1uZ8Sc8O1VXPV/mwuhrU2fhmn8+hHevWLWj3y/CcdX47WrURq7dxRVl71Nmxwa8GgB/nOvsRj+dL+Dwm1fOLuLEO5V4FeT4n+YSYi1A+IeSfyedoDf32PSu3zqNF2SZ5ooxMZrexPdXtQl31/CKeev53FfAgLKOjRu0/nf/dyD93oI/1bwr8O4T/At3iGcqIYW2LZ9Y+s8lP5t+z2CbTn+/nysQ+Oytn+Wd81TKOx900nRmt5ktq0aqtGV62Qy905OVA8MjzRh2ev4h5w/DXo6Bz6GLeqBM9LB/0UVndnqC1KepwbLEO8ewJPC8jrMC6E+8K3JFH+GaPZp8f5p+Zv/gM8Vgh+fmhoR+r+csj/I6av/zB781U/OAPfrdr8GtB4HeGak3gUf59FZd7lP/U4O+Hgb+Q/0EY+S/08zCM/Bfj2wgCv7Ww32YY+Y9s/rkTLQvP3XfhuT//mxSeuw1/nWgNNXffJXpYPjx3Hwlam6KOfdiRwHMk8ChYux5hNW8oXdseYe3cUB4bN5Qun7Lf8ghr3yMsn7L3yeOhR1gVj7BuquxrHmEt8hjRqvyycpZ/xtcri7nGaMG5YY/4iaLl2t7a/ynRGSZ/lPRULpzjg1og3Cz7KNLxgeE/EPQY3fU1dWdXpHU4nE67rVmaxN12rz3tVAi+0crP2E/siPYq1gibf086ZfPXNaqrQZ3RqPKoIfZGMvqLyB/xN0Ud5hnKjOXd6KKuoT3ynkolWuaBMlp+kjdsRKs+9jbRsy/o2Rf0NEX//QKwdgQsa3/gwI2yawjc7FOxX4j4/bAkbw3RHufgfeIN16oN4u0wDG8to7VZkrc7oj3G+4fEG87Ld4i3Zhje2kbr3ZK8qXke16pN4g3XjUfEG+I5yz+T1nA0mySTtNsZ9eNea9IbdTudaX/a7o2GcX/u97vxrDcbpXHSag3GnWTcb80nhm48nHX7cTLl9TPCjqfxJJ20Wt24O2jPWulwFqfjUdyZTqaTWTLvPRp0R3F72B6n0363PZtjTTqjwSCdDZLxqNvaFTJYwO7M6Wknnf6oN4gH3XgyHrSmg7TbTYfd1qQzmbXiVrc3m8bdYXsy7Aznj+e0p3E8p2E0SxY5mVcU7GG/PYpb4+44Tcft9nwW7KST7iQddZN2azhsxbP+HMSol8ZzguePp93JrNePO/GoPZ80ewu6X1Ww08FcgtNePInn/826k/kGWbcznHQGs/Y8lTOJe8kcznAwnfSTfjocddutdNZrx+Ok256nYhKDfU/KezJKpq25PNvj6TAZzcZzWc+/pulcPnN2OsksHU7iYTaG01Enbk9no2Q8S1vjUbvd7S/ykPeVnrQ7yaTX787SuB1Px9N2krTnQpkPXbsz15/2KBmOetNhv9eKO73+/Fkn6QxanXFn0ksn0/ZC3scCdmvQ6o77w/G4l3bHo9F0OuvPew0+EnHSGrWTVpq224NOJ06nsznh7eFcSIPxYDgf/jmLQ5t/HgBsjt8ewnOPc/KFw0VWVPxm+OtEa6j54SHRw/Lh/M4jQWtT1PG665HA80jgUbBe9QhrzyOsux5hvXJDeTz2CGvnhvJ4zyOs+zeUx5tuj7uCTo/+NzX/hf7OivJtGPtx2aa/ke4s1v+b6hIut2OcaBOPqA79y0n+nWOGFy0njCO5KDkZ3WXlhHrBckLfyXJCe3yRcsI1IBclJ6O7rJxQL1hO6OdYToHinhHLIhI0nwBuXE9yUXIyusvK6b6QhdXhnPc4/74raPUop8kB4YsEzU8It33nouRkdJeVE+rFE6pD/X5KdScCrsnwMfFxlv8dX6+MKtEqHyrGNvz1KOSYLmPsx0QPy4dj7CeC1qao43jqicDzROBRsO56hHXkEdYrHmG96hHWPY+w7nuEdewR1kOPsHguwhwT+4cwZyziTlH/wGcswuTp3Wcs1Bo8bIwcz4yeVwQ9Jw56wsSicWr03BP0qFzonfw56xDKC/0J0n0P4GelIeCwv1XjdlfQ1RT92d8eFeTRNUbIZ93Bh/W9aWuuCtWdrJEXl8vWYz+45nrMmV++XmnzGgbpCmxfhf2h4a9HqzYUwh++SvSwfDheuidobYo6jkuUX7kn8ChYWx5hmc41otXx5vhHyeZVBx7l75z7DuVKmx8YbLRrjz5lrNYXVngNxbLkovyG0f3Rfn1tCZfbMU4cz8dUh/Edr6EwXuM1FMZfp/n3RrQq3+vmL7E/x2nYr7Lm0/DwsyI514aggePhsrZ1X+A5EP2uy4+imcfcBx7k55jwHHvEg7r4kPDgWRuLLTK/9eXK8jn2q0XLscK+TajH9n9WXcL8jRxm4NxUaV/CtqHWg1b3FOpYN06hDmXO5bJ815sl/BPOA8aTjYGd4/ntvGM2BrPKxf44hng5zr/TmR20Cdy7vIodY39rx/vDnnUi+D6B0V02D+fy0SqXedPm4bL7BDgPl5GTyt26cpk3La9bdp/gqnndO0IWrrxu2NxtMmVZRIJm9Kll9wmM7rJyui1kodanp/n33Wh1TD3KacayiATNp4TbvnNRcjK6y8rpQMhC+YFnVLct4IaVYfF9AsNfj1ZlGWLdq/KrKB9e9z4VtDZFHa8Pngo8TwUeBeu+R1jHHmE99AjrjkdYjzzCuu0R1olHWAceYfGc7bpHAfG+iLyY4d/UPQrq3LlrnyDQu6GLfQIVz2876AlzFmO5T3As6FH3TOA+AeoQymtdPuIY4GelQXwrO90uKCf1rsI2wTooyGOFeML2yHPdwQefeQ9jb8v3qlCfrKg1ToXqeC0YRRdtF/nHgjyV3SfAMeL1fUX0DX23UVGfZc/qRGson6V0H2nkmOZA0NoUdZzLV3ZxIPAoWEXe7ykKy/SisQY2ft8SeLYceCqC5rC+vrxtls23G91l8+0oV7Y/1HvOl6LdPqA6HEeLJ9X7MkV8rHpvsSn63yEa1N0TRWxb4VE0K73kOaasXm4LPAei33X5UTS71pFXxaPmclc8elU86r1Aw6Pexcxilv+oLJ9jP8y3Y1/Ot1v7b0G+/b9ymDdtnmfbwHme9Yzfk8E6XBuWza9hfFAm345jwP5J2UTg+GBaREdVfLAVhh5nfKB8TfbeqeU43p6+/9YHo3ffGX9++s333vja5K30G++/k777xmTyjel77yE3rA3MLWuByipm39dl+VXUvLUGP3Loiv5dnvm2gKWkxd4B26MFuKL/gwKwXLgvW3nwm8RI150CsFy41WkqhMlv+qrIUp2qYv1QsBG3ix4X/WplrW4pUvTzTlmg04KLWwbul+RNrdLR6x8Rb7gSP94Mb10XrS7eHoj2xw7ekO8Hjn7YDtscCdlgvZIrzzhhdlLjnslEvWHqkqE6vfJQ8NkguWHfwLz1XbS6eDsR7R85eEO+TzbD28BFq4s311sOijfk+7GjH7bDNsdCNiifMDvf8dDFr0s+andHnS5pCBk82QxvqYtWF28q4//EwRvy/XQzvI1ctLp4OxXtnzp4Q75PHf2wHbZRu+8on0C7omMXvy75PBPtTwWfDSED61tkZXQahu9JhfAZH/gM8W9qZXQarcpVjcMByRL7NkUdrynU+D0TeBSs2x5h3fEI68AjrHseYR15hPXAI6yHHmEde4R14hHWY4+wwr8Z0u5w1stwI95At8MUzhYZ/nq0OvYhfKJrfZUV3hUJc3L44zkD4SM9D4V81Mk6tl/Tdczkqtt2tqJV28D4t0bPficXis9bQbKs8XTrIm+c91CfBpefsa2pdS3vrmafmBn/va2LvFg/lCf2fQL12D6FzPh7OUy1a8JreZ834Co8Hn3NhB+EPQXbivlkIhYVv3CuIiL5YUG6y+4ior96RnVon69RHdr4c6pD+3o9/650hOfJsjqi8kqbssWGoIH9mcpHHTvwPBB4XHPgVflRNPOY+8CD/PDbNA894kFd5Lgk0Fp6cpkv/g75YjW3VQTdPHd9DnzxX2xtgrer+yqrew3qWI+fQx3r3utQh2PKRfk/fFvizSueojCeAr7tPHuBMW3hE1I3NaZVc4/1Vb6AYztXrIp4FKwtj7As/6NiKp4TtwQe10kUdULgF/WNZJQrn6pG3eC3f9D+rvpGcpE9Hdcbydh/U28ku05IsS2V1Uu1Ngh9QmpTMeGLiqHWxR7/QrGHeiMZ+657I/nTEHv8G8UeN+UtOLaNU6hz5YddMQvKnIvyT/hmXZnYA9eavAcUJgYo/zbmiaDfJYsHIIu3r+ir2R+jra2TU1bO8s/4eiXh+dIBuzWeJe3utN+Ne2mnO+m1W5NWP550urMkGSStYWfQbs/GncFk0GrPWv2WnCsrxFOg2wELx38/L7cD8nrcx+1tPmDtET+u29gDrV/bRXXB8G/qNnYVJ7luY1fnB5qirshZjccCj4LFc4drzzbk2TPEZ3zgM8S/qT1blcNz3ZwXUr/XjbPrjcFAZwsWv9hS9OwFvqGnbn5mnUS6nwL8rGwqP2+wHhTksYjNZ9/rDj4eFYDlwn3ZeTQ+o4t0nRSA5cJ92XkxPqPrOi+GvzS07rzYloC9DsYWweDntlZQZ4OZDmurbrNh2W2toeER1K/z+wjv0SXwWH5qrkCYT+jvIwFLxdY8H+Da5UXMB4a/LvgOMR8of6fm2czf3YpWfRnqDI6fOu+dfb8veGU/qOLHSrQ6zkXiunU+uAzv1v5UtEd9qTv4OC0Ay4X7mWiPMNkPus6wKf0vop9Il9qDuC6sZx5guca9Ga3K7SnVPYM6pu+1aJU+8xvP4fmL8BuGv060hvIbz4kelo/yGyonx/NakTbPAW9WGtHqGCD/6+h9Luhtiv7PCdbrUTHerf0nRHvcS6s7+PhEAVgu3J8U7REm+w2ky/rynuebueCz+Pez+XeV87zqTaJ4hucLDvjPHfBfd8DfE/CV3zBcym8cU90zqMN8LuruF0FuX3LgPXDgvefAez9ahV+jul8HGn7TQcORg4YHDhoOo1X4FhOui2+tfk/wYn+jXNbFjPxrVFuiPcbeBq8h+j+mOoxnTgnPkcBzKHipUN3tNXyw7B8LHtW4sN6ocWF8ph8NgYN/xfqr20u6P4DcMbYxGFnZjVbl+iLmRsO/qRzLHtHD8uG44kDQqm7uQN6wDvGUvQXEByy+hSfMr+qGv+kD7bLMPjaOC79Jj3LmszZoF2Vu+mD52ne28+1I+9qsqJskDokG9hnqM4qKxeOK5k3dTHUg+l2XH0Uzj7kPPMgP70vsecSDusg3fSBM3Mf+cHv5HPsV3ce29kewj/3nOcybdtMH24a60UudT2HdUHFoUf901Zs+cL5bdxMR9t2NtC2d5X/H1yvdovO24d/U7abq7grla/ZBjm9P3//89JtfSt99Z5K+/87vfu2L069/MH3vfWQDQVcFmzz8VUJn7fhv1Q7Lpi5SqhA9CEuJzyVulE/TwYf13RV4zvLP+Fql3T0QfG3IRAqHtmwi1TD0JEXGLIpWQ9s9QauaclgvVQi9J/AoWDWPsKxO6WCV8JS1parAE3bJFD6ENro3dVkejjWH0GibHEKrMb6qvqgUROgQzaWXIXx86KOgmwrVa4Sn5hEP6iKHfQgTQ+gfUQht/YqG0Nb+fyCt92MKocPMCclifsQf6YqIb9z6Y9tAP8N6VjS8RplzUf7JZFE2hMYx4B/SwR+esXb4wzMMA3HYGAVKSRUOtQ3/pi7dVT5J2ZaaA1z2zT9aWTZ9gLBe8QhrxyMs0zeTzS2CHeX4fuLYOrE+mU2yL/k/8CUHucGYntYBhke9WBwHuyyFUId6bP//kJr+/dpFeVifKHLHrEwDtq9Tm6yoawGtb1h53Szfq1IbZS8xNTll/b5VwC+jbvLcaThYd/aji+1xHlbtcS7G9neqS1r/jrZBVH+c51lvX4XU16fI1nBLJoSt3QH+FP8N4t/aPwD+2dasTxS5Y02mAds3qE0U6W043nYII6+blSrkV8xYJlyUrZmcytjap8jWlI902VoDYKn26Pex/S8VtLUDgP8h2ZrJ8VfA1t4gWwv0CsXKMed1tnZC/Fv7tsPW1HFW9Vou04Dt+YhsVtTVjtb3pv0YHb9ehsfe1h1Vy77zKwLPoI7zCK9BXdnX3vHaj6K29gbZmnqV2WVrJwBLtefjKdb+swVt7SHAt1cZV44Iga19hWwt0JHWxZVHeG2O4p9/XNTaf8Fha76v0mRbc12lGUZeN+saCav7BNSVfbURX/MsamtfIVtTPtVla48BVhm//lsFbQ1t2a4sUVfbFHnFw8XHw0v4eEB8WPuZ4CPwq0NjHquyV7Z81WHnvl9Pcc2pfF1yoBhkwrqK8lKvy7Cufl3Iy+xq+3zZH68+z0r1PAg/04yOvyebwXGrAd7LxigrZeMkPv6I/vkh1alXoZSdG0y8Jo7Xin8Ac+q3aU4N9BrjIn61tc+6H3E5ii7SbO3/0GFr6pW2CjzjcbnsJweMnhf3kwM36wdkfKwVTU5l5tRvF1grou7wXHQEsFR7Xita+w8dc6rqjz9WxPPad8DWvncD1oq4x7DOT3+35FrxFXhW1gcaPT8va0Xe0zmFOt6PfgZ1HPdueq34vQJrRdSdImvFXcEDx1B/5bA11T+D/+Wc+JDxQX8QxyYji03MjrhUoR7b/3XOG+bu7bN6DTpn/TSZtdNZ2k0nk844vUvws2J2mOX7Mtl+n3xPoPM9XbUfbsXqeA8riorrNu67XvXamR2qwz0x289iOWXlLP+8RAbJZUIyXCajrUiPieI7Evzw2QP722ytIuDUqO0/kX7sEC1nxXi/tLCuqvGoCD7VOJqMLtPxyB/9Hdd5j8CyK3yWz/DXo9WYJcQe/A7Rw/LhMbwlaG2KOj4Xd0vguSXwKFgVj7D4zBTC5jODFYGn4sDD/bOyK/qd5Z9xudLmB4HPnw55LsdidWpPvOh8YHRf55xgnepQ73i/DG17n+pQR4wGpSMcI5fVEe6PNGC/yppPwxNdgkfRvKnzq6HPCVYJT9UjHuSH57Ydj3hQFzluQV30ubYM7C8W/mg3DPxExXx4vuJ/15wFwTW0ihf57NNubQnzpxSXBJqP++yHsKizzOw7UOZsh+ij2XbwPDHqJBflv00WZc9RqvFT8SPGiDxGezBGj2nPIfT5NHw1WukVn0+z9o3aUl5FzqepOIxpwPbM90c4o1Xdsb6B5TU6ELRasTrORWAd5ilZp/FVUtZpPAPEPrwJdZs4n/aYxtn1ehnbMeLcWdN+3fm0Z6BrnJu5zH+q9RjO5Wf5Z3zNwvQYTYg3UK6j8HrM8G/q9cOi78+pnLb1VesR9h81gUf5m03BakR6vBGPkk3VgQf7F4kZA8/xhc/hG/5Nvc9XKyhXtY6qkcyxjvVE5Rp2BJ6XCRbrDscvZ/nf8TWLekckivz7YmWbrtyvWpOvszWE74r31DxluDlf2IjW+0GV0/MpM6PfYnbFJ+KvUfu3KG4NtS5TeVt+dzqQz+uptbMVlXthvVLXI6k1D+uOWvNUBA2XrWv+tUCcp3SwQnXK/1gdr/ezovI47GvVvoia+zi/wPPQWf4ZX68kKoeyKf9YIb6jyO3LXTHFtqDflTtz7X2wv3LhMJjbApfSU4ah8HvMP6/sjbEcXLypMxzVNXxj/5rgm+2syN7bdrTeRhnuloOPy/oqP6V0JtML33vL/da4m7a7w3g87fbTXv+yvWXf+KeD4SQezqZpkiStSTwts7et/CTnMNT+kpo7o8i/X1mcVwA8SA+vw639H20mNyXn+DrJKFReuUIyQFt25bkD7bUmnCv8S8gV/nH+XekU+3oVe1idij0aUbQ29jCe9wOPAZ6Lc5394XOlfyJyk+p8L45hVqrnQfjpqPO9mEesAV7kK4qWfKv7OlhO2B7HxvhTVx3yHKLWzyhzXjeZDNedt+IzINb+uyKnp+JEvj4Seef7d9Rcq+I4zEP+Lfm0QH5lwGsALGoNUKE6tEOek9W9QyonXXbtYLIou3bw4YfY14Saa36R/YLJ1OUXfNokr+tQH03WaJMh4rpON+2P036SDDvJtJN0L4vrFu/5ni/rUVeyciv/22IFbm/watT+H2Au/0eyr5rAl7X7oaNdZc3nRzDEs+r5xWe756vtt89X2xvu+vkqjVa3B3Wox1nZz/9GeSEso6NG7f8Z4p2s3IY+1r8p8N8m/BfoFs84L7kn2u+J9tn4/CCncbFvCrh957s/wknw8RnT9kOwK7UvFuqsZeC5NQmcc2yrfPIOyPVHtC+KOVK1Vuf1lbX/T/AHP6bY3mc+Ts3FPN8GOvfS4XgmAn4CX69eeM+Kr1cPFHs4r1dXeb7A666OK26oC3qyd70Oo9UxQ/oMlprrlf7yGcyy+1nYn+MNHGNX/pnjIpV/VjHM4jxP5M4BVUgO6/wE77VY+/8GP3GcN1L42E+oc1Vqnc9+AseW/cQB9TvL/46vVxa6eHiJjPjdOWv/U8f5JKXfeC6Y42h1Bb2KlU1eqP+HJK8wPyWwzJk0LpHXIcnL2ld31stL8e/ah1B3Jh065IWyxL6Me51v2ZQuXiZb1kVrvy9kq9adu8BPVqrnQfjpqnUnri0xZl1nL9i+yPi71pZ4xs3GW/ls9ueId5/q1BlG5bPxp5PMl7rmHhxvznPgGraMPz8B/XC956tizp8B7vsYCkoBAQA=","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_data_witness","field_less_than","decompose_hint","lte_hint","pack_returns_oracle_wrapper","directive_integer_quotient","directive_invert","directive_to_radix"]},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/71VUU+DMBAuY2TiXGKmDxpfNDHxtR3gtjeM8VUT/QVltIZkZgam8ZGfLiTX0dXCwMG+pLkDju/uu6PUQAUMsH20DQNpbqhBpcHSvTuwNtie9NzMlg/XeD8QW8nbJv8Mu66t0ddi/Y4NnEY3/Fjwd9R/PACex7Tgl7WIvEfZGoI/qniny3qzeW76bXbAn4GcldQvenAF/km2TsGn3x8vn4tVyB7CMGZJIu8rtZ9VaMLZa8B5oXI+fy2XEY9Y/PQTJes/3KaGW/g9pNem1iXHydDtlxw+WLwfiKVoGIPNZ3dTUkOL+Sd5v8+Ba9Pvt/Uqpu/sldGw7hzrfkMmKt+zslazgVZeEyKfOF8GSP8vzGEpsZdg87ncgj+q0DJExVnUT7f5/R166mA6w1jkNdOiZrlvSMlvKfHXcH0s1Y8k3f4/6+RTSrhDOfVoGLoLOlb4kdKntvMHjDAnm7fDqMvv+cHzexRPmEuCwCOMzud8V/5f0WQc9ikJAAA=","debug_symbols":"7ZbbjoIwEIbfpddcdA49+SqbjUGthoSAQdxkY3z3bQ1FliVyo94sN8aSLzP//EyHuYid35wP66La1yex+riIst7mbVFX4XS5ZmLTFGVZHNbDx0LGH8AbfzrmVTye2rxpxQq0k5nw1S78NVKGCPui9GKl8Zr9haVUCZaoehiIJ2gmazuayZmedjABW6AU2oKCIfyZCaAnaLeY4CD+jdr5CdoZet/1nO+gKGkH5fixdoeYQjvUPNaunqod5G/tMYN+eQbz8gx2OgP1GbQyjzMgWNPB4YUMupPdBG0QdEcbpJnuDNWl0EayfgyHW2KobzUn9bgh3L8pFeXbS5XQl6pwrtR0xw3fJw5aOTWfLKcrLt0MyzopZkd3we7mCCyOjBzBxZGRI7Q4MnKEF0eGjlzD6StvinxT+m5p3Z+r7WCHbb+PfrTOHpt663fnxsfFdrDTxhmNJiOM36Y4nogyUiFHyPMD","brillig_names":["get_portal_address_public"]},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7043145299448266897":{"error_kind":"string","string":"L1-to-L2 message is already nullified"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13293000217372736598":{"error_kind":"string","string":"Tried to consume nonexistent L1-to-L2 message"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["claim_public"]},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","field_less_than","decompose_hint","lte_hint","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","pack_arguments_oracle_wrapper","call_private_function_internal","directive_to_radix","directive_invert","directive_integer_quotient"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==","debug_symbols":"ndLNCoQgFAXgd7nrFqn92avEEFYWgmiYDQzRu49GMzRDG91cPOJ33ZwNBt6tUyvUqBeomw2k7pkVWrm07Ql0RkgppvZ6DakfCB3vl5kpHxfLjIWaVCgBrgZ/os6PQnKoC7w/EkA4WJBgkQWLPFTg2z8oocVJaIbJ1yBUHCiPQUUMKmNQFYHIbQVoVuUflKfZL9pdfDIjWCf5WbFxVf2lcfY187/yzUb3fFgN9zW8NNDNBpUJxm6tW/0G","brillig_names":["sync_notes"]},{"name":"get_token","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"11235885384217001395":{"error_kind":"string","string":"Function get_token can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/71VTUvEMBBNPxatVZBVUS8KgvfUVLveKosHLwruL0ibRAqVlbaKx/50u5DYONuu+9HugzBpMn0z85IhBqphSGujvzBQwwJ0anXW1q6ldaQ1tX2rGqH8xpvBc0DcLvlH2Pedhvo6zJ84ktPohx8r/p70xzuSZ1zW/HotKu5uNVw5P1jwT5/5Vuf5q7fVA38F76glf6XBuZzvV+NQzunX+8tHPGX8gbGM57neV1DPRViF01yB8wxyPn+maSISnj1+J3kxx201cKu5iZprg3npfjqa+mWGUFq8GbwBqGEo7ezsLjVNTqAmT/mkoEUSj2marnuA8PJ3WRgChQ1Qe7NCEU41Ea40EY6hCJNimtE3/sopW1aDZS+mi+rHxC5rn66aNxhhrGJaZa2DheZha/u6/4X83gM1qEc0XDNPEVBPECroLWXMj+kQ8CNNN7eH+BH3OBFCEE59cSe2Hv8+4ozfEIoD3xMsIv/F/wGzLjA+6ggAAA==","debug_symbols":"vZTbioMwEIbfJddeZCbnvspSim1jEUTFw8IivvsmixHrirKu7Y2Y8M38PzOT6cjdXtvHJc2Toianj45kxS1u0iJ3p66PyLVKsyx9XKbXhPoP4A9fl3Huj3UTVw05gTQ0Ija/u19FqcuQpJklJ4l99BumVASYohhhYHyB5kzrgebMqJE2sABrYCG1BgFT+BwRYAd41xhgZ/6N3vkB3jmMdZdbdQfBgncQhq97N4ghtUHJ597Fod6BPnv3CvLlCurlCvrfClKNClKJrXnTJoyyNiDmPTN/dONikO6IgR0xuCNm8e1LkGPBQJn16iJoNcBu3Cdvn5sFWiHIgVbINnrh/IbUinK5DrsdpNj4kA19ws+9O33GVRpfMzts86TNb5Pl3nyVdrbny6q42XtbWb/xJ8veNxRFxKifCN8pBhFjTsPpfAM=","brillig_names":["get_token"]},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["exit_to_l1_public"]},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"7408320001641276198":{"error_kind":"string","string":"Function _assert_token_is_same can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17456365777023668047":{"error_kind":"string","string":"Token address is not the same as seen in storage"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/81VTUvDQBDdNikaqyhV0INeFATBw6aJaY4R8apgf8E2uyOFaiWt4rE/3S7Mku00rZYkxQdhZj/yZt7bfDRYjgZGl4xZwZ4EIy8Hv0IuvtDkOhGrRN1i9DA2rXWnQtEeqVslf8zD0CvQV2H/gYecdfpjOGvg5zvI8zDL+akWjQMc28+QuWd3frVxziP76jjPGv3mxwX9m1pa5wXm+/PrCHPx9fb8kY6lupcyU5OJ7RHtdR024XQ24DyjnE+fo9EQhip7/B5OpkvcRd8LkzfJXHNFX/a8jaLz00gw8nLwW0RDB6M+uyvLk0PqSV+9S5X9p6NjREqLrX49qexTjFr2NebUeo0EIy8HX+s/ofr703EmXtWLEvKvHmziv73eKuBtkDWz95zl3txg3mb5r86dLfaZ4DwvgV7MuenHmeV9OWwZrrVu77/E8Z6l0US3RJ/QEz4EAsSdkDJMRYfwM8u7dg31B8pXAQAESoQQwdbrR1EKIkhFxANQQTfadn3ohn4v7sIgTmMOIfxW/we1XGnYqAoAAA==","debug_symbols":"5ZXNboMwDMffJWcOsZ04SV9lmiraphUSgorSSVPVd18yEcQYKmpLd9kFEfSz/cfxx0Xs/OZ8WBfVvj6J1dtFlPU2b4u6CqfLNRObpijL4rAefhYyPgC/+dMxr+Lx1OZNK1bATmbCV7vwaqQMHvZF6cWK8Zr9hqXUCZaoexhITdCKrO1oRc70tIMJ2AIl1xY0DOH3TAAtoN1igoP4P9SuFtCuoM87z+UdNCXtoJ26rd0hJtcOWY2160W1g/ypPUbgl0cwL49gn46gtKZUb5phpt5QplK2CGZ8Z+55NctVP8o71UQbeMAGH7CZnCpMOl02E7vbmUKwpoNDIw2minITtEHgjjZIM3kNepNrIxXfhsN0M9SPCCd5fA3q//yqnv1VC+NK4AdszL0213D6yJsi35S+W9f7c7UdbO/28+hHi/zY1Fu/Ozc+rvTBNo99hS4jFVs+NkzoQjIhRojzBQ==","brillig_names":["_assert_token_is_same"]},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17288131482828810359":{"error_kind":"string","string":"Message not in state"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","field_less_than","decompose_hint","lte_hint","build_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","call_private_function_internal","directive_to_radix","directive_invert","directive_integer_quotient"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7043145299448266897":{"error_kind":"string","string":"L1-to-L2 message is already nullified"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7408320001641276198":{"error_kind":"string","string":"Function _assert_token_is_same can only be called internally"},"11235885384217001395":{"error_kind":"string","string":"Function get_token can only be called statically"},"13293000217372736598":{"error_kind":"string","string":"Tried to consume nonexistent L1-to-L2 message"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16541607464495309456":{"error_kind":"fmtstring","length":16,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17456365777023668047":{"error_kind":"string","string":"Token address is not the same as seen in storage"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::get_portal_address_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::get_portal_address_public_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::get_token_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000c0c5aaf"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000c0c5aaf"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]}],"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"TokenBridge"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}}]}]}},"file_map":{"17":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"51":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"52":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"57":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"62":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract TokenBridge {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view},\n        storage::storage,\n    };\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        token: PublicImmutable<AztecAddress, Context>,\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.initialize(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[private]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read()\n    }\n\n    #[public]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read(),\n            message_leaf_index,\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_to_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n    }\n    // docs:end:exit_to_l1_public\n\n    // docs:start:claim_private\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    /// TODO(#8416): Consider creating a truly private claim flow.\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read(),\n            message_leaf_index,\n        );\n\n        // Read the token address from storage\n        let token_address = storage.token.read();\n\n        // At last we mint the tokens\n        // docs:start:call_mint_on_token\n        Token::at(token_address).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n        // docs:end:call_mint_on_token\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n    // docs:start:get_token\n    #[public]\n    #[view]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:assert_token_is_same\n    #[public]\n    #[internal]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n","path":"/home/josh/Documents/test/token-bridge-tutorial-test/packages/aztec-contracts/token_bridge_contract/src/main.nr"},"85":{"source":"use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"87":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"91":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"93":{"source":"use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"96":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"98":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"99":{"source":"use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr"},"105":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"108":{"source":"use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"111":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"115":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"116":{"source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"118":{"source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"122":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"125":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"126":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"128":{"source":"use crate::utils::array;\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = array::subarray(returned_message, 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"130":{"source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"132":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"133":{"source":"use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"134":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"149":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"167":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"186":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"188":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"205":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"206":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"230":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"237":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"279":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"280":{"source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Deserialize, Empty, Serialize, ToField}};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"292":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"295":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"302":{"source":"use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"305":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"331":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::encode_and_encrypt_note_unconstrained,\n        },\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        // TODO: constrain encryption below - we are using unconstrained here only because of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(&mut context, to, from),\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: Field) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // TODO(#8271): Type the amount as U128 and nuke the ugly cast\n        let amount = U128::from_integer(amount);\n\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueud call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: Field,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: Field, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U128::from_integer(amount);\n\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            user,\n            user,\n        ));\n\n        // 4. We prepare the partial notes\n        let fee_payer_point_slot =\n            _prepare_private_balance_increase(user, fee_payer, &mut context, storage);\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund(Field,Field,Field)\") },\n            [fee_payer_point_slot, user_point_slot, funded_amount],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_slot: Field, user_slot: Field, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, fee_payer_slot, tx_fee);\n        let user_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, user_slot, refund_amount);\n\n        // 4. At last we emit the note hashes and the final note logs.\n        fee_payer_finalization_payload.emit();\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"347":{"source":"use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr"},"348":{"source":"// docs:start:mint_to_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_to_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes:[u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"mint_to_public(bytes32,uint256)\".as_bytes(), 31) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_to_public_content_hash_nr\n\n// docs:start:get_mint_to_private_content_hash\n// Computes a content hash of a deposit/mint_to_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_private_content_hash(\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 36];\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"mint_to_private(uint256)\".as_bytes(), 24) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_to_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { std::hash::keccak256(\"withdraw(address,uint256,address)\".as_bytes(), 33) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}